/*
  ==============================================================================

    StateManager.cpp
    Created: Auto-generated by Claude Code
    
    强大的统一状态机管理器实现
    基于用户6大核心观点的完整状态转换逻辑

  ==============================================================================
*/

#include "StateManager.h"

// =============================================================================
// MuteMemoryManager 实现
// =============================================================================

MuteMemoryManager::MuteMemoryManager() {
    // 获取插件数据目录用于保存记忆文件
    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory);
    auto pluginDir = appDataDir.getChildFile("MonitorControllerMax");
    pluginDir.createDirectory();
    memoryFile = pluginDir.getChildFile("MuteMemory.json");
    
    // 启动时加载记忆
    loadFromFile();
}

void MuteMemoryManager::saveMuteMemory(const std::map<int, ChannelState>& currentStates) {
    persistentMuteMemory.clear();
    
    // 保存所有手动Mute的通道
    for (const auto& pair : currentStates) {
        if (pair.second == ChannelState::ManualMute) {
            persistentMuteMemory[pair.first] = true;
        }
    }
    
    DBG("Mute memory saved: " << persistentMuteMemory.size() << " channels");
    saveToFile();
}

void MuteMemoryManager::restoreMuteMemory(std::map<int, ChannelState>& channelStates) {
    for (const auto& pair : persistentMuteMemory) {
        if (pair.second) {
            channelStates[pair.first] = ChannelState::ManualMute;
            DBG("Restoring Mute memory: Channel " << pair.first);
        }
    }
}

void MuteMemoryManager::clearMuteMemory() {
    persistentMuteMemory.clear();
    saveToFile();
    DBG("Mute memory cleared");
}

bool MuteMemoryManager::hasMemory() const {
    return !persistentMuteMemory.empty();
}

void MuteMemoryManager::saveToFile() {
    juce::var jsonData = juce::var(new juce::DynamicObject());
    auto* obj = jsonData.getDynamicObject();
    
    for (const auto& pair : persistentMuteMemory) {
        obj->setProperty(juce::String(pair.first), pair.second);
    }
    
    auto jsonString = juce::JSON::toString(jsonData);
    memoryFile.replaceWithText(jsonString);
}

void MuteMemoryManager::loadFromFile() {
    if (!memoryFile.existsAsFile()) return;
    
    auto jsonString = memoryFile.loadFileAsString();
    auto jsonData = juce::JSON::parse(jsonString);
    
    if (jsonData.isObject()) {
        auto* obj = jsonData.getDynamicObject();
        for (auto& prop : obj->getProperties()) {
            int channelIndex = prop.name.toString().getIntValue();
            bool isMuted = (bool)prop.value;
            if (isMuted) {
                persistentMuteMemory[channelIndex] = true;
            }
        }
        DBG("Loaded Mute memory from file: " << persistentMuteMemory.size() << " channels");
    }
}

// =============================================================================
// StateManager 实现
// =============================================================================

StateManager::StateManager() {
    muteMemory = std::make_unique<MuteMemoryManager>();
    
    // 注意：延迟记忆恢复到回调函数设置完成后
    // 这避免了在回调未设置时触发setChannelState()调用
    
    DBG("StateManager basic initialization completed - Current state: " << getStateDescription());
}

StateManager::~StateManager() {
    // 析构时保存当前记忆
    if (currentState == SystemState::MuteActive || currentState == SystemState::SoloMuteActive) {
        muteMemory->saveMuteMemory(channelStates);
    }
}

void StateManager::setParameterUpdateCallback(std::function<void(int, float)> callback) {
    parameterUpdateCallback = callback;
}

void StateManager::setUIUpdateCallback(std::function<void()> callback) {
    uiUpdateCallback = callback;
}

void StateManager::completeInitialization() {
    // 现在安全地恢复Mute记忆，因为回调已经设置
    if (muteMemory->hasMemory()) {
        muteMemory->restoreMuteMemory(channelStates);
        if (hasAnyMuteChannels()) {
            currentState = SystemState::MuteActive;
        }
        DBG("StateManager memory restoration completed - Restored channels: " << channelStates.size());
    }
}

// =============================================================================
// 核心交互逻辑 - 基于6大观点实现
// =============================================================================

void StateManager::handleSoloButtonClick() {
    logStateChange("Solo button click");
    
    switch (currentState) {
        case SystemState::Normal:
            // 观点1：按钮激活 = 选择状态
            transitionTo(SystemState::SoloSelecting);
            break;
            
        case SystemState::SoloSelecting:
            // 观点3：主按钮点击 = 全清除+退出选择
            transitionTo(SystemState::Normal);
            break;
            
        case SystemState::MuteSelecting:
            // 切换选择模式
            transitionTo(SystemState::SoloSelecting);
            break;
            
        case SystemState::SoloActive:
        case SystemState::SoloMuteActive:
            // 观点3：全清除所有Solo状态，恢复到Normal
            clearAllSoloStates();
            clearAllAutoMutes();
            
            // 如果有Mute记忆，恢复它
            if (muteMemory->hasMemory()) {
                muteMemory->restoreMuteMemory(channelStates);
                if (hasAnyMuteChannels()) {
                    transitionTo(SystemState::MuteActive);
                } else {
                    transitionTo(SystemState::Normal);
                }
            } else {
                transitionTo(SystemState::Normal);
            }
            break;
            
        case SystemState::MuteActive:
            // 观点6：保存当前Mute为记忆，进入Solo选择
            muteMemory->saveMuteMemory(channelStates);
            transitionTo(SystemState::SoloSelecting);
            break;
    }
}

void StateManager::handleMuteButtonClick() {
    logStateChange("Mute button click");
    
    switch (currentState) {
        case SystemState::SoloMuteActive:
        case SystemState::SoloActive:
            // 观点2：Solo优先级高于Mute - Mute按钮无效
            DBG("Solo priority: Mute button click ignored");
            return;
            
        case SystemState::Normal:
            // 观点1：按钮激活 = 选择状态
            transitionTo(SystemState::MuteSelecting);
            break;
            
        case SystemState::MuteSelecting:
            // 观点3：主按钮点击 = 退出选择
            transitionTo(SystemState::Normal);
            break;
            
        case SystemState::SoloSelecting:
            // 切换选择模式
            transitionTo(SystemState::MuteSelecting);
            break;
            
        case SystemState::MuteActive:
            // 观点3：全清除所有Mute状态
            clearAllMuteStates();
            muteMemory->clearMuteMemory();
            transitionTo(SystemState::Normal);
            break;
    }
}

void StateManager::handleChannelClick(int channelIndex) {
    logStateChange("Channel click: " + juce::String(channelIndex));
    
    switch (currentState) {
        case SystemState::Normal:
            // 观点6：无选择状态下通道点击无效
            DBG("Channel click invalid in Normal state");
            return;
            
        case SystemState::SoloSelecting:
            // 执行Solo操作
            setChannelState(channelIndex, ChannelState::Solo);
            applyAutoMuteToOthers(channelIndex);
            transitionTo(SystemState::SoloMuteActive);
            break;
            
        case SystemState::MuteSelecting:
            // 执行Mute操作
            toggleChannelMute(channelIndex);
            updateSystemStateBasedOnChannels();
            break;
            
        case SystemState::SoloActive:
        case SystemState::SoloMuteActive:
            // Solo状态下的通道操作：添加/移除Solo
            if (isChannelSolo(channelIndex)) {
                removeChannelSolo(channelIndex);
                // 观点4-5：如果还有其他Solo通道，保持Solo状态
                // 如果没有Solo通道了，回到SoloSelecting
                recalculateAutoMutes();
                if (hasAnySoloChannels()) {
                    // 保持当前状态或转换为SoloActive
                    transitionTo(hasAnyAutoMuteChannels() ? 
                                SystemState::SoloMuteActive : SystemState::SoloActive);
                } else {
                    transitionTo(SystemState::SoloSelecting);
                }
            } else {
                addChannelSolo(channelIndex);
                recalculateAutoMutes();
                transitionTo(SystemState::SoloMuteActive);
            }
            break;
            
        case SystemState::MuteActive:
            // Mute状态下的通道操作
            toggleChannelMute(channelIndex);
            if (!hasAnyMuteChannels()) {
                // 观点4-5：回到选择状态，不直接退出
                transitionTo(SystemState::MuteSelecting);
            }
            break;
    }
}

// =============================================================================
// 状态转换核心
// =============================================================================

void StateManager::transitionTo(SystemState newState) {
    if (currentState == newState) return;
    
    auto oldState = currentState;
    currentState = newState;
    
    DBG("State transition: " << (int)oldState << " -> " << (int)newState 
        << " (" << getStateDescription() << ")");
    
    // 触发UI更新
    if (uiUpdateCallback) {
        uiUpdateCallback();
    }
}

// =============================================================================
// 辅助函数实现
// =============================================================================

void StateManager::applyAutoMuteToOthers(int soloChannelIndex) {
    for (auto& pair : channelStates) {
        int channelIndex = pair.first;
        if (channelIndex != soloChannelIndex && pair.second != ChannelState::Solo) {
            // 保留已有的手动Mute，其他设为auto-mute
            if (pair.second != ChannelState::ManualMute) {
                setChannelState(channelIndex, ChannelState::AutoMute);
            }
        }
    }
    
    // 为新通道也设置auto-mute（如果它们还没有状态）
    for (int i = 0; i < 26; ++i) {
        if (i != soloChannelIndex && channelStates.find(i) == channelStates.end()) {
            setChannelState(i, ChannelState::AutoMute);
        }
    }
}

void StateManager::recalculateAutoMutes() {
    // 先清除所有auto-mute
    clearAllAutoMutes();
    
    // 如果有Solo通道，重新计算auto-mute
    if (hasAnySoloChannels()) {
        for (int i = 0; i < 26; ++i) {
            if (!isChannelSolo(i) && getChannelState(i) != ChannelState::ManualMute) {
                setChannelState(i, ChannelState::AutoMute);
            }
        }
    }
}

void StateManager::clearAllSoloStates() {
    // 安全方式：先收集需要清除的通道，再批量处理
    std::vector<int> channelsToModify;
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::Solo) {
            channelsToModify.push_back(pair.first);
        }
    }
    
    // 安全地修改状态
    for (int channelIndex : channelsToModify) {
        setChannelState(channelIndex, ChannelState::Normal);
    }
}

void StateManager::clearAllMuteStates() {
    // 安全方式：先收集需要清除的通道，再批量处理
    std::vector<int> channelsToModify;
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::ManualMute) {
            channelsToModify.push_back(pair.first);
        }
    }
    
    // 安全地修改状态
    for (int channelIndex : channelsToModify) {
        setChannelState(channelIndex, ChannelState::Normal);
    }
}

void StateManager::clearAllAutoMutes() {
    // 安全方式：先收集需要清除的通道，再批量处理
    std::vector<int> channelsToModify;
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::AutoMute) {
            channelsToModify.push_back(pair.first);
        }
    }
    
    // 安全地修改状态
    for (int channelIndex : channelsToModify) {
        setChannelState(channelIndex, ChannelState::Normal);
    }
}

bool StateManager::hasAnySoloChannels() const {
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::Solo) {
            return true;
        }
    }
    return false;
}

bool StateManager::hasAnyMuteChannels() const {
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::ManualMute) {
            return true;
        }
    }
    return false;
}

bool StateManager::hasAnyAutoMuteChannels() const {
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::AutoMute) {
            return true;
        }
    }
    return false;
}

void StateManager::setChannelState(int channelIndex, ChannelState newState) {
    auto oldState = getChannelState(channelIndex);
    
    if (newState == ChannelState::Normal) {
        channelStates.erase(channelIndex);
    } else {
        channelStates[channelIndex] = newState;
    }
    
    // 更新参数值 - 传递channelIndex给回调函数
    if (parameterUpdateCallback) {
        // 检查是否需要更新Solo参数
        if (oldState == ChannelState::Solo || newState == ChannelState::Solo) {
            parameterUpdateCallback(channelIndex, 1.0f); // 通道索引，参数值
        }
        
        // 检查是否需要更新Mute参数  
        bool shouldBeMuted = (newState == ChannelState::ManualMute || 
                             newState == ChannelState::AutoMute);
        bool wasMuted = (oldState == ChannelState::ManualMute || 
                        oldState == ChannelState::AutoMute);
        
        if (shouldBeMuted != wasMuted) {
            parameterUpdateCallback(channelIndex, 0.0f); // 通道索引，参数值
        }
    }
    
    DBG("Channel state update: " << channelIndex << " -> " << (int)newState);
}

bool StateManager::isChannelSolo(int channelIndex) const {
    return getChannelState(channelIndex) == ChannelState::Solo;
}

void StateManager::removeChannelSolo(int channelIndex) {
    setChannelState(channelIndex, ChannelState::Normal);
}

void StateManager::addChannelSolo(int channelIndex) {
    setChannelState(channelIndex, ChannelState::Solo);
}

void StateManager::toggleChannelMute(int channelIndex) {
    auto currentChannelState = getChannelState(channelIndex);
    if (currentChannelState == ChannelState::ManualMute) {
        setChannelState(channelIndex, ChannelState::Normal);
    } else {
        setChannelState(channelIndex, ChannelState::ManualMute);
    }
}

void StateManager::updateSystemStateBasedOnChannels() {
    if (hasAnyMuteChannels()) {
        transitionTo(SystemState::MuteActive);
    } else {
        transitionTo(SystemState::MuteSelecting);
    }
}

// =============================================================================
// 状态查询接口
// =============================================================================

SystemState StateManager::getCurrentState() const {
    return currentState;
}

ChannelState StateManager::getChannelState(int channelIndex) const {
    auto it = channelStates.find(channelIndex);
    return (it != channelStates.end()) ? it->second : ChannelState::Normal;
}

bool StateManager::shouldSoloButtonBeActive() const {
    return (currentState == SystemState::SoloSelecting || 
            currentState == SystemState::SoloActive ||
            currentState == SystemState::SoloMuteActive);
}

bool StateManager::shouldMuteButtonBeActive() const {
    return (currentState == SystemState::MuteSelecting ||
            currentState == SystemState::MuteActive ||
            currentState == SystemState::SoloMuteActive);
}

bool StateManager::shouldChannelBeActive(int channelIndex) const {
    auto state = getChannelState(channelIndex);
    return (state == ChannelState::Solo || 
            state == ChannelState::ManualMute || 
            state == ChannelState::AutoMute);
}

juce::Colour StateManager::getChannelColour(int channelIndex) const {
    auto state = getChannelState(channelIndex);
    switch (state) {
        case ChannelState::Solo:
            return juce::Colours::green;
        case ChannelState::ManualMute:
            return juce::Colours::red;
        case ChannelState::AutoMute:
            return juce::Colours::darkred;
        case ChannelState::Normal:
        default:
            return juce::Colours::grey;
    }
}

// =============================================================================
// 记忆管理接口
// =============================================================================

void StateManager::saveMuteMemoryNow() {
    muteMemory->saveMuteMemory(channelStates);
}

void StateManager::restoreMuteMemoryNow() {
    muteMemory->restoreMuteMemory(channelStates);
}

void StateManager::clearMuteMemoryNow() {
    muteMemory->clearMuteMemory();
}

// =============================================================================
// 调试和日志
// =============================================================================

juce::String StateManager::getStateDescription() const {
    switch (currentState) {
        case SystemState::Normal: return "Normal";
        case SystemState::SoloSelecting: return "SoloSelecting";
        case SystemState::MuteSelecting: return "MuteSelecting";
        case SystemState::SoloActive: return "SoloActive";
        case SystemState::MuteActive: return "MuteActive";
        case SystemState::SoloMuteActive: return "SoloMuteActive";
        default: return "Unknown";
    }
}

void StateManager::logStateChange(const juce::String& operation) const {
    DBG("StateManager: " << operation << " | Current state: " << getStateDescription() 
        << " | Solo channels: " << (hasAnySoloChannels() ? "Yes" : "No")
        << " | Mute channels: " << (hasAnyMuteChannels() ? "Yes" : "No"));
}