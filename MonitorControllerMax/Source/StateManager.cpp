/*
  ==============================================================================

    StateManager.cpp
    Created: Auto-generated by Claude Code
    
    强大的统一状态机管理器实现
    基于用户6大核心观点的完整状态转换逻辑

  ==============================================================================
*/

#include "StateManager.h"
#include "DebugLogger.h"

// =============================================================================
// MuteMemoryManager 实现
// =============================================================================

MuteMemoryManager::MuteMemoryManager() {
    // 获取插件数据目录用于保存记忆文件
    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory);
    auto pluginDir = appDataDir.getChildFile("MonitorControllerMax");
    pluginDir.createDirectory();
    memoryFile = pluginDir.getChildFile("MuteMemory.json");
    
    // 启动时加载记忆
    loadFromFile();
}

void MuteMemoryManager::saveMuteMemory(const std::map<int, ChannelState>& currentStates) {
    // 计算要保存的手动Mute通道数量
    std::map<int, bool> newMemory;
    for (const auto& pair : currentStates) {
        if (pair.second == ChannelState::ManualMute) {
            newMemory[pair.first] = true;
        }
    }
    
    // 防止用空记忆覆盖有效记忆
    // 只有在以下情况才真正保存：
    // 1. 新记忆不为空，或者
    // 2. 当前没有任何记忆（首次保存）
    if (!newMemory.empty() || persistentMuteMemory.empty()) {
        persistentMuteMemory = newMemory;
        VST3_DBG("Mute memory saved: " << persistentMuteMemory.size() << " channels");
        saveToFile();
    } else {
        VST3_DBG("Mute memory save skipped: would overwrite " << persistentMuteMemory.size() 
                 << " existing channels with 0 channels");
    }
}

void MuteMemoryManager::restoreMuteMemory(std::map<int, ChannelState>& channelStates) {
    for (const auto& pair : persistentMuteMemory) {
        if (pair.second) {
            channelStates[pair.first] = ChannelState::ManualMute;
            VST3_DBG("Restoring Mute memory: Channel " << pair.first);
        }
    }
}

void MuteMemoryManager::clearMuteMemory() {
    persistentMuteMemory.clear();
    saveToFile();
    VST3_DBG("Mute memory cleared");
}

bool MuteMemoryManager::hasMemory() const {
    return !persistentMuteMemory.empty();
}

void MuteMemoryManager::saveToFile() {
    juce::var jsonData = juce::var(new juce::DynamicObject());
    auto* obj = jsonData.getDynamicObject();
    
    for (const auto& pair : persistentMuteMemory) {
        obj->setProperty(juce::String(pair.first), pair.second);
    }
    
    auto jsonString = juce::JSON::toString(jsonData);
    memoryFile.replaceWithText(jsonString);
}

void MuteMemoryManager::loadFromFile() {
    if (!memoryFile.existsAsFile()) return;
    
    auto jsonString = memoryFile.loadFileAsString();
    auto jsonData = juce::JSON::parse(jsonString);
    
    if (jsonData.isObject()) {
        auto* obj = jsonData.getDynamicObject();
        for (auto& prop : obj->getProperties()) {
            int channelIndex = prop.name.toString().getIntValue();
            bool isMuted = (bool)prop.value;
            if (isMuted) {
                persistentMuteMemory[channelIndex] = true;
            }
        }
        VST3_DBG("Loaded Mute memory from file: " << persistentMuteMemory.size() << " channels");
    }
}

// =============================================================================
// StateManager 实现
// =============================================================================

StateManager::StateManager() {
    muteMemory = std::make_unique<MuteMemoryManager>();
    
    // 注意：延迟记忆恢复到回调函数设置完成后
    // 这避免了在回调未设置时触发setChannelState()调用
    
    VST3_DBG("StateManager basic initialization completed - Current state: " << getStateDescription());
}

StateManager::~StateManager() {
    // 析构时保存当前记忆
    if (currentState == SystemState::MuteActive || currentState == SystemState::SoloMuteActive) {
        muteMemory->saveMuteMemory(channelStates);
    }
}

void StateManager::setParameterUpdateCallback(std::function<void(int, float)> callback) {
    parameterUpdateCallback = callback;
}

void StateManager::setUIUpdateCallback(std::function<void()> callback) {
    uiUpdateCallback = callback;
}

void StateManager::completeInitialization() {
    // 现在安全地恢复Mute记忆，因为回调已经设置
    if (muteMemory->hasMemory()) {
        muteMemory->restoreMuteMemory(channelStates);
        if (hasAnyMuteChannels()) {
            currentState = SystemState::MuteActive;
        }
        VST3_DBG("StateManager memory restoration completed - Restored channels: " << channelStates.size());
    }
}

// =============================================================================
// 核心交互逻辑 - 基于6大观点实现
// =============================================================================

void StateManager::handleSoloButtonClick() {
    logStateChange("Solo button click");
    
    switch (currentState) {
        case SystemState::Normal:
            // 观点1：按钮激活 = 选择状态
            // 在进入Solo选择模式前，保存当前任何Mute状态为记忆
            if (hasAnyMuteChannels()) {
                muteMemory->saveMuteMemory(channelStates);
                VST3_DBG("Saved existing Mute states as memory before Solo selection");
            }
            transitionTo(SystemState::SoloSelecting);
            break;
            
        case SystemState::SoloSelecting:
            // 观点3：主按钮点击 = 全清除+退出选择
            // 退出Solo选择模式时，需要恢复Mute记忆（如果存在）
            if (muteMemory->hasMemory()) {
                muteMemory->restoreMuteMemory(channelStates);
                if (hasAnyMuteChannels()) {
                    transitionTo(SystemState::MuteActive);
                    VST3_DBG("Restored Mute memory when exiting SoloSelecting");
                } else {
                    muteMemory->clearMuteMemory();  // 清空无效记忆
                    transitionTo(SystemState::Normal);
                }
            } else {
                transitionTo(SystemState::Normal);
            }
            break;
            
        case SystemState::MuteSelecting:
            // 切换选择模式 - 保存当前Mute状态为记忆
            if (hasAnyMuteChannels()) {
                muteMemory->saveMuteMemory(channelStates);
                VST3_DBG("Saved Mute states as memory when switching to Solo selection");
            }
            transitionTo(SystemState::SoloSelecting);
            break;
            
        case SystemState::SoloActive:
        case SystemState::SoloMuteActive:
            // 观点3：全清除所有Solo状态，恢复到Normal
            clearAllSoloStates();
            clearAllAutoMutes();
            
            // 如果有Mute记忆，恢复它
            if (muteMemory->hasMemory()) {
                muteMemory->restoreMuteMemory(channelStates);
                if (hasAnyMuteChannels()) {
                    transitionTo(SystemState::MuteActive);
                } else {
                    muteMemory->clearMuteMemory();  // 清空无效记忆
                    transitionTo(SystemState::Normal);
                }
            } else {
                transitionTo(SystemState::Normal);
            }
            break;
            
        case SystemState::MuteActive:
            // 观点6：保存当前Mute为记忆，但清除当前显示状态
            muteMemory->saveMuteMemory(channelStates);
            clearAllMuteStates();  // 清除当前Mute显示，但保留记忆
            transitionTo(SystemState::SoloSelecting);
            break;
    }
}

void StateManager::handleMuteButtonClick() {
    logStateChange("Mute button click");
    
    switch (currentState) {
        case SystemState::SoloMuteActive:
            // 在SoloMuteActive状态下，Mute按钮表示清除记忆
            // 这样可以让用户在Solo状态下控制Mute记忆
            if (muteMemory->hasMemory()) {
                muteMemory->clearMuteMemory();
                VST3_DBG("Mute memory cleared in SoloMuteActive state");
                // 手动触发UI更新以反映Mute按钮状态变化
                if (uiUpdateCallback) {
                    uiUpdateCallback();
                }
            }
            break;
            
        case SystemState::SoloActive:
            // 纯Solo状态下Mute按钮无效
            VST3_DBG("Solo priority: Mute button click ignored in SoloActive");
            return;
            
        case SystemState::Normal:
            // 观点1：按钮激活 = 选择状态
            transitionTo(SystemState::MuteSelecting);
            break;
            
        case SystemState::MuteSelecting:
            // 观点3：主按钮点击 = 退出选择
            transitionTo(SystemState::Normal);
            break;
            
        case SystemState::SoloSelecting:
            // 切换选择模式
            transitionTo(SystemState::MuteSelecting);
            break;
            
        case SystemState::MuteActive:
            // 观点3：全清除所有Mute状态
            clearAllMuteStates();
            muteMemory->clearMuteMemory();
            transitionTo(SystemState::Normal);
            break;
    }
}

void StateManager::handleChannelClick(int channelIndex) {
    logStateChange("Channel click: " + juce::String(channelIndex));
    
    switch (currentState) {
        case SystemState::Normal:
            // 观点6：无选择状态下通道点击无效
            VST3_DBG("Channel click invalid in Normal state");
            return;
            
        case SystemState::SoloSelecting:
            // 注意：记忆在MuteActive->SoloSelecting转换时已经保存了
            // 这里只需要清除当前Mute显示状态，不需要重新保存记忆
            
            // 清除所有手动Mute状态（Solo会接管控制）
            clearAllMuteStates();
            
            // 设置Solo状态
            setChannelState(channelIndex, ChannelState::Solo);
            applyAutoMuteToOthers(channelIndex);
            transitionTo(SystemState::SoloMuteActive);
            break;
            
        case SystemState::MuteSelecting:
            // 执行Mute操作
            toggleChannelMute(channelIndex);
            updateSystemStateBasedOnChannels();
            break;
            
        case SystemState::SoloActive:
        case SystemState::SoloMuteActive:
            // Solo状态下的通道操作：添加/移除Solo
            if (isChannelSolo(channelIndex)) {
                removeChannelSolo(channelIndex);
                // 观点4-5：如果还有其他Solo通道，保持Solo状态
                // 如果没有Solo通道了，回到SoloSelecting
                recalculateAutoMutes();
                if (hasAnySoloChannels()) {
                    // 保持当前状态或转换为SoloActive
                    auto newState = hasAnyAutoMuteChannels() ? 
                                   SystemState::SoloMuteActive : SystemState::SoloActive;
                    if (currentState == newState) {
                        // 状态不变，手动触发UI更新
                        if (uiUpdateCallback) {
                            uiUpdateCallback();
                        }
                    } else {
                        transitionTo(newState);
                    }
                } else {
                    transitionTo(SystemState::SoloSelecting);
                }
            } else {
                // 多声道Solo支持：添加新Solo通道
                // 如果这个通道之前是ManualMute，需要从记忆中移除
                if (getChannelState(channelIndex) == ChannelState::ManualMute) {
                    // 从Mute记忆中移除这个通道，因为Solo会覆盖Mute
                    auto currentMemory = channelStates;
                    currentMemory.erase(channelIndex);  // 临时移除以更新记忆
                    muteMemory->saveMuteMemory(currentMemory);
                }
                
                setChannelState(channelIndex, ChannelState::Solo);
                // 重新计算AutoMute：所有非Solo通道设为AutoMute
                recalculateAutoMutes();
                // 状态不变，但需要手动触发UI更新
                if (uiUpdateCallback) {
                    uiUpdateCallback();
                }
            }
            break;
            
        case SystemState::MuteActive:
            // Mute状态下的通道操作：多声道控制器支持多个Mute
            if (getChannelState(channelIndex) == ChannelState::ManualMute) {
                // 如果已经是Mute，则取消Mute
                setChannelState(channelIndex, ChannelState::Normal);
                if (!hasAnyMuteChannels()) {
                    // 观点4-5：回到选择状态，不直接退出
                    transitionTo(SystemState::MuteSelecting);
                }
            } else {
                // 如果不是Mute，则添加到Mute列表（多声道支持）
                setChannelState(channelIndex, ChannelState::ManualMute);
                // 保持在MuteActive状态，但需要手动触发UI更新
                if (uiUpdateCallback) {
                    uiUpdateCallback();
                }
            }
            break;
    }
}

// =============================================================================
// 状态转换核心
// =============================================================================

void StateManager::transitionTo(SystemState newState) {
    if (currentState == newState) return;
    
    auto oldState = currentState;
    currentState = newState;
    
    VST3_DBG("State transition: " << (int)oldState << " -> " << (int)newState 
        << " (" << getStateDescription() << ")");
    
    // 触发UI更新
    if (uiUpdateCallback) {
        uiUpdateCallback();
    }
}

// =============================================================================
// 辅助函数实现
// =============================================================================

void StateManager::applyAutoMuteToOthers(int soloChannelIndex) {
    for (auto& pair : channelStates) {
        int channelIndex = pair.first;
        if (channelIndex != soloChannelIndex && pair.second != ChannelState::Solo) {
            // 保留已有的手动Mute，其他设为auto-mute
            if (pair.second != ChannelState::ManualMute) {
                setChannelState(channelIndex, ChannelState::AutoMute);
            }
        }
    }
    
    // 为新通道也设置auto-mute（如果它们还没有状态）
    for (int i = 0; i < 26; ++i) {
        if (i != soloChannelIndex && channelStates.find(i) == channelStates.end()) {
            setChannelState(i, ChannelState::AutoMute);
        }
    }
}

void StateManager::recalculateAutoMutes() {
    // 先清除所有auto-mute
    clearAllAutoMutes();
    
    // 如果有Solo通道，重新计算auto-mute
    if (hasAnySoloChannels()) {
        for (int i = 0; i < 26; ++i) {
            if (!isChannelSolo(i) && getChannelState(i) != ChannelState::ManualMute) {
                setChannelState(i, ChannelState::AutoMute);
            }
        }
    }
}

void StateManager::clearAllSoloStates() {
    // 安全方式：先收集需要清除的通道，再批量处理
    std::vector<int> channelsToModify;
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::Solo) {
            channelsToModify.push_back(pair.first);
        }
    }
    
    // 安全地修改状态
    for (int channelIndex : channelsToModify) {
        setChannelState(channelIndex, ChannelState::Normal);
    }
}

void StateManager::clearAllMuteStates() {
    // 安全方式：先收集需要清除的通道，再批量处理
    std::vector<int> channelsToModify;
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::ManualMute) {
            channelsToModify.push_back(pair.first);
        }
    }
    
    // 安全地修改状态
    for (int channelIndex : channelsToModify) {
        setChannelState(channelIndex, ChannelState::Normal);
    }
}

void StateManager::clearAllAutoMutes() {
    // 安全方式：先收集需要清除的通道，再批量处理
    std::vector<int> channelsToModify;
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::AutoMute) {
            channelsToModify.push_back(pair.first);
        }
    }
    
    // 安全地修改状态
    for (int channelIndex : channelsToModify) {
        setChannelState(channelIndex, ChannelState::Normal);
    }
}

bool StateManager::hasAnySoloChannels() const {
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::Solo) {
            return true;
        }
    }
    return false;
}

bool StateManager::hasAnyMuteChannels() const {
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::ManualMute) {
            return true;
        }
    }
    return false;
}

bool StateManager::hasAnyAutoMuteChannels() const {
    for (const auto& pair : channelStates) {
        if (pair.second == ChannelState::AutoMute) {
            return true;
        }
    }
    return false;
}

void StateManager::setChannelState(int channelIndex, ChannelState newState) {
    auto oldState = getChannelState(channelIndex);
    
    if (newState == ChannelState::Normal) {
        channelStates.erase(channelIndex);
    } else {
        channelStates[channelIndex] = newState;
    }
    
    // 更新参数值 - 传递channelIndex给回调函数
    if (parameterUpdateCallback) {
        // 检查是否需要更新Solo参数
        if (oldState == ChannelState::Solo || newState == ChannelState::Solo) {
            parameterUpdateCallback(channelIndex, 1.0f); // 通道索引，参数值
        }
        
        // 检查是否需要更新Mute参数  
        bool shouldBeMuted = (newState == ChannelState::ManualMute || 
                             newState == ChannelState::AutoMute);
        bool wasMuted = (oldState == ChannelState::ManualMute || 
                        oldState == ChannelState::AutoMute);
        
        if (shouldBeMuted != wasMuted) {
            parameterUpdateCallback(channelIndex, 0.0f); // 通道索引，参数值
        }
    }
    
    VST3_DBG("Channel state update: " << channelIndex << " -> " << (int)newState);
}

bool StateManager::isChannelSolo(int channelIndex) const {
    return getChannelState(channelIndex) == ChannelState::Solo;
}

void StateManager::removeChannelSolo(int channelIndex) {
    setChannelState(channelIndex, ChannelState::Normal);
}

void StateManager::addChannelSolo(int channelIndex) {
    setChannelState(channelIndex, ChannelState::Solo);
}

void StateManager::toggleChannelMute(int channelIndex) {
    auto currentChannelState = getChannelState(channelIndex);
    if (currentChannelState == ChannelState::ManualMute) {
        setChannelState(channelIndex, ChannelState::Normal);
    } else {
        setChannelState(channelIndex, ChannelState::ManualMute);
    }
}

void StateManager::updateSystemStateBasedOnChannels() {
    if (hasAnyMuteChannels()) {
        transitionTo(SystemState::MuteActive);
    } else {
        transitionTo(SystemState::MuteSelecting);
    }
}

// =============================================================================
// 状态查询接口
// =============================================================================

SystemState StateManager::getCurrentState() const {
    return currentState;
}

ChannelState StateManager::getChannelState(int channelIndex) const {
    auto it = channelStates.find(channelIndex);
    return (it != channelStates.end()) ? it->second : ChannelState::Normal;
}

bool StateManager::shouldSoloButtonBeActive() const {
    return (currentState == SystemState::SoloSelecting || 
            currentState == SystemState::SoloActive ||
            currentState == SystemState::SoloMuteActive);
}

bool StateManager::shouldMuteButtonBeActive() const {
    // Mute按钮激活条件：正在选择Mute或有手动Mute的通道
    return (currentState == SystemState::MuteSelecting ||
            currentState == SystemState::MuteActive ||
            (currentState == SystemState::SoloMuteActive && muteMemory->hasMemory()));
}

bool StateManager::shouldChannelBeActive(int channelIndex) const {
    auto state = getChannelState(channelIndex);
    // 修复Solo模式UI显示错误：AutoMute通道不应该显示为激活按钮
    // 只有Solo和ManualMute通道才应该显示为激活状态
    bool shouldBeActive = (state == ChannelState::Solo || 
                          state == ChannelState::ManualMute);
    
    // 详细调试信息
    if (state == ChannelState::Solo) {
        VST3_DBG("UI Query: Channel " << channelIndex << " should be ACTIVE (Solo state)");
    } else if (state == ChannelState::ManualMute) {
        VST3_DBG("UI Query: Channel " << channelIndex << " should be ACTIVE (ManualMute state)");
    } else if (state == ChannelState::AutoMute) {
        VST3_DBG("UI Query: Channel " << channelIndex << " should be INACTIVE (AutoMute state - visually normal but functionally muted)");
    } else {
        VST3_DBG("UI Query: Channel " << channelIndex << " should be INACTIVE (Normal state)");
    }
    
    return shouldBeActive;
}

juce::Colour StateManager::getChannelColour(int channelIndex) const {
    auto state = getChannelState(channelIndex);
    switch (state) {
        case ChannelState::Solo:
            return juce::Colours::green;  // 纯绿色 - Solo状态
        case ChannelState::ManualMute:
        case ChannelState::AutoMute:
            return juce::Colours::red;    // 统一纯红色 - 所有Mute状态
        case ChannelState::Normal:
        default:
            return juce::Colours::grey;
    }
}

// =============================================================================
// 记忆管理接口
// =============================================================================

void StateManager::saveMuteMemoryNow() {
    muteMemory->saveMuteMemory(channelStates);
}

void StateManager::restoreMuteMemoryNow() {
    muteMemory->restoreMuteMemory(channelStates);
}

void StateManager::clearMuteMemoryNow() {
    muteMemory->clearMuteMemory();
}

// =============================================================================
// 参数驱动的状态变化处理
// =============================================================================

void StateManager::handleParameterChange(const juce::String& parameterID, float newValue) {
    VST3_DBG("StateManager handling parameter: " << parameterID << " = " << newValue);
    
    if (parameterID.startsWith("SOLO_")) {
        int channelIndex = parameterID.substring(5).getIntValue() - 1;
        if (channelIndex >= 0 && channelIndex < 26) {
            handleSoloParameterChange(channelIndex, newValue > 0.5f);
        }
    }
    else if (parameterID.startsWith("MUTE_")) {
        int channelIndex = parameterID.substring(5).getIntValue() - 1;
        if (channelIndex >= 0 && channelIndex < 26) {
            handleMuteParameterChange(channelIndex, newValue > 0.5f);
        }
    }
}

void StateManager::handleSoloParameterChange(int channelIndex, bool enabled) {
    VST3_DBG("StateManager handling Solo parameter change: Channel " << channelIndex << " = " << (enabled ? "true" : "false"));
    
    if (enabled) {
        // 直接设置通道为Solo状态，无需模拟UI操作
        channelStates[channelIndex] = ChannelState::Solo;
        
        // 进入Solo模式时，自动保存Mute记忆并静音所有非Solo通道
        if (currentState == SystemState::Normal || currentState == SystemState::MuteActive) {
            // 保存当前Mute状态
            if (muteMemory) {
                muteMemory->saveMuteMemory(channelStates);
            }
            
            // 将所有非Solo通道设为AutoMute
            for (int i = 0; i < 26; ++i) {
                if (i != channelIndex && channelStates[i] != ChannelState::Solo) {
                    channelStates[i] = ChannelState::AutoMute;
                }
            }
            
            currentState = SystemState::SoloActive;
        }
        
        VST3_DBG("Direct state update: Channel " << channelIndex << " set to Solo, System state: " << getStateDescription());
    } else {
        // 直接取消该通道的Solo状态
        if (channelStates[channelIndex] == ChannelState::Solo) {
            channelStates[channelIndex] = ChannelState::Normal;
            
            // 检查是否还有其他Solo通道
            bool hasAnySoloChannels = false;
            for (int i = 0; i < 26; ++i) {
                if (channelStates[i] == ChannelState::Solo) {
                    hasAnySoloChannels = true;
                    break;
                }
            }
            
            // 如果没有Solo通道了，恢复Mute记忆
            if (!hasAnySoloChannels && currentState == SystemState::SoloActive) {
                if (muteMemory) {
                    muteMemory->restoreMuteMemory(channelStates);
                }
                
                // 检查是否有ManualMute通道决定系统状态
                bool hasAnyMuteChannels = false;
                for (int i = 0; i < 26; ++i) {
                    if (channelStates[i] == ChannelState::ManualMute) {
                        hasAnyMuteChannels = true;
                        break;
                    }
                }
                
                currentState = hasAnyMuteChannels ? SystemState::MuteActive : SystemState::Normal;
            }
            
            VST3_DBG("Direct state update: Channel " << channelIndex << " Solo removed, System state: " << getStateDescription());
        }
    }
    
    // 通知UI更新
    if (uiUpdateCallback) {
        uiUpdateCallback();
    }
}

void StateManager::handleMuteParameterChange(int channelIndex, bool enabled) {
    VST3_DBG("StateManager handling Mute parameter change: Channel " << channelIndex << " = " << (enabled ? "true" : "false"));
    
    // 检查Solo/Mute互斥：如果通道已经Solo，不允许Mute
    if (enabled && getChannelState(channelIndex) == ChannelState::Solo) {
        VST3_DBG("Cannot mute a Solo channel: " << channelIndex);
        return;
    }
    
    // 检查AutoMute保护：如果通道处于AutoMute状态，不允许用户直接取消
    if (!enabled && getChannelState(channelIndex) == ChannelState::AutoMute) {
        VST3_DBG("Cannot unmute AutoMute channel through parameter: " << channelIndex << " (controlled by Solo)");
        return;
    }
    
    if (enabled) {
        // 直接设置通道为Mute状态，无需模拟UI操作
        channelStates[channelIndex] = ChannelState::ManualMute;
        
        // 如果没有其他Mute通道，切换到MuteActive状态
        bool hasOtherMuteChannels = false;
        for (int i = 0; i < 26; ++i) {
            if (i != channelIndex && channelStates[i] == ChannelState::ManualMute) {
                hasOtherMuteChannels = true;
                break;
            }
        }
        
        if (currentState == SystemState::Normal || !hasOtherMuteChannels) {
            currentState = SystemState::MuteActive;
        }
        
        VST3_DBG("Direct state update: Channel " << channelIndex << " set to ManualMute, System state: " << getStateDescription());
    } else {
        // 直接取消该通道的Mute状态
        if (channelStates[channelIndex] == ChannelState::ManualMute) {
            channelStates[channelIndex] = ChannelState::Normal;
            
            // 检查是否还有其他Mute通道
            bool hasAnyMuteChannels = false;
            for (int i = 0; i < 26; ++i) {
                if (channelStates[i] == ChannelState::ManualMute) {
                    hasAnyMuteChannels = true;
                    break;
                }
            }
            
            // 如果没有Mute通道了，返回Normal状态
            if (!hasAnyMuteChannels && currentState == SystemState::MuteActive) {
                currentState = SystemState::Normal;
            }
            
            VST3_DBG("Direct state update: Channel " << channelIndex << " set to Normal, System state: " << getStateDescription());
        }
    }
    
    // 通知UI更新
    if (uiUpdateCallback) {
        uiUpdateCallback();
    }
}

// =============================================================================
// 调试和日志
// =============================================================================

juce::String StateManager::getStateDescription() const {
    switch (currentState) {
        case SystemState::Normal: return "Normal";
        case SystemState::SoloSelecting: return "SoloSelecting";
        case SystemState::MuteSelecting: return "MuteSelecting";
        case SystemState::SoloActive: return "SoloActive";
        case SystemState::MuteActive: return "MuteActive";
        case SystemState::SoloMuteActive: return "SoloMuteActive";
        default: return "Unknown";
    }
}

void StateManager::logStateChange(const juce::String& operation) const {
    VST3_DBG("StateManager: " << operation << " | Current state: " << getStateDescription() 
        << " | Solo channels: " << (hasAnySoloChannels() ? "Yes" : "No")
        << " | Mute channels: " << (hasAnyMuteChannels() ? "Yes" : "No"));
}