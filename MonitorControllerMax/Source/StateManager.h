/*
  ==============================================================================

    StateManager.h
    Created: Auto-generated by Claude Code
    
    Powerful unified state machine manager based on 6 core principles
    Completely replaces the previous weak scattered state management

  ==============================================================================
*/

#pragma once

#include <JuceHeader.h>
#include <map>
#include <set>
#include <vector>
#include <functional>

// System state enumeration - designed based on 6 core principles
enum class SystemState {
    Normal,          // Default state: no selection, no activation
    SoloSelecting,   // Solo selection state: Solo button lit, waiting for channel selection
    MuteSelecting,   // Mute selection state: Mute button lit, waiting for channel selection
    SoloActive,      // Solo active state: channels are soloed, others auto-muted
    MuteActive,      // Mute active state: channels manually muted
    SoloMuteActive   // Dual active state: Solo active + auto-mute, Solo has priority
};

// Channel state enumeration - precise state classification
enum class ChannelState {
    Normal,          // Normal state
    ManualMute,      // Manual mute
    AutoMute,        // Auto-mute caused by solo
    Solo             // Solo active
};

// Mute memory manager - implements principle 6 persistent memory
class MuteMemoryManager {
private:
    std::map<int, bool> persistentMuteMemory;
    juce::File memoryFile;
    
public:
    MuteMemoryManager();
    
    // Memory management
    void saveMuteMemory(const std::map<int, ChannelState>& currentStates);
    void restoreMuteMemory(std::map<int, ChannelState>& channelStates);
    void clearMuteMemory();
    bool hasMemory() const;
    
    // Persistence to file (cross-session saving)
    void saveToFile();
    void loadFromFile();
};

// Powerful unified state machine manager
class StateManager {
private:
    SystemState currentState = SystemState::Normal;
    std::map<int, ChannelState> channelStates;
    
    // Mute memory management
    std::unique_ptr<MuteMemoryManager> muteMemory;
    
    // Callback functions - notify external updates
    std::function<void(int, float)> parameterUpdateCallback;
    std::function<void()> uiUpdateCallback;
    
    // Internal helper functions
    void applyAutoMuteToOthers(int soloChannelIndex);
    void recalculateAutoMutes();
    void clearAllSoloStates();
    void clearAllMuteStates();
    void clearAllAutoMutes();
    
    // State query helper functions
    bool hasAnySoloChannels() const;
    bool hasAnyMuteChannels() const;
    bool hasAnyAutoMuteChannels() const;
    
    // Channel operation helper functions
    void setChannelState(int channelIndex, ChannelState newState);
    bool isChannelSolo(int channelIndex) const;
    void removeChannelSolo(int channelIndex);
    void addChannelSolo(int channelIndex);
    void toggleChannelMute(int channelIndex);
    
    // State transition core logic
    void updateSystemStateBasedOnChannels();
    
public:
    StateManager();
    ~StateManager();
    
    // Set callback functions
    void setParameterUpdateCallback(std::function<void(int, float)> callback);
    void setUIUpdateCallback(std::function<void()> callback);
    
    // Complete initialization after callbacks are set
    void completeInitialization();
    
    // Main interaction interfaces - implemented based on 6 core principles
    void handleSoloButtonClick();
    void handleMuteButtonClick();
    void handleChannelClick(int channelIndex);
    
    // State query interfaces
    SystemState getCurrentState() const;
    ChannelState getChannelState(int channelIndex) const;
    
    // UI state queries - for button appearance updates
    bool shouldSoloButtonBeActive() const;
    bool shouldMuteButtonBeActive() const;
    bool shouldChannelBeActive(int channelIndex) const;
    juce::Colour getChannelColour(int channelIndex) const;
    
    // State transition core
    void transitionTo(SystemState newState);
    
    // Memory management interfaces
    void saveMuteMemoryNow();
    void restoreMuteMemoryNow();
    void clearMuteMemoryNow();
    
    // Debug and logging
    juce::String getStateDescription() const;
    void logStateChange(const juce::String& operation) const;
};