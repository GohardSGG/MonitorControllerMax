# 2. 技术架构总览

## 2.1 整体架构图

本系统采用 **Master-Slave 分布式架构**，通过 **ZeroMQ** 网络层实现跨实例、跨机器的高性能状态同步。

```mermaid
graph TB
    subgraph "Master Plugin (Source Control)"
        M_GUI[GUI / OSC Thread]
        M_Logic[Semantic Logic Core]
        M_Net[ZMQ Publisher]
        M_Audio[Audio Thread (Source Mute)]
        
        M_GUI -->|Update Params| M_Logic
        M_Logic -->|Compute RenderState| M_Audio
        M_Logic -->|Serialize| M_Net
    end

    subgraph "Slave Plugin (Monitor Control)"
        S_Net[ZMQ Subscriber]
        S_Cache[AtomicCell RenderState]
        S_Audio[Audio Thread (Gain/Dim/Mute)]
        
        M_Net -.->|TCP/IPC| S_Net
        S_Net -->|Update| S_Cache
        S_Cache -->|Lock-Free Read| S_Audio
    end
```

## 2.2 核心分层策略

我们将系统严格划分为三个安全域，域之间只能通过 **Channel**、**Atomic** 或 **Socket** 通信。

| 模块/层级 | 职责 | 线程环境 | 关键技术 | 内存策略 |
| :--- | :--- | :--- | :--- | :--- |
| **Control Plane** | 业务逻辑 (Solo/Mute/Group) | GUI/Worker | `nih-plug Params`, `Arc<Mutex>` | 核心状态由参数系统管理，复杂逻辑允许堆分配。 |
| **Network Plane** | 跨实例状态广播 | Background Thread | `ZeroMQ (PUB/SUB)`, `Bincode` | 异步 IO，序列化/反序列化。 |
| **Audio Plane** | 信号处理 (Gain/Mute/Dim) | Real-time | `ArcSwap`, `AtomicCell` | **严禁分配**。无锁读取缓存快照。 |

## 2.3 核心技术选型

### 2.3.1 框架与运行时
*   **Plugin Framework**: `nih-plug`。
*   **GUI Stack**: `egui` + `wgpu`。
*   **Network Stack**: `zeromq` (Rust bindings) + `bincode` (序列化)。

### 2.3.2 分布式通信模型 (The ZMQ Way)
*   **模式**: **PUB/SUB (发布/订阅)**。
*   **Master**: 绑定 `tcp://0.0.0.0:9123`，作为状态发布者。
*   **Slave**: 连接 Master IP，作为订阅者。
*   **特性**:
    *   **无状态广播**: Master 只管发，不维护连接状态。
    *   **自动重连**: ZMQ 底层处理 TCP 断连与重连。
    *   **状态保持 (Fail-Safe)**: Slave 在断连期间保持最后收到的有效状态，防止音量突跳。

### 2.3.3 音频处理策略
*   **Master (Source)**: 负责“源头清洗”。仅执行针对校准软件的 Mute 逻辑（如 Solo L 时 Mute R）。**不处理增益**。
*   **Slave (Monitor)**: 负责“最终把关”。执行最终的 Mute（如 Solo SUB 时切断主音箱）以及 **Gain/Dim** 控制。

## 2.4 为什么是 ZeroMQ？

这是为了支持 **跨机协同** 的关键决策：
1.  **统一架构**: 无论是本机（Localhost）还是局域网（LAN），通信代码完全一致。
2.  **解耦**: Master 和 Slave 彻底解耦，不再共享进程内存，消除了野指针风险。
3.  **高性能**: ZMQ 专为高吞吐设计，配合 Bincode 的极小 Payload (约 20 bytes)，延迟极低。

## 2.5 OSC 集成架构

OSC 服务作为 Master 的输入源之一，将外部硬件指令转化为对 `Params` 的修改。反馈逻辑（点灯）由 Master 统一计算后回传给硬件。

**端口配置 (v2.5.x)**:
- 发送端口: 7444 (插件 → 硬件)
- 接收端口: 7445 (硬件 → 插件)

## 2.6 日志架构 (v2.5.0 新增)

### 2.6.1 实例级日志系统

每个 VST 实例拥有独立的日志器，解决多实例日志混乱问题：

```
┌─────────────────────────────────────────────────────────────────────┐
│                        MonitorControllerMax                         │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐           │
│  │  Instance 1  │     │  Instance 2  │     │  Instance N  │           │
│  │ ┌─────────┐ │     │ ┌─────────┐ │     │ ┌─────────┐ │           │
│  │ │ Logger  │ │     │ │ Logger  │ │     │ │ Logger  │ │           │
│  │ └────┬────┘ │     │ └────┬────┘ │     │ └────┬────┘ │           │
│  └──────┼──────┘     └──────┼──────┘     └──────┼──────┘           │
│         ▼                   ▼                   ▼                   │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐           │
│  │ MCM_xxx.log │     │ MCM_yyy.log │     │ MCM_zzz.log │           │
│  └─────────────┘     └─────────────┘     └─────────────┘           │
└─────────────────────────────────────────────────────────────────────┘
```

**日志输出路径**:
- 默认: `C:\Plugins\MCM_Logs\`
- Fallback: `%TEMP%\MonitorControllerMax_Logs\`

**文件命名**: `MCM_{instance_id}_{date}_{time}.log`

### 2.6.2 日志级别

| 级别 | 写入文件 | 写入UI | 使用场景 |
|------|---------|--------|----------|
| Error | ✅ | ❌ | 严重错误 |
| Warn | ✅ | ❌ | 警告信息 |
| Info | ✅ | ❌ | 一般信息 |
| Important | ✅ | ✅ | 关键事件（用户应知晓）|
| Debug | ✅ | ❌ | 调试信息 |

### 2.6.3 Production 模式

通过 Cargo feature 控制：
```bash
cargo xtask bundle monitor_controller_max --production
```

Production 模式下禁用文件日志写入，仅保留 UI 日志缓冲。

## 2.7 热重载架构 (v2.5.0 新增)

### 2.7.1 请求-执行分离模式

热重载采用请求-执行分离设计，避免在 UI 线程进行阻塞操作：

```
┌─────────────┐                    ┌─────────────────────┐
│  UI 线程    │                    │    process() 线程   │
│  (Editor)   │                    │    (音频线程)        │
├─────────────┤                    ├─────────────────────┤
│ 用户修改配置 │                    │  检查重载请求        │
│     │       │                    │       │             │
│     ▼       │                    │       ▼             │
│ request_xxx │  ────────────────▶ │  take_xxx_request   │
│ _restart()  │  (通过 RwLock)     │       │             │
│             │                    │       ▼             │
│             │                    │  shutdown() + init()│
└─────────────┘                    └─────────────────────┘
```

### 2.7.2 支持的热重载项

| 触发源 | 热重载类型 | 触发方法 |
|--------|-----------|---------|
| Settings 保存 OSC 端口 | OSC | `request_osc_restart()` |
| Settings 保存 Network 端口 | Network | `request_network_restart()` |
| UI 切换 Role | Network | `request_network_restart()` |
| 心跳超时 (Slave) | Network | `request_network_restart()` |

## 2.8 网络协议 v2 (v2.5.0 新增)

### 2.8.1 协议字段

```rust
pub struct NetworkInteractionState {
    // === 协议元数据 ===
    pub protocol_version: u8,      // 协议版本号 (必须=2)
    pub magic: u16,                // 魔数 0x4D43 ("MC")
    pub timestamp: u64,            // 毫秒时间戳 (防乱序)

    // === 模式状态 ===
    pub primary: u8,               // 主模式: 0=None, 1=Solo, 2=Mute
    pub compare: u8,               // 比较模式

    // === 通道状态 (位掩码) ===
    pub solo_mask: u32,            // Solo 集合
    pub mute_mask: u32,            // Mute 集合
    pub user_mute_sub_mask: u8,    // SUB User Mute

    // === 全局控制 ===
    pub master_gain: f32,          // 主音量 (0.0-1.0)
    pub dim: bool,                 // Dim 开关
    pub cut: bool,                 // Cut 开关

    // === v2 新增字段 ===
    pub layout: i32,               // Speaker 布局索引
    pub sub_layout: i32,           // SUB 布局索引
    pub automation_mode: bool,     // 自动化模式
}
```

### 2.8.2 心跳超时机制

Slave 端实现心跳检测：
- 超时阈值: 2000ms
- 检测间隔: 100ms
- 超时后自动触发 `request_network_restart()` 进行重连

## 2.9 线程模型

```
┌─────────────────────────────────────────────────────────────────────┐
│                     MonitorControllerMax 线程模型                    │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐                                                │
│  │    DAW 主线程    │ ← 初始化、加载、卸载                            │
│  └────────┬────────┘                                                │
│           │ new() / initialize()                                    │
│           ▼                                                         │
│  ┌─────────────────┐                                                │
│  │   音频线程       │ ← process() 音频处理 + 热重载检查               │
│  │  (实时优先级)    │   无锁操作: AtomicCell 读取                     │
│  └────────┬────────┘                                                │
│           │ reset() 触发                                            │
│           ▼                                                         │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │
│  │   OSC 线程      │  │  Network 线程   │  │   UI 渲染线程    │     │
│  │  (Tokio)        │  │  (Tokio)        │  │  (egui)         │     │
│  │ UDP :7445       │  │ ZMQ :9123       │  │ 60 FPS          │     │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘     │
└─────────────────────────────────────────────────────────────────────┘
```

### 线程安全数据访问

| 数据类型 | 同步机制 | 访问线程 |
|---------|---------|---------|
| Solo/Mute 集合 | `RwLock<HashSet<String>>` | UI, Network |
| 渲染快照 | `AtomicCell<RenderSnapshot>` | UI(写), Audio(读) |
| 运行标志 | `AtomicBool` | 所有线程 |
| 参数值 | `AtomicF32` (nih-plug) | 所有线程 |
| 热重载请求 | `RwLock<Option<AppConfig>>` | UI(写), Audio(读) |
