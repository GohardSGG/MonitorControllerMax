//! Build script for MonitorControllerMax
//!
//! Reads Speaker_Config.json at compile time and generates Audio_Layouts.rs
//! with the appropriate AUDIO_IO_LAYOUTS constant.

use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Tell Cargo to rerun this script if the config file changes
    println!("cargo:rerun-if-changed=../Resource/Speaker_Config.json");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("Audio_Layouts.rs");

    // Read and parse the JSON config
    let config_path = Path::new("../Resource/Speaker_Config.json");
    let config_content = fs::read_to_string(config_path)
        .expect("Failed to read Speaker_Config.json");

    // Remove potential UTF-8 BOM
    let config_content = config_content.trim_start_matches('\u{FEFF}');

    let config: serde_json::Value = serde_json::from_str(config_content)
        .expect("Failed to parse Speaker_Config.json");

    // Extract speaker layouts and their channel counts
    let speakers = config.get("Speaker")
        .and_then(|v| v.as_object())
        .expect("Missing 'Speaker' section in config");

    // Collect layouts with their channel counts
    let mut layouts: Vec<(String, usize)> = Vec::new();

    for (name, layout_data) in speakers {
        if let Some(obj) = layout_data.as_object() {
            // Count channels (all keys except "Size")
            let channel_count = obj.keys()
                .filter(|k| *k != "Size")
                .count();
            layouts.push((name.clone(), channel_count));
        }
    }

    // Sort by channel count for consistent ordering
    layouts.sort_by_key(|(_, count)| *count);

    // Deduplicate channel counts (we only need unique counts for AUDIO_IO_LAYOUTS)
    let mut seen_counts: HashMap<usize, String> = HashMap::new();
    for (name, count) in &layouts {
        seen_counts.entry(*count).or_insert_with(|| name.clone());
    }

    // Build the generated code
    let mut code = String::new();
    code.push_str("// Auto-generated from Speaker_Config.json - DO NOT EDIT MANUALLY\n");
    code.push_str("// Generated by build.rs at compile time\n\n");
    code.push_str("use nih_plug::prelude::*;\n");
    code.push_str("use std::num::NonZeroU32;\n\n");

    // Generate layout info for runtime use
    code.push_str("/// Layout information generated from Speaker_Config.json\n");
    code.push_str("pub const GENERATED_LAYOUTS: &[(&str, usize)] = &[\n");
    for (name, count) in &layouts {
        code.push_str(&format!("    (\"{}\", {}),\n", name, count));
    }
    code.push_str("];\n\n");

    // Generate AUDIO_IO_LAYOUTS
    code.push_str("/// Audio IO layouts generated from Speaker_Config.json\n");
    code.push_str("pub const GENERATED_AUDIO_IO_LAYOUTS: &[AudioIOLayout] = &[\n");

    // First, add MAX_CHANNELS (32) as the primary layout
    code.push_str("    // Maximum channel layout (32 channels)\n");
    code.push_str("    AudioIOLayout {\n");
    code.push_str("        main_input_channels: NonZeroU32::new(32),\n");
    code.push_str("        main_output_channels: NonZeroU32::new(32),\n");
    code.push_str("        names: PortNames {\n");
    code.push_str("            layout: Some(\"32ch\"),\n");
    code.push_str("            main_input: Some(\"32ch In\"),\n");
    code.push_str("            main_output: Some(\"32ch Out\"),\n");
    code.push_str("            ..PortNames::const_default()\n");
    code.push_str("        },\n");
    code.push_str("        ..AudioIOLayout::const_default()\n");
    code.push_str("    },\n");

    // Collect unique channel counts and generate layouts in descending order
    let mut unique_counts: Vec<usize> = seen_counts.keys().copied().collect();
    unique_counts.sort_by(|a, b| b.cmp(a)); // Descending order

    for count in unique_counts {
        if count == 0 {
            continue;
        }
        let name = seen_counts.get(&count).unwrap();

        code.push_str(&format!("    // {} ({} channels)\n", name, count));
        code.push_str("    AudioIOLayout {\n");
        code.push_str(&format!("        main_input_channels: NonZeroU32::new({}),\n", count));
        code.push_str(&format!("        main_output_channels: NonZeroU32::new({}),\n", count));
        code.push_str("        names: PortNames {\n");
        code.push_str(&format!("            layout: Some(\"{}\"),\n", name));
        code.push_str(&format!("            main_input: Some(\"{} In\"),\n", name));
        code.push_str(&format!("            main_output: Some(\"{} Out\"),\n", name));
        code.push_str("            ..PortNames::const_default()\n");
        code.push_str("        },\n");
        code.push_str("        ..AudioIOLayout::const_default()\n");
        code.push_str("    },\n");
    }

    code.push_str("];\n");

    // Write the generated code
    fs::write(&dest_path, code).expect("Failed to write Audio_Layouts.rs");
}
