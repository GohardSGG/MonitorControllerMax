# 2. 技术架构总览

## 2.1 整体架构图

本系统采用 **注册中心模式 (Registry Pattern)** 配合 **消息驱动 (Message Driven)** 机制，彻底解耦 Master 与 Slave 的生命周期。

```mermaid
graph TB
    subgraph "Global Scope (Static Lazy)"
        Registry[Registry <Arc RwLock>]
        Router[Message Router]
    end

    subgraph "Master Plugin Instance"
        M_GUI[GUI Thread (egui + wgpu)]
        M_DSP[Audio Thread (DSP)]
        M_OSC[OSC Server Task]
        M_State[Shared State (Params)]
        
        M_GUI -- "Update Params" --> M_State
        M_OSC -- "Cmd -> Update Params" --> M_State
        M_State -- "Broadcast Changes" --> Router
    end

    subgraph "Slave Plugin Instance"
        S_DSP[Audio Thread (DSP)]
        S_State[Render State Cache]
        S_Receiver[Message Receiver]
        
        Router -.->|Weak Ref| S_Receiver
        S_Receiver -->|SPSC Queue| S_DSP
    end

    Registry --- M_State
    Registry --- S_Receiver
```
*（架构图微调，明确GUI与State的交互方式为更新参数）*

## 2.2 核心分层策略

我们将系统严格划分为三个安全域，域之间只能通过 **Channel** 或 **Atomic** 通信。

| 模块/层级 | 职责 | 线程环境 | 关键技术 | 内存策略 |
| :--- | :--- | :--- | :--- | :--- |
| **Registry** | 维护插件拓扑，路由消息 | 任意线程 | `Weak<T>`, `RwLock` | **主要防线**。只存弱引用，杜绝悬垂指针。 |
| **Control Plane** | 业务逻辑 (Solo/Mute/Group) | GUI/Worker | `nih-plug Params`, `Arc<Mutex>` | 核心状态由参数系统管理，复杂逻辑允许堆分配。 |
| **Audio Plane** | 信号处理 (Gain/Mute/Dim) | Real-time | `TripleBuffer`, `Atomic f32` | **严禁分配**。只读原子快照。 |

## 2.3 核心技术选型

### 2.3.1 框架与运行时
*   **Plugin Framework**: `nih-plug`。提供最现代的 Rust VST3 支持和声明式参数管理。
*   **GUI Stack**: **`egui` + `wgpu`**。这是经过第一阶段实践最终确定的技术栈。`egui` 提供即时模式的 UI 构建能力，而 `wgpu` 作为渲染后端，确保了与各平台及宿主（DAW）窗口系统的最大兼容性。
*   **Async Runtime**: `smol` 或 `async-std` (集成在 nih-plug 中)，用于处理 OSC 网络 I/O。

### 2.3.2 并发模型 (The Rust Way)
*   **GUI-DSP 通信**:
    *   **控制信号 (用户操作)**: 遵循 `nih-plug` 的核心范式，GUI 线程通过修改 `Params` 来驱动状态变化。音频线程通过参数平滑（smoothing）来安全地响应这些变化。
    *   **实时数据 (电平表)**: 对于从 DSP 到 GUI 的高频数据，将使用无锁环形缓冲区 (`ring_buffer`)。
*   **Master-Slave 通信**: Pub/Sub 模型。Master 发布 `LayoutUpdate` 事件，Slave 订阅并消费。
*   **RenderState 同步**: 使用 `triple_buffer` 库。Producer (Control Plane) 写入新状态，Consumer (DSP) 总是获取最新的完整快照，无锁且无撕裂。

### 2.3.3 GUI “胶水层”：`nih-plug-egui`
值得注意的是，`egui` 本身是一个独立的 UI 库，`nih-plug` 通过 `nih-plug-egui` 这个 crate 将其集成进来。这个“胶水层”代码至关重要，它负责处理窗口句柄的附加、输入事件的翻译，以及最关键的 **UI 缩放**。我们在第一阶段的经验表明，必须深入理解这一层的内部机制（如 `set_scale_factor_override`），才能正确实现诸如 DPI 感知和动态缩放等核心 GUI 功能。

## 2.4 为什么是 Registry + Weak？

这是解决“石油般崩溃”的数学解：
1.  所有插件实例在构造时将自己的 `Weak<Sender>` 注册到全局 `Registry`。
2.  Master 广播时，遍历 `Registry`。
3.  尝试 `Weak::upgrade()`。
    -   **成功**：说明 Slave 还活着，发送消息。
    -   **失败**：说明 Slave 已被宿主销毁（用户删了轨道），直接从列表移除该条目。
4.  **结果**：无论宿主何时销毁插件，Master 永远不会访问无效内存。

## 2.5 OSC 集成架构
OSC 服务运行在独立的后台线程中，接收到 UDP 包后，解析为内部 `CommandEnum`，通过 `mpsc::channel` 发送给主逻辑以更新 `Params`，避免在网络回调中直接操作音频状态。

