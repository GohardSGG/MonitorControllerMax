# 2. 技术架构总览

## 2.1 整体架构图

本系统采用 **Master-Slave 分布式架构**，通过 **ZeroMQ** 网络层实现跨实例、跨机器的高性能状态同步。

```mermaid
graph TB
    subgraph "Master Plugin (Source Control)"
        M_GUI[GUI / OSC Thread]
        M_Logic[Semantic Logic Core]
        M_Net[ZMQ Publisher]
        M_Audio[Audio Thread (Source Mute)]
        
        M_GUI -->|Update Params| M_Logic
        M_Logic -->|Compute RenderState| M_Audio
        M_Logic -->|Serialize| M_Net
    end

    subgraph "Slave Plugin (Monitor Control)"
        S_Net[ZMQ Subscriber]
        S_Cache[AtomicCell RenderState]
        S_Audio[Audio Thread (Gain/Dim/Mute)]
        
        M_Net -.->|TCP/IPC| S_Net
        S_Net -->|Update| S_Cache
        S_Cache -->|Lock-Free Read| S_Audio
    end
```

## 2.2 核心分层策略

我们将系统严格划分为三个安全域，域之间只能通过 **Channel**、**Atomic** 或 **Socket** 通信。

| 模块/层级 | 职责 | 线程环境 | 关键技术 | 内存策略 |
| :--- | :--- | :--- | :--- | :--- |
| **Control Plane** | 业务逻辑 (Solo/Mute/Group) | GUI/Worker | `nih-plug Params`, `Arc<Mutex>` | 核心状态由参数系统管理，复杂逻辑允许堆分配。 |
| **Network Plane** | 跨实例状态广播 | Background Thread | `ZeroMQ (PUB/SUB)`, `Bincode` | 异步 IO，序列化/反序列化。 |
| **Audio Plane** | 信号处理 (Gain/Mute/Dim) | Real-time | `ArcSwap`, `AtomicCell` | **严禁分配**。无锁读取缓存快照。 |

## 2.3 核心技术选型

### 2.3.1 框架与运行时
*   **Plugin Framework**: `nih-plug`。
*   **GUI Stack**: `egui` + `wgpu`。
*   **Network Stack**: `zeromq` (Rust bindings) + `bincode` (序列化)。

### 2.3.2 分布式通信模型 (The ZMQ Way)
*   **模式**: **PUB/SUB (发布/订阅)**。
*   **Master**: 绑定 `tcp://0.0.0.0:9123`，作为状态发布者。
*   **Slave**: 连接 Master IP，作为订阅者。
*   **特性**:
    *   **无状态广播**: Master 只管发，不维护连接状态。
    *   **自动重连**: ZMQ 底层处理 TCP 断连与重连。
    *   **状态保持 (Fail-Safe)**: Slave 在断连期间保持最后收到的有效状态，防止音量突跳。

### 2.3.3 音频处理策略
*   **Master (Source)**: 负责“源头清洗”。仅执行针对校准软件的 Mute 逻辑（如 Solo L 时 Mute R）。**不处理增益**。
*   **Slave (Monitor)**: 负责“最终把关”。执行最终的 Mute（如 Solo SUB 时切断主音箱）以及 **Gain/Dim** 控制。

## 2.4 为什么是 ZeroMQ？

这是为了支持 **跨机协同** 的关键决策：
1.  **统一架构**: 无论是本机（Localhost）还是局域网（LAN），通信代码完全一致。
2.  **解耦**: Master 和 Slave 彻底解耦，不再共享进程内存，消除了野指针风险。
3.  **高性能**: ZMQ 专为高吞吐设计，配合 Bincode 的极小 Payload (约 20 bytes)，延迟极低。

## 2.5 OSC 集成架构
OSC 服务作为 Master 的输入源之一，将外部硬件指令转化为对 `Params` 的修改。反馈逻辑（点灯）由 Master 统一计算后回传给硬件。
