# 2. 技术架构总览

## 2.1 整体架构图

本系统采用 **Rust Workspace 模块化架构**，将业务逻辑、异步副作用和界面展示分离开来，以确保高并发环境下的稳定性和可维护性。

```mermaid
graph TD
    subgraph "Host Environment (DAW)"
        AudioThread[音频线程 (Real-time)]
        UIThread[UI 线程 (Main)]
    end

    subgraph "monitor_controller_max (Plugin)"
        Lib[Plugin Entry]
        Editor[Editor GUI (egui)]
    end

    subgraph "mcm_core (Pure Logic)"
        AudioProc[AudioProcessor]
        Interaction[InteractionManager]
        Params[MonitorParams]
    end

    subgraph "mcm_reactor (Async Runtime)"
        Reactor[Reactor (Tokio)]
        WebActor[Web Actor (Axum)]
        OscActor[OSC Actor (Rosc)]
        NetActor[Network Actor (ZMQ)]
    end

    subgraph "Shared Infrastructure"
        Protocol[mcm_protocol (Data)]
        Infra[mcm_infra (Logger/Config)]
    end

    %% Relationships
    Lib --> AudioProc
    Editor --> Interaction
    
    Lib --> Reactor
    AudioProc -.->|Atomic Read| Params
    Interaction -->|Update| Params
    
    Reactor --> WebActor
    Reactor --> OscActor
    Reactor --> NetActor
    
    WebActor -->|Shared State| Protocol
    OscActor -->|Shared State| Protocol
    NetActor -->|Shared State| Protocol
```

## 2.2 核心模块职责

我们通过 Cargo Workspace 定义了以下 Crate：

| Crate | 类型 | 职责 | 依赖关系 |
| :--- | :--- | :--- | :--- |
| **mcm_protocol** | Lib | **数据契约层**。定义所有跨模块共享的数据结构（如配置、网络包、Web状态）。纯数据，无逻辑。 | 无 (基础库除外) |
| **mcm_infra** | Lib | **基础设施层**。提供日志系统 (`InstanceLogger`)、配置加载 (`ConfigLoader`) 等通用工具。 | `mcm_protocol` |
| **mcm_core** | Lib | **核心逻辑层**。包含所有音频处理算法、参数定义 (`MonitorParams`) 和交互逻辑 (`InteractionManager`)。纯函数式设计，易于测试。 | `mcm_infra` |
| **mcm_reactor** | Lib | **副作用层**。基于 Tokio 的异步运行时，管理 Web 服务器、OSC 通信和 ZMQ 网络广播。它作为插件的"Sidecar"运行。 | `mcm_core` |
| **monitor_controller_max** | Lib (CDylib) | **插件适配层**。利用 `nih-plug` 将上述模块组装为 VST3/CLAP 插件。负责生命周期管理和 GUI 渲染。 | 所有上述模块 |

## 2.3 线程模型

我们严格区分了三类执行环境，以确保音频线程永不阻塞：

### 2.3.1 音频线程 (Real-time Safe)
- **职责**: 执行 DSP 处理、音量计算、静音控制。
- **约束**: **严禁** 内存分配 (Alloc)、锁竞争 (Lock) 或 系统调用 (Syscall)。
- **交互**: 仅通过 `Atomic` 类型或 `ArcSwap` 读取参数和状态快照。

### 2.3.2 UI 线程 (Main Thread)
- **职责**: 渲染 GUI、处理用户鼠标点击。
- **交互**: 持有 `Arc<InteractionManager>`，将用户的意图转化为参数变更。
- **限制**: 不应执行耗时操作，耗时任务通过 Channel 发送给 Reactor。

### 2.3.3 Reactor 线程 (Async Background)
- **职责**: 运行 Tokio Runtime，处理网络 I/O。
- **组件**:
    - **Web Actor**: HTTP API / WebSocket 推送 (:8080)
    - **OSC Actor**: UDP 双向通信 (:7444/:7445)
    - **Network Actor**: ZeroMQ 跨机广播 (:9123)
- **交互**: 通过 `crossbeam` Channel 接收来自 UI/Plugin 的指令；通过 `Atomic` 或 `RwLock` 共享状态给 UI。

## 2.4 关键技术决策

### 2.4.1 状态管理
- **WebSharedState**: 为了解决 Web 服务与 UI 线程的数据共享，我们将状态定义下沉到 `mcm_protocol`，并使用 `Atomic` 字段。这允许 UI 线程在不锁住 Web 服务器的情况下读取状态（如"是否运行中"）。

### 2.4.2 Master-Slave 分布式架构
- **Master**: 负责接收 OSC/Web 指令，计算逻辑状态 (Solo/Mute)，并通过 ZeroMQ 发布。
- **Slave**: 订阅 ZeroMQ 消息，应用到本地音频处理。Slave 端的 UI 交互被禁用，完全由 Master 驱动。

### 2.4.3 热重载 (Hot Reload)
- 支持在运行时修改 OSC 或 Network 端口配置。
- UI 线程发出 `Restart` 请求，Reactor 线程捕获后优雅关闭旧服务并重启新服务，全程不影响音频处理。

## 2.5 目录结构

```
MonitorControllerMax/
├── Cargo.toml              # Workspace 根配置
├── Source/
│   ├── Core/               # mcm_core
│   ├── Infra/              # mcm_infra
│   ├── Plugin/             # monitor_controller_max
│   ├── Protocol/           # mcm_protocol
│   ├── Reactor/            # mcm_reactor
│   └── xtask/              # 构建脚本
├── Library/                # 本地依赖 (nih-plug)
└── target/                 # 构建产物
```
