# 7. 技术风险与解决方案 (经实践验证与更新)

## 7.1 风险矩阵

| 风险项 | 状态 | 可能性 | 严重性 | 描述 | 解决方案 |
| :--- | :--- |:---|:---|:---|:---|
| **GUI 框架兼容性** | <font color="green">**已解决**</font> | 低 | 高 | `egui` 作为独立 GUI 框架，其默认渲染后端 `glow` 与宿主窗口系统存在严重冲突，导致无法渲染或UI被拉伸。 | **已成功实施**：废弃 `glow`，采用 `wgpu` 作为渲染后端；并深入理解 `nih-plug-egui` 胶水层，通过 `set_scale_factor_override` API 实现了可靠的DPI感知缩放。 |
| **Master-Slave 延迟** | <font color="orange">**理论验证**</font> | 低 | 高 | 消息传递可能比直接指针调用慢，导致 Slave 响应滞后。 | **方案已集成**: 架构已选定高性能的 `crossbeam-channel`，并在 `AudioProcessor` 设计中使用 `TripleBuffer` 读取状态，确保了音频线程的无锁消费。实际延迟待后续压力测试验证。 |
| **OSC 端口冲突** | <font color="red">**待处理**</font> | 高 | 中 | 多个 Master 实例或与其他软件抢占 UDP 端口。 | **计划中**: 实现端口自动协商机制；在 UI 中提供端口配置选项；错误时优雅降级（仅 Disable OSC，不 Crash）。 |
| **DAW 兼容性** | <font color="orange">**部分验证**</font> | 中 | 高 | 部分 DAW 对多总线插件或窗口管理有特殊处理。 | **持续验证中**: `nih-plug` 框架本身已处理大量兼容性问题。我们已在 Reaper 中完成初步验证。后续将在 Logic, Cubase 等主要宿主中进行专项测试。 |

## 7.2 核心问题与已验证的解决方案

### 7.2.1 根除“死亡指针” (The Weak Ref Pattern)

这是本项目最大的技术变革，其有效性已在我们的 `Registry` 模块设计中得到体现。

**旧方案 (C++)**:
```cpp
// 危险！vector 存的是裸指针
std::vector<Plugin*> slaves; 
// 访问时不知道 Plugin 是否已被析构
slaves[0]->doSomething(); // CRASH!
```

**新方案 (Rust)**:
```rust
// 安全！Registry 存的是弱引用
struct Registry {
    slaves: HashMap<InstanceId, Weak<Sender<Msg>>>,
}

impl Registry {
    fn broadcast(&mut self, msg: Msg) {
        // 1. 移除已经死掉的引用 (cleanup)
        self.slaves.retain(|_, weak| weak.strong_count() > 0);
        
        // 2. 尝试升级引用，只有升级成功才发送
        for weak in self.slaves.values() {
            if let Some(sender) = weak.upgrade() {
                let _ = sender.send(msg.clone()); // 安全发送
            }
        }
    }
}
```
该模式已作为我们多实例通信的架构基石。Rust 的内存模型从数学上保证了我们永远不会访问一个已经被宿主销毁的插件实例。

### 7.2.2 解决 RenderState 数据竞争 (The Triple Buffer Pattern)

**旧方案**: 简单的指针交换 (`active`/`inactive`)，缺乏原子性保障，写入者可能覆盖正在读取的数据。

**新方案**: **Triple Buffer (三缓冲)**。
该方案已在我们`Control Plane -> Audio Plane`的数据流设计中被采纳。

1.  **Write Buffer**: `Semantic Logic` 计算出的新 `RenderState` 存放在此。
2.  **Read Buffer**: `AudioProcessor` 正在读取的当前 `RenderState`。
3.  **Back Buffer**: 闲置的缓冲，用于下一次交换。

我们选定 `triple_buffer` crate 来实现这一模式。它利用原子交换索引，实现了无锁、非阻塞的生产-消费模型，是音频参数同步的理论最优解。

### 7.2.3 复杂状态管理的解耦 (The Param-Logic-State Flow)

通过将 `SemanticState` 提取为纯 Rust 结构体，并建立 **`Params -> Logic -> RenderState`** 的单向数据流，我们从架构上解决了 C++ 版本中状态管理混乱的问题。

- **输入**: `nih-plug Params` (真理之源)。
- **处理**: `ChannelLogic` (纯函数，易于测试)。
- **输出**: `RenderState` (扁平化数据，适合实时处理)。

这种设计使得我们可以为 `ChannelLogic` 编写数千个单元测试用例，覆盖所有“多选 Solo”、“分组 Mute”、“Solo Safe”等复杂逻辑，确保重构后的核心功能在集成到插件中之前，就已经达到了 100% 的逻辑正确性。

