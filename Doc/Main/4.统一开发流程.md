# 4. 统一开发流程

本文档定义了从 C++ 迁移到 Rust 的标准化作业流程。

## 4.1 IDIV 开发循环 (以 GUI 缩放问题为例)

我们继续沿用 IDIV (Iterative Design, Implement, Verify) 模式。第一阶段的 GUI 开发过程，完美地诠释了这一循环在实践中的应用。

```mermaid
graph LR
    A[问题分析: GUI被拉伸] --> B[源码研究: nih-plug-egui]
    B --> C[方案设计: 使用 scale_factor_override]
    C --> D[代码实现: Editor::set_scale_factor]
    D --> E[集成测试: 在 Reaper 中拖动窗口]
    E --> F[经验沉淀: 写入开发总结]
```

### 1. 逻辑分析 (Analysis)
*   **旧代码/行为分析**：观察到 GUI 控件在窗口拖动时被不成比例地拉伸，而不是重新布局。
*   **提取核心问题**：`egui` 的内部画布尺寸没有随着窗口物理尺寸的变化而更新。
*   **摒弃表面方案**：最初尝试在 `egui::Context` 中强行设置 `pixels_per_point`，但宣告失败。这引导我们将问题定位在 `nih-plug-egui` 这个“胶水层”上。

### 2. 源码驱动的再设计 (Redesign via Source Code)
*   **深入研究**：我们深入 `nih_plug_egui::EguiState` 的源码，发现了 `scale_factor_override` 这个关键成员变量。
*   **重新建模**：理解了 `nih-plug` 的设计哲学——它通过“覆盖”的方式接管了 `egui` 的缩放控制权。我们必须遵循它的规则，而不是 `egui` 原生的规则。

### 3. 实现与单元测试 (Implementation & Test)
*   **逻辑实现**: 编写代码，在 `Editor::create` 和处理尺寸变化的事件时，调用 `editor_state.set_scale_factor_override()`。
*   **单元测试 (适用时)**: 对于纯逻辑模块（如 `SemanticState`），编写 `cargo test` 用例，确保其在各种输入下的行为符合预期。

### 4. 宿主验证 (Host Verification)
*   **主要调试宿主**: Reaper。
*   **关键检查点**:
    1.  加载/卸载插件是否造成内存泄漏或 Panic。
    2.  快速复制/删除 Slave 轨道，验证 Registry 是否健壮。
    3.  **（GUI验证）** 在不同DPI的显示器间拖动插件窗口，反复调整尺寸，验证 UI 是否始终清晰、无拉伸。
    4.  OSC 端口冲突处理。

## 4.2 构建与调试命令 (重要修订)

使用 `xtask` 进行跨平台构建和打包。

```bash
# 构建 VST3 并自动安装到系统目录 (推荐)
cargo xtask bundle monitor_plugin --release

# 仅运行单元测试 (针对纯逻辑模块)
cargo test -p monitor_core
```

**注意**: 我们当前的技术栈 (`nih-plug-egui` + `wgpu`) **不支持**将 GUI 作为独立窗口运行进行预览。`cargo run --bin editor_preview` 这类命令是无效的。**所有 GUI 相关的调试和验证工作，都必须在目标宿主 (DAW) 中加载插件来进行。**

## 4.3 迁移 Checklist

每个模块迁移时需完成以下检查：
- [ ] 数据结构是否使用了 `Arc/RwLock` 替代裸指针？
- [ ] DSP 循环中是否清除了所有 `unwrap()`？
- [ ] 是否编写了涵盖边缘情况（如 0 通道、最大通道）的测试？
- [ ] `cargo clippy -- -D warnings` 是否通过且无警告？
- [ ] **(新增)** 是否已经理解并正确处理了与框架“胶水层”相关的特殊逻辑（如 `nih-plug-egui` 的缩放机制）？
- [ ] **(新增)** 相关实现是否遵循了《3.项目规范与约定.md》中的最新规范？

