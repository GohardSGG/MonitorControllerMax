# 1. 项目概述

## 1.1 项目目标

**MonitorControllerMax (Rust Edition)** 旨在重建基于 macOS/Windows 平台的工业级监听控制器 VST3 插件。

本项目的核心使命是**彻底根除**原 C++ 版本中存在的“石油般崩溃”（由裸指针管理不当引发的随机闪退）和数据竞争问题。我们将利用 Rust 语言的**所有权模型 (Ownership Model)** 和 **nih-plug** 框架，构建一个在数学上被证明为内存安全、并发安全的高性能音频控制系统。

*此核心目标保持不变，它依然是我们所有技术决策的最终指引。*

## 1.2 核心特性

- 🛡️ **零崩溃保证 (Crash-Free)**：利用 Rust 的 `Arc`、`Weak` 和 `RwLock` 彻底解决 Master-Slave 通信中的悬垂指针问题。
- 🚀 **Master-Slave 分布式架构**：
    - **Master**: 全局控制中心，负责 OSC 通信、状态广播。
    - **Slave**: 纯音频处理节点，零延迟同步 Master 状态。
- 🎛️ **18x18 矩阵路由**：支持大规模多通道监听，任意 Input 到 Output 的路由映射。
- ⚡ **实时无锁处理 (Real-time Safe)**：音频线程 (Process Block) 严格遵循无锁、无内存分配 (No Alloc) 原则，使用 Triple Buffer 或 SPSC 队列进行状态更新。
- 🎮 **硬件深度集成**：基于 OSC 协议与 Loupedeck/StreamDeck 双向同步，提供物理级的触觉反馈。
- 🎨 **可缩放的现代GUI**：基于 `nih-plug` + `egui` + `wgpu` 实现，确保在不同DPI的显示器上都能获得清晰、无拉伸的视觉体验。

## 1.3 迁移背景：为什么选择 Rust？

原 C++ (v4.1) 架构虽然逻辑完备，但存在根本性的技术债务：
1.  **生命周期管理失效**：`GlobalPluginState` 依赖裸指针维护插件列表，导致 DAW 在快速增删轨道时发生 Use-After-Free 崩溃。
2.  **数据竞争**：`RenderState` 的双缓冲实现缺乏原子性保障，导致 UI 线程与音频线程由于时序问题产生状态撕裂。
3.  **维护成本**：过度复杂的 OOP 继承链导致代码难以测试和扩展。

Rust 版本将通过**编译期检查**强制执行线程安全，将运行时错误转化为编译时错误。

*这一部分作为项目的“初心”，内容无需改动。*

## 1.4 当前状态 (更新于 2025.11.29)

**阶段：核心技术预研与 GUI 基础设施构建完毕**

经过第一阶段充满挑战的开发，我们已经从“Day 0”的设想阶段，成功地迈出了坚实的一步。我们当前的状态不再是“即将开始”，而是“已经攻克了最关键的技术难题之一”。

- ✅ **完成了对渲染后端的艰难选型**：在经历了 `glow` 与宿主窗口不兼容的挫折后，我们最终确定并成功实现了基于 `wgpu` 的渲染后端。这是保障插件UI能在所有DAW中稳定运行的基石。
- ✅ **实现了真正意义上的UI缩放**：我们深入研究了 `nih-plug-egui` 的内部机制，通过 `set_scale_factor_override` API 从根本上解决了UI被拉伸的问题，实现了DPI感知的、平滑的动态缩放。
- ✅ **构建了第一个可视化的GUI原型**：如 `image.png` 所示，我们已经成功渲染出一个虽然简陋但技术上完备的UI界面。这个界面证明了我们的技术栈是可行的，并为后续添加复杂的路由矩阵和控制按钮铺平了道路。
- 🔄 **下一步：业务逻辑的全面迁移**：在GUI底层稳固之后，我们现在的工作重心将转移到将 C++ 版本中的核心业务逻辑（如 Solo/Mute 状态机、路由算法）安全、高效地迁移到 Rust 中。

