# 1. 项目概述

## 1.1 项目目标

**MonitorControllerMax (Rust Edition)** 旨在重建基于 macOS/Windows 平台的工业级监听控制器 VST3 插件。

本项目的核心使命是**彻底根除**原 C++ 版本中存在的“石油般崩溃”（由裸指针管理不当引发的随机闪退）和数据竞争问题。我们将利用 Rust 语言的**所有权模型 (Ownership Model)** 和 **nih-plug** 框架，构建一个在数学上被证明为内存安全、并发安全的高性能音频控制系统。

*此核心目标保持不变，它依然是我们所有技术决策的最终指引。*

## 1.2 核心特性

- 🛡️ **零崩溃保证 (Crash-Free)**：利用 Rust 的 `Arc`、`Weak` 和 `RwLock` 彻底解决 Master-Slave 通信中的悬垂指针问题。
- 🚀 **Master-Slave 分布式架构**：
    - **Master**: 全局控制中心，负责 OSC 通信、状态广播、信号源控制。
    - **Slave**: 纯音频处理节点，负责最终的监听静音、增益控制，支持跨机分布式部署。
- 🎛️ **18x18 矩阵路由**：支持大规模多通道监听，任意 Input 到 Output 的路由映射，支持 7.1.4 乃至更高的通道配置。
- ⚡ **实时无锁处理 (Real-time Safe)**：音频线程 (Process Block) 严格遵循无锁、无内存分配 (No Alloc) 原则，使用 `AtomicCell` 或 `ArcSwap` 进行状态更新。
- 🎮 **硬件深度集成**：基于 OSC 协议与 Loupedeck/StreamDeck 双向同步，提供物理级的触觉反馈。
- 🎨 **可缩放的现代GUI**：基于 `nih-plug` + `egui` + `wgpu` 实现，确保在不同DPI的显示器上都能获得清晰、无拉伸的视觉体验。
- 🌐 **跨机协同 (Networked)**: 基于 ZeroMQ 实现的局域网内低延迟状态同步，支持多台电脑协同工作。

## 1.3 迁移背景：为什么选择 Rust？

原 C++ (v4.1) 架构虽然逻辑完备，但存在根本性的技术债务：
1.  **生命周期管理失效**：`GlobalPluginState` 依赖裸指针维护插件列表，导致 DAW 在快速增删轨道时发生 Use-After-Free 崩溃。
2.  **数据竞争**：`RenderState` 的双缓冲实现缺乏原子性保障，导致 UI 线程与音频线程由于时序问题产生状态撕裂。
3.  **维护成本**：过度复杂的 OOP 继承链导致代码难以测试和扩展。

Rust 版本将通过**编译期检查**强制执行线程安全，将运行时错误转化为编译时错误。

*这一部分作为项目的“初心”，内容无需改动。*

## 1.4 当前状态 (更新于 2025.12.09)

**阶段：核心功能开发完成，进入测试验证阶段**

项目已完成阶段一至四的全部开发工作，正式进入最终测试与打磨阶段。

### 已完成的里程碑

- ✅ **阶段一 - GUI 基础设施**：`egui` + `wgpu` 渲染后端、DPI 缩放、Brutalist 组件库。
- ✅ **阶段二 - 核心逻辑与网络层**：
  - `MonitorParams` 参数系统完整实现
  - `ChannelLogic` 纯函数计算 `RenderState`
  - ZeroMQ PUB/SUB 广播网络 (端口 9123)
  - Master-Slave 状态同步机制
- ✅ **阶段三 - UI 功能绑定与交互**：
  - `InteractionManager` v4.0 状态机 (PrimaryMode + CompareMode)
  - GUI 完整绑定（Solo/Mute/Cut/Dim/Volume）
  - 视觉反馈（闪烁/常亮/颜色变化）
- ✅ **阶段四 - 硬件集成**：
  - OSC 双向通信 (端口 9124)
  - Loupedeck 硬件控制器集成
  - 通道旋钮语义层 (value=10/11/12)

**➡️ 当前阶段：测试验证与打磨**
- [ ] 音频处理验证（Solo/Mute/Cut/Dim 实际生效）
- [ ] Master-Slave 通信测试（本机/跨实例/断连）
- [ ] 增益平滑（如有点击噪声）
