# 1. 项目概述

## 1.1 项目目标

**MonitorControllerMax (Rust Edition)** 旨在重建基于 macOS/Windows 平台的工业级监听控制器 VST3 插件。

本项目的核心使命是**彻底根除**原 C++ 版本中存在的“石油般崩溃”（由裸指针管理不当引发的随机闪退）和数据竞争问题。我们将利用 Rust 语言的**所有权模型 (Ownership Model)** 和 **nih-plug** 框架，构建一个在数学上被证明为内存安全、并发安全的高性能音频控制系统。

*此核心目标保持不变，它依然是我们所有技术决策的最终指引。*

## 1.2 核心特性

- 🛡️ **零崩溃保证 (Crash-Free)**：利用 Rust 的 `Arc`、`Weak` 和 `RwLock` 彻底解决 Master-Slave 通信中的悬垂指针问题。
- 🚀 **Master-Slave 分布式架构**：
    - **Master**: 全局控制中心，负责 OSC 通信、状态广播、信号源控制。
    - **Slave**: 纯音频处理节点，负责最终的监听静音、增益控制，支持跨机分布式部署。
- 🎛️ **18x18 矩阵路由**：支持大规模多通道监听，任意 Input 到 Output 的路由映射，支持 7.1.4 乃至更高的通道配置。
- ⚡ **实时无锁处理 (Real-time Safe)**：音频线程 (Process Block) 严格遵循无锁、无内存分配 (No Alloc) 原则，使用 `AtomicCell` 或 `ArcSwap` 进行状态更新。
- 🎮 **硬件深度集成**：基于 OSC 协议与 Loupedeck/StreamDeck 双向同步，提供物理级的触觉反馈。
- 🎨 **可缩放的现代GUI**：基于 `nih-plug` + `egui` + `wgpu` 实现，确保在不同DPI的显示器上都能获得清晰、无拉伸的视觉体验。
- 🌐 **跨机协同 (Networked)**: 基于 ZeroMQ 实现的局域网内低延迟状态同步，支持多台电脑协同工作。

## 1.3 迁移背景：为什么选择 Rust？

原 C++ (v4.1) 架构虽然逻辑完备，但存在根本性的技术债务：
1.  **生命周期管理失效**：`GlobalPluginState` 依赖裸指针维护插件列表，导致 DAW 在快速增删轨道时发生 Use-After-Free 崩溃。
2.  **数据竞争**：`RenderState` 的双缓冲实现缺乏原子性保障，导致 UI 线程与音频线程由于时序问题产生状态撕裂。
3.  **维护成本**：过度复杂的 OOP 继承链导致代码难以测试和扩展。

Rust 版本将通过**编译期检查**强制执行线程安全，将运行时错误转化为编译时错误。

*这一部分作为项目的“初心”，内容无需改动。*

## 1.4 当前状态 (更新于 2025.11.29)

**阶段：架构设计定稿 & GUI 原型完成**

经过密集的架构讨论与验证，我们已经完成了核心逻辑的重构设计（v4.0 Final Gold），并确立了分布式通信方案。

- ✅ **渲染后端定型**：确立了 `egui` + `wgpu` 的技术栈，确保了跨平台兼容性。
- ✅ **完美的高分屏支持**：彻底掌握了 `set_scale_factor_override` 机制，实现了无拉伸、DPI 感知的 UI 缩放。
- ✅ **交互逻辑闭环**：确定了 "A/B 场景对比" + "混合 Solo" + "SUB 豁免" 的复杂交互逻辑。
- ✅ **分布式通信方案**：选定 `ZeroMQ` + `Bincode` 作为跨机通信基石，支持无锁快照广播。
- ✅ **构建流程优化**：修复了 `xtask` 打包脚本的逻辑缺陷。

**🔄 下一步：核心业务逻辑与通信层实现**
接下来的工作重心将从 UI 转入内核：实现 `MonitorParams` 参数系统、`ChannelLogic` 纯函数逻辑，以及基于 ZMQ 的 Master-Slave 广播网络。
