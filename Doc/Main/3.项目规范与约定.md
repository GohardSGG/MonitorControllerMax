# 3. 项目规范与约定

本文档定义了 MonitorControllerMax (Rust Edition) 的开发规范。

## 3.1 核心原则 (The Iron Rules)

1.  **No Raw Pointers (拒绝裸指针)**: 除非是在与 C++ FFI 交互的边界（极其罕见），否则严禁使用 `*const T` 或 `*mut T`。所有共享权必须通过 `Arc`，弱引用必须通过 `Weak`。
2.  **Allocation-Free DSP (DSP 零分配)**: 在 `process()` 回调中，严禁执行任何会导致内存分配的操作（如 `Vec::push`, `Box::new`, `format!`）。
3.  **Panic Free (拒绝崩溃)**: `unwrap()` 仅限用于测试代码或程序启动阶段。运行时逻辑必须使用 `match` 或 `if let` 处理 `Option`/`Result`。

*以上核心原则经受住了考验，保持不变。*

## 3.2 目录与文件命名规范 (重要修订)

经过第一阶段的实践，我们决定**废除原有的 `PascalCase` 文件名强制约定**，全面回归 Rust 社区的**标准 `snake_case` 风格**。

**修正原因**：强制 `PascalCase` 与 Rust 的工具链（`cargo`, `clippy` 等）和整个生态的习惯相悖，带来了不必要的摩擦和配置成本。遵循社区标准将使项目更易于维护和协作。

**新规范**:
- **目录**: 保持 `PascalCase` 以进行逻辑分组 (e.g., `Plugin`, `Source`, `UserInterface`)。
- **Rust 源文件**: 必须使用 `snake_case` (e.g., `lib.rs`, `audio_processor.rs`, `editor_state.rs`)。
- **非 Rust 文件**: 保持 `PascalCase` 或遵循其领域的常规约定 (e.g., `README.md`, `Justfile`)。

**示例目录结构**:
```
C:/Code/MonitorControllerMax/
├── 📄 Cargo.toml
├── 📂 Plugin/
│   ├── 📄 Cargo.toml
│   ├── 📂 src/
│   │   ├── 📄 lib.rs
│   │   ├── 📄 editor.rs
│   │   ├── 📄 audio.rs
│   │   └── 📄 registry.rs
│   └── 📂 assets/
...
```

## 3.3 Rust 代码风格规范

| 条目 | 风格 | 示例 | 备注 |
| :--- | :--- | :--- | :--- |
| **结构体/枚举/Trait** | `PascalCase` | `RenderState`, `PluginParams` | Rust 标准 |
| **变量/函数/模块** | `snake_case` | `process_audio`, `master_gain`, `mod user_interface` | Rust 标准 |

我们将**不再**使用 `#![allow(non_snake_case)]`。所有代码都应通过 `cargo clippy` 的检查。

## 3.4 注释规范 (必须执行)

**所有代码注释必须使用中文 (Chinese Simplified)。**

**新增规范**: 对于调用框架“胶水层”的特定、非直观的 API，必须添加注释，解释其背后的工作原理和调用意图。

**示例**:
```rust
/// 在 `Editor::create` 或尺寸变化时调用
///
/// # 注释
/// 这里必须调用 `set_scale_factor_override` 来通知 `nih-plug-egui` 的胶水层
/// 我们想要手动控制缩放因子。只有这样，它才会根据我们提供的因子
/// 去创建正确物理尺寸的 `wgpu::Texture`，从而从根本上解决 UI 拉伸问题。
fn set_scale_factor(&self, new_factor: f32) {
    self.editor_state.set_scale_factor_override(Some(new_factor));
}
```

## 3.5 GUI 实现规范 (实践驱动)

基于第一阶段的技术攻关成果，GUI 的实现必须遵循以下经过验证的最佳实践：

*   **渲染后端**: **必须**使用 `wgpu`。禁止任何基于 `glow` 的实现，以确保最大的宿主兼容性。
*   **缩放机制**: **必须**通过 `EditorState::set_scale_factor_override()` 来管理 UI 缩放。这是解决 `nih-plug` 环境下 `egui` 控件拉伸问题的唯一正确途径。
*   **状态管理**: **必须**以 `nih-plug` 的 `Params` 系统为核心。UI 控件应作为参数的“视图”，用户的交互应转化为对参数的修改请求。避免在 `Editor` 结构体中存储复杂的、需要跨线程同步的业务状态。
*   **性能**: 对于复杂的、动态的图形（如路由矩阵），应优先使用 `egui::Painter` 进行矢量绘制，避免因加载和缩放大量位图资源而导致的性能问题。

## 3.6 构建输出规范

构建脚本 (`xtask` 或 `Justfile`) 必须配置为将最终产物 (`.vst3`) 复制到以下目录：
*   `Build/Debug/`
*   `Build/Release/`
