# 3. 项目规范与约定

本文档定义了 MonitorControllerMax (Rust Edition) 的开发规范。

## 3.1 核心原则 (The Iron Rules)

1.  **No Raw Pointers (拒绝裸指针)**: 严禁使用 `*const T` 或 `*mut T`。
2.  **Allocation-Free DSP (DSP 零分配)**: 音频线程严禁内存分配。
3.  **Panic Free (拒绝崩溃)**: 运行时逻辑必须处理所有 `Result`。
4.  **Fail-Safe (故障导向安全)**: 在网络断连、Master 崩溃等异常情况下，Slave 必须保持当前状态或平滑静音，严禁产生全量爆音。

## 3.2 目录与文件命名规范

*   **Rust 源文件**: 必须使用 `snake_case` (e.g., `lib.rs`, `audio_processor.rs`)。
*   **目录**: 保持 `PascalCase` 以进行逻辑分组。

## 3.3 Rust 代码风格规范

| 条目 | 风格 | 示例 | 备注 |
| :--- | :--- | :--- | :--- |
| **结构体/枚举** | `PascalCase` | `RenderState`, `NetworkPacket` | Rust 标准 |
| **变量/函数** | `snake_case` | `process_audio`, `broadcast_state` | Rust 标准 |

## 3.4 注释规范

**所有代码注释必须使用中文 (Chinese Simplified)。**

## 3.5 GUI 实现规范

*   **渲染后端**: **必须**使用 `wgpu`。
*   **缩放机制**: **必须**通过 `set_scale_factor_override()` 管理。
*   **尺寸计算**: **严禁**硬编码像素，必须使用 `scale.s()`。
*   **状态管理**: UI 控件仅作为 `Params` 的视图，不存储业务状态。

## 3.6 网络通信规范

*   **端口约定**:
    - ZMQ 网络同步: `9123`
    - OSC 发送: `7444`
    - OSC 接收: `7445`
*   **序列化**: 必须使用 `#[repr(C)]` 标记网络结构体，确保内存布局稳定。
*   **线程模型**: 网络 IO 必须在独立的后台线程中运行，严禁阻塞 GUI 或 DSP 线程。
*   **协议版本**: 网络协议必须包含 `protocol_version` 和 `magic` 字段用于兼容性检查。

## 3.7 构建输出规范

构建脚本 (`xtask`) 必须具备错误阻断机制：如果编译或打包失败，后续的拷贝流程**绝不能**执行。

## 3.8 日志规范 (v2.5.0 新增)

### 3.8.1 模块名命名

| 模块 | 日志模块名 |
|------|-----------|
| Lib.rs | `lib` |
| Editor.rs | `editor` |
| Network.rs | `network` |
| Osc.rs | `osc` |
| Interaction.rs | `interaction` |

### 3.8.2 日志消息格式

**关键事件**：使用 `[TAG]` 前缀
```rust
logger.important("editor", "[ROLE] Standalone -> Master");
logger.important("lib", "[HOT RELOAD] OSC restart requested");
logger.important("network", "[HEARTBEAT] Timeout detected");
```

### 3.8.3 日志级别选择

| 场景 | 级别 |
|------|------|
| Role 切换、网络连接/断开、心跳超时 | Important |
| 参数变化、状态更新 | Info |
| 每帧渲染、数据包内容 | Debug |
| 错误和异常 | Error/Warn |

## 3.9 Cargo Feature 规范 (v2.5.0 新增)

### 3.9.1 Feature 定义

```toml
[features]
default = []
production = []  # 生产模式：禁用文件日志
```

### 3.9.2 Feature 检测

```rust
#[cfg(feature = "production")]
fn is_production_build() -> bool { true }

#[cfg(not(feature = "production"))]
fn is_production_build() -> bool { false }
```

## 3.10 并发规范 (v2.5.0 新增)

### 3.10.1 锁使用规范

| 场景 | 推荐方案 |
|------|---------|
| 音频线程读取 | `AtomicCell` (无锁) |
| UI 状态更新 | `RwLock` (读多写少) |
| 简单标志 | `AtomicBool` |
| 热重载请求 | `RwLock<Option<T>>` |

### 3.10.2 音频线程禁止清单

在 `process()` 中禁止:
- ❌ `Box::new()` / `Vec::push()` 等内存分配
- ❌ `Mutex::lock()` / `RwLock::write()` 等阻塞操作
- ❌ 文件 I/O、网络 I/O
- ❌ `println!()` / `eprintln!()`

允许:
- ✅ `AtomicCell::load()` / `AtomicCell::store()`
- ✅ 预分配数组访问
- ✅ 纯数学计算

## 3.11 错误处理规范 (v2.5.0 新增)

### 3.11.1 资源清理原则

**任何线程退出路径都必须清理状态标志**：

```rust
fn run_network_thread(is_running: Arc<AtomicBool>) {
    let rt = match Runtime::new() {
        Ok(rt) => rt,
        Err(e) => {
            is_running.store(false, Ordering::Release); // 清理
            return;
        }
    };
    // ... 主循环 ...
    is_running.store(false, Ordering::Release); // 正常退出也清理
}
```

### 3.11.2 常见错误模式检查清单

- [ ] 线程退出路径是否清理了 `is_running` 标志？
- [ ] `process()` 中是否有锁等待或内存分配？
- [ ] 网络协议变更是否更新了版本号？
- [ ] UI 参数变化是否需要触发热重载？
- [ ] Slave 模式下的交互是否被禁用？
- [ ] 布局切换时是否清理了相关状态？

## 3.12 版本号规范 (v2.5.0 新增)

### 3.12.1 版本号格式

`MAJOR.MINOR.PATCH`

- **MAJOR**: 不兼容的 API 变更
- **MINOR**: 向后兼容的功能新增
- **PATCH**: 向后兼容的 bug 修复

### 3.12.2 协议版本

协议版本独立于插件版本，只在协议结构变化时递增：

| 插件版本 | 协议版本 |
|---------|---------|
| 2.0.x | v1 |
| 2.5.x | v2 |
