# 缩放机制深度对比分析报告

本报告深度探究了 `MonitorControllerMax/Library/nih-plug/plugins/diopser` (基于 Vizia) 与 `MonitorControllerMax/Source/Plugin` (基于 Egui) 在 UI 缩放实现上的核心差异。

## 1. 核心结论 (Executive Summary)

**结论**：两者最终的视觉效果都是 **整体缩放 (Uniform Zoom)**，即随着窗口变大，所有 UI 元素等比例放大。但是，**交互方式** 和 **驱动逻辑** 存在本质区别：

*   **Diopser (Vizia)**：采用 **主动驱动** 模式。右下角的三角形是一个独立的 `ResizeHandle` 控件，它捕获鼠标拖拽事件，计算缩放比例，并直接驱动窗口内容的缩放。
*   **MonitorControllerMax (Egui)**：采用 **被动响应** 模式。依赖操作系统的窗口边框（或宿主提供的调整手柄）改变窗口大小，然后代码根据新的窗口物理宽度，反向计算缩放比例 `ScaleContext` 并应用。

---

## 2. Diopser (Vizia) 实现深度解析

Diopser 的右下角缩放完全由 `nih_plug_vizia` 提供的标准控件 `ResizeHandle` 实现。

### 2.1 代码位置
*   **文件**: `nih_plug_vizia/src/widgets/resize_handle.rs`
*   **调用**: `diopser/src/editor.rs` (第 83 行 `ResizeHandle::new(cx)`)

### 2.2 实现逻辑
1.  **控件绘制**：这是一个绘制在 UI 最顶层（最后添加）的三角形视图，通常位于右下角。
2.  **交互捕获**：监听 `MouseDown` 和 `MouseMove` 事件。
3.  **相对计算 (核心)**：
    *   当用户点击时，记录当前的 `start_scale_factor` (起始缩放) 和 `start_physical_coordinates` (起始鼠标物理坐标)。
    *   拖拽时，计算当前鼠标位置相对于起始位置的比率：
        ```rust
        // 简化伪代码：计算相对于起始点的移动比例
        new_scale = start_scale * (current_mouse_pos / start_mouse_pos)
        ```
    *   它选取 X 轴和 Y 轴变化中较大的那个比率，以保持比例（或者在该简易实现中直接修改 scale factor）。
4.  **应用缩放**：直接调用 `cx.set_user_scale_factor(new_scale)`。这是 Vizia 框架内建的 API。
5.  **Vizia 引擎反应**：Vizia 检测到 Scale Factor 变化，会自动重新布局。并没有改变窗口的逻辑尺寸 (Logical Size) 定义（仍是 600x490），但因为缩放因子的变化，物理像素渲染内容会变大/变小。通常这会结合 `nih_plug_vizia` 的封装，最终反馈给宿主去调整物理窗口大小。

**特点**：
*   **平滑**：缩放是基于鼠标移动的相对量，手感非常直接，类似于调整图片大小。
*   **集成**：缩放手柄是 UI 的一部分，不需要依赖 OS 边框。

---

## 3. MonitorControllerMax (Egui) 实现深度解析

MCM 目前的实现依赖于对窗口尺寸变化的 **响应**。

### 3.1 代码位置
*   **文件**: `Source/Plugin/src/scale.rs` 和 `Source/Plugin/src/editor.rs`
*   **核心**: `ScaleContext` 结构体

### 3.2 实现逻辑
1.  **窗口尺寸获取**：在每一帧渲染开始时，获取当前的物理窗口宽度 `physical_width`。
    ```rust
    // editor.rs:243
    let (physical_width, _) = egui_state_clone.size();
    ```
2.  **绝对计算 (核心)**：
    根据物理宽度和设计基准宽度 (720px) 计算当前的缩放因子。
    ```rust
    // scale.rs:20
    let factor = (physical_width as f32 / base_width).clamp(0.5, 4.0);
    ```
3.  **应用缩放**：
    *   **全局缩放**：`ctx.set_pixels_per_point(scale.factor)`。这告诉 Egui 1 个逻辑点 = N 个物理像素。
    *   **手动修正**：在布局代码中，使用了 `scale.s(value)` (即 `value * factor`)。
        *   这里存在一个微小的**双重缩放风险**：`pixels_per_point` 已经会让 Egui 放大绘制。例如宽度 100，Factor 2.0，Egui 会画 200 像素宽。如果再传入 `scale.s(100)` (即 200) 并配合 Factor 2.0，理论上 Egui 会尝试画 400 像素。
        *   但仔细看 `ScaleContext::from_physical_size` 的逻辑，它是基于物理像素反推 Factor。
        *   MCM 的逻辑实际上是：始终让 UI 认为自己处在 720x720 的逻辑空间，然后通过 `pixels_per_point` 将这 720x720 映射到当前的物理窗口大小。

**特点**：
*   **响应式**：只要窗口变大（无论是拖 OS 边框还是拖左上角），内容就会自适应填满。
*   **无内置手柄**：目前 Egui 实现中没有专门的 `ResizeHandle` 控件，而是依赖 `ResizableWindow` 提供的能力（使用 OS 标准窗口行为）。

---

## 4. 关键差异总结

| 特性 | Diopser (Vizia) | MonitorControllerMax (Egui) |
| :--- | :--- | :--- |
| **可调整区域** | 仅右下角三角形区域 (无需 OS 边框) | 整个窗口边框 (依赖 OS/Container) |
| **计算方式** | **相对增量** (Relative Delta) <br> 基于鼠标移动距离的百分比 | **绝对重算** (Absolute Recalc) <br> `物理宽度 / 基准宽度` |
| **驱动流向** | 鼠标 -> 缩放因子 -> 窗口大小 | 窗口大小 -> 缩放因子 -> UI重新绘制 |
| **手感** | 类似图片缩放，鼠标紧跟角落，像素级跟随 | 类似网页缩放，窗口变大后内容适配 |

## 5. 建议

如果您希望在 MCM (Egui) 中实现类似 Diopser 的右下角拖拽体验：

1.  **需要自定义组件**：在 Egui 的右下角绘制一个三角形 Canvas/Area。
2.  **捕获拖拽**：使用 `ui.interact` 捕获该区域的 Drag 事件。
3.  **请求调整大小**：
    *   这是难点。Egui 本身是 Immediate Mode (即时模式)，它通常 **被动** 接受窗口大小。
    *   要实现主动缩放，你需要能够反向调用宿主 (baseview/nih-plug) 的 `set_size` 接口，或者，如果 `ResizableWindow` 支持，可以通过拖拽去更新 `ResizableWindow` 的内部状态。
    *   目前的 `ScaleContext` 设计是非常适合 Egui 的推荐做法（即响应式）。引入主动缩放手柄需要 Egui 与底层窗口系统有更复杂的交互。

目前 MCM 的 "响应式 + 锁定宽高比 (Aspect Ratio)" 方案在工程上更稳健，也更符合 Egui 的设计哲学。Diopser 的方案更适合 Vizia 这种保留模式 (Retained Mode) 且深度集成的 UI 框架。
