<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JUCE: AudioBuffer&lt; Type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- main-nav -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAudioBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AudioBuffer&lt; Type &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__juce__audio__basics.html">juce_audio_basics</a> &raquo; <a class="el" href="group__juce__audio__basics-buffers.html">buffers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A multi-channel buffer containing floating point audio samples.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a068bbc97f0a351ef72dcb09060eb3c64" id="r_a068bbc97f0a351ef72dcb09060eb3c64"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a068bbc97f0a351ef72dcb09060eb3c64">SampleType</a> = Type</td></tr>
<tr class="memdesc:a068bbc97f0a351ef72dcb09060eb3c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allows templated code that takes an <a class="el" href="classAudioBuffer.html" title="A multi-channel buffer containing floating point audio samples.">AudioBuffer</a> to access its sample type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f480180fae64496886e43ea2b15ddc8" id="r_a4f480180fae64496886e43ea2b15ddc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f480180fae64496886e43ea2b15ddc8">AudioBuffer</a> () noexcept</td></tr>
<tr class="memdesc:a4f480180fae64496886e43ea2b15ddc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty buffer with 0 channels and 0 length.  <br /></td></tr>
<tr class="memitem:ab2e7c447c820c6ef23b0f7a9cacf920d" id="r_ab2e7c447c820c6ef23b0f7a9cacf920d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2e7c447c820c6ef23b0f7a9cacf920d">AudioBuffer</a> (int numChannelsToAllocate, int numSamplesToAllocate)</td></tr>
<tr class="memdesc:ab2e7c447c820c6ef23b0f7a9cacf920d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer with a specified number of channels and samples.  <br /></td></tr>
<tr class="memitem:ada2cf3f1e306a207f3d689d37192b823" id="r_ada2cf3f1e306a207f3d689d37192b823"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada2cf3f1e306a207f3d689d37192b823">AudioBuffer</a> (Type *const *dataToReferTo, int numChannelsToUse, int numSamples)</td></tr>
<tr class="memdesc:ada2cf3f1e306a207f3d689d37192b823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer using a pre-allocated block of memory.  <br /></td></tr>
<tr class="memitem:afcd4c606bb2fde74fea189eedcea96ec" id="r_afcd4c606bb2fde74fea189eedcea96ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcd4c606bb2fde74fea189eedcea96ec">AudioBuffer</a> (Type *const *dataToReferTo, int numChannelsToUse, int startSample, int numSamples)</td></tr>
<tr class="memdesc:afcd4c606bb2fde74fea189eedcea96ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer using a pre-allocated block of memory.  <br /></td></tr>
<tr class="memitem:ad773e1b58a9ec886349456b5f1a926d5" id="r_ad773e1b58a9ec886349456b5f1a926d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad773e1b58a9ec886349456b5f1a926d5">AudioBuffer</a> (const <a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:ad773e1b58a9ec886349456b5f1a926d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another buffer.  <br /></td></tr>
<tr class="memitem:a2a0651a32b3b54c31807de1be5c70321" id="r_a2a0651a32b3b54c31807de1be5c70321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a0651a32b3b54c31807de1be5c70321">operator=</a> (const <a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:a2a0651a32b3b54c31807de1be5c70321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another buffer onto this one.  <br /></td></tr>
<tr class="memitem:adf1c10e8cd0cc4ca8dcfa33f9d5ebced" id="r_adf1c10e8cd0cc4ca8dcfa33f9d5ebced"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf1c10e8cd0cc4ca8dcfa33f9d5ebced">~AudioBuffer</a> ()=default</td></tr>
<tr class="memdesc:adf1c10e8cd0cc4ca8dcfa33f9d5ebced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="memitem:a4124843b0d14b6d5b3ae282366e6824d" id="r_a4124843b0d14b6d5b3ae282366e6824d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4124843b0d14b6d5b3ae282366e6824d">AudioBuffer</a> (<a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a4124843b0d14b6d5b3ae282366e6824d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="memitem:a710f75c5e97718acdf82d946ac21fc9c" id="r_a710f75c5e97718acdf82d946ac21fc9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a710f75c5e97718acdf82d946ac21fc9c">operator=</a> (<a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a710f75c5e97718acdf82d946ac21fc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <br /></td></tr>
<tr class="memitem:a3a9ecde91bf5b96871ce3a474c1d831f" id="r_a3a9ecde91bf5b96871ce3a474c1d831f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a9ecde91bf5b96871ce3a474c1d831f">getNumChannels</a> () const noexcept</td></tr>
<tr class="memdesc:a3a9ecde91bf5b96871ce3a474c1d831f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of channels of audio data that this buffer contains.  <br /></td></tr>
<tr class="memitem:a74e3eeed9991f6633570b3bbcd723e2b" id="r_a74e3eeed9991f6633570b3bbcd723e2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74e3eeed9991f6633570b3bbcd723e2b">getNumSamples</a> () const noexcept</td></tr>
<tr class="memdesc:a74e3eeed9991f6633570b3bbcd723e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of samples allocated in each of the buffer's channels.  <br /></td></tr>
<tr class="memitem:a91e852775811ee81a1d21574af224866" id="r_a91e852775811ee81a1d21574af224866"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91e852775811ee81a1d21574af224866">getReadPointer</a> (int channelNumber) const noexcept</td></tr>
<tr class="memdesc:a91e852775811ee81a1d21574af224866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array of read-only samples in one of the buffer's channels.  <br /></td></tr>
<tr class="memitem:a71651918c90d036e0966aae1881cae48" id="r_a71651918c90d036e0966aae1881cae48"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71651918c90d036e0966aae1881cae48">getReadPointer</a> (int channelNumber, int sampleIndex) const noexcept</td></tr>
<tr class="memdesc:a71651918c90d036e0966aae1881cae48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array of read-only samples in one of the buffer's channels.  <br /></td></tr>
<tr class="memitem:a10cfe91eb4965895bc258cee02409d3b" id="r_a10cfe91eb4965895bc258cee02409d3b"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10cfe91eb4965895bc258cee02409d3b">getWritePointer</a> (int channelNumber) noexcept</td></tr>
<tr class="memdesc:a10cfe91eb4965895bc258cee02409d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writeable pointer to one of the buffer's channels.  <br /></td></tr>
<tr class="memitem:af747c38dec0ab271b682949e646cd5c8" id="r_af747c38dec0ab271b682949e646cd5c8"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af747c38dec0ab271b682949e646cd5c8">getWritePointer</a> (int channelNumber, int sampleIndex) noexcept</td></tr>
<tr class="memdesc:af747c38dec0ab271b682949e646cd5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writeable pointer to one of the buffer's channels.  <br /></td></tr>
<tr class="memitem:a7f935a348a10bc8548a9046c745d10ee" id="r_a7f935a348a10bc8548a9046c745d10ee"><td class="memItemLeft" align="right" valign="top">const Type *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f935a348a10bc8548a9046c745d10ee">getArrayOfReadPointers</a> () const noexcept</td></tr>
<tr class="memdesc:a7f935a348a10bc8548a9046c745d10ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of pointers to the channels in the buffer.  <br /></td></tr>
<tr class="memitem:a68d9da790b234a055abab08f94fb7b29" id="r_a68d9da790b234a055abab08f94fb7b29"><td class="memItemLeft" align="right" valign="top">Type *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68d9da790b234a055abab08f94fb7b29">getArrayOfWritePointers</a> () noexcept</td></tr>
<tr class="memdesc:a68d9da790b234a055abab08f94fb7b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of pointers to the channels in the buffer.  <br /></td></tr>
<tr class="memitem:a4434de94aa03d7db6d7ef06977ddf0ac" id="r_a4434de94aa03d7db6d7ef06977ddf0ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4434de94aa03d7db6d7ef06977ddf0ac">setSize</a> (int newNumChannels, int newNumSamples, bool keepExistingContent=false, bool clearExtraSpace=false, bool avoidReallocating=false)</td></tr>
<tr class="memdesc:a4434de94aa03d7db6d7ef06977ddf0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the buffer's size or number of channels.  <br /></td></tr>
<tr class="memitem:ad37378c42606504558b6de1476a1cb1c" id="r_ad37378c42606504558b6de1476a1cb1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad37378c42606504558b6de1476a1cb1c">setDataToReferTo</a> (Type *const *dataToReferTo, int newNumChannels, int newStartSample, int newNumSamples)</td></tr>
<tr class="memdesc:ad37378c42606504558b6de1476a1cb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this buffer point to a pre-allocated set of channel data arrays.  <br /></td></tr>
<tr class="memitem:a0aff1f124d400ca44fde84c6fe3da2f9" id="r_a0aff1f124d400ca44fde84c6fe3da2f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aff1f124d400ca44fde84c6fe3da2f9">setDataToReferTo</a> (Type *const *dataToReferTo, int newNumChannels, int newNumSamples)</td></tr>
<tr class="memdesc:a0aff1f124d400ca44fde84c6fe3da2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this buffer point to a pre-allocated set of channel data arrays.  <br /></td></tr>
<tr class="memitem:a88f19397f068366e13aa53a0b6f92913" id="r_a88f19397f068366e13aa53a0b6f92913"><td class="memTemplParams" colspan="2">template&lt;typename OtherType&gt; </td></tr>
<tr class="memitem:a88f19397f068366e13aa53a0b6f92913 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88f19397f068366e13aa53a0b6f92913">makeCopyOf</a> (const <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; OtherType &gt; &amp;other, bool avoidReallocating=false)</td></tr>
<tr class="memdesc:a88f19397f068366e13aa53a0b6f92913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this buffer to match the given one, and copies all of its content across.  <br /></td></tr>
<tr class="memitem:a7dcadc4a02b048ae99166b5b306e552a" id="r_a7dcadc4a02b048ae99166b5b306e552a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dcadc4a02b048ae99166b5b306e552a">clear</a> () noexcept</td></tr>
<tr class="memdesc:a7dcadc4a02b048ae99166b5b306e552a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all the samples in all channels and marks the buffer as cleared.  <br /></td></tr>
<tr class="memitem:a97d34c7bc5dfd19fa9450d112972422b" id="r_a97d34c7bc5dfd19fa9450d112972422b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97d34c7bc5dfd19fa9450d112972422b">clear</a> (int startSample, int numSamples) noexcept</td></tr>
<tr class="memdesc:a97d34c7bc5dfd19fa9450d112972422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a specified region of all the channels.  <br /></td></tr>
<tr class="memitem:a3c0cc34d68718a0f24bcea846cf92f61" id="r_a3c0cc34d68718a0f24bcea846cf92f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c0cc34d68718a0f24bcea846cf92f61">clear</a> (int channel, int startSample, int numSamples) noexcept</td></tr>
<tr class="memdesc:a3c0cc34d68718a0f24bcea846cf92f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a specified region of just one channel.  <br /></td></tr>
<tr class="memitem:acc922971fe78c785110e46d30c210d9c" id="r_acc922971fe78c785110e46d30c210d9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc922971fe78c785110e46d30c210d9c">hasBeenCleared</a> () const noexcept</td></tr>
<tr class="memdesc:acc922971fe78c785110e46d30c210d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the buffer has been entirely cleared.  <br /></td></tr>
<tr class="memitem:ada26c9e1814e37f3e2c8b1248e916bfe" id="r_ada26c9e1814e37f3e2c8b1248e916bfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada26c9e1814e37f3e2c8b1248e916bfe">setNotClear</a> () noexcept</td></tr>
<tr class="memdesc:ada26c9e1814e37f3e2c8b1248e916bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the internal cleared flag of the buffer to false.  <br /></td></tr>
<tr class="memitem:afa9b351b6e3cba941cf7c44860851991" id="r_afa9b351b6e3cba941cf7c44860851991"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa9b351b6e3cba941cf7c44860851991">getSample</a> (int channel, int sampleIndex) const noexcept</td></tr>
<tr class="memdesc:afa9b351b6e3cba941cf7c44860851991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sample from the buffer.  <br /></td></tr>
<tr class="memitem:a8aba905085e81fefb8ef4c8589c9e7d8" id="r_a8aba905085e81fefb8ef4c8589c9e7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aba905085e81fefb8ef4c8589c9e7d8">setSample</a> (int destChannel, int destSample, Type newValue) noexcept</td></tr>
<tr class="memdesc:a8aba905085e81fefb8ef4c8589c9e7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a sample in the buffer.  <br /></td></tr>
<tr class="memitem:ab46e9ad400252255daa1086b354454b8" id="r_ab46e9ad400252255daa1086b354454b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab46e9ad400252255daa1086b354454b8">addSample</a> (int destChannel, int destSample, Type valueToAdd) noexcept</td></tr>
<tr class="memdesc:ab46e9ad400252255daa1086b354454b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a value to a sample in the buffer.  <br /></td></tr>
<tr class="memitem:a9ffc61d339e455d4bddc7cf055a63ee3" id="r_a9ffc61d339e455d4bddc7cf055a63ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ffc61d339e455d4bddc7cf055a63ee3">applyGain</a> (int channel, int startSample, int numSamples, Type gain) noexcept</td></tr>
<tr class="memdesc:a9ffc61d339e455d4bddc7cf055a63ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a gain multiple to a region of one channel.  <br /></td></tr>
<tr class="memitem:a25c9a05ff546379ba7bed697e616bfb3" id="r_a25c9a05ff546379ba7bed697e616bfb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25c9a05ff546379ba7bed697e616bfb3">applyGain</a> (int startSample, int numSamples, Type gain) noexcept</td></tr>
<tr class="memdesc:a25c9a05ff546379ba7bed697e616bfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a gain multiple to a region of all the channels.  <br /></td></tr>
<tr class="memitem:a0c4794d6dbfd6d0c20d041fffc9939af" id="r_a0c4794d6dbfd6d0c20d041fffc9939af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c4794d6dbfd6d0c20d041fffc9939af">applyGain</a> (Type gain) noexcept</td></tr>
<tr class="memdesc:a0c4794d6dbfd6d0c20d041fffc9939af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a gain multiple to all the audio data.  <br /></td></tr>
<tr class="memitem:ab0542e5b626b36087f0054e795695682" id="r_ab0542e5b626b36087f0054e795695682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0542e5b626b36087f0054e795695682">applyGainRamp</a> (int channel, int startSample, int numSamples, Type startGain, Type endGain) noexcept</td></tr>
<tr class="memdesc:ab0542e5b626b36087f0054e795695682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a range of gains to a region of a channel.  <br /></td></tr>
<tr class="memitem:af5cde88e72248367626419733fc58fc2" id="r_af5cde88e72248367626419733fc58fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5cde88e72248367626419733fc58fc2">applyGainRamp</a> (int startSample, int numSamples, Type startGain, Type endGain) noexcept</td></tr>
<tr class="memdesc:af5cde88e72248367626419733fc58fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a range of gains to a region of all channels.  <br /></td></tr>
<tr class="memitem:abb2b03021cca3f0382d602d0b9755a08" id="r_abb2b03021cca3f0382d602d0b9755a08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb2b03021cca3f0382d602d0b9755a08">addFrom</a> (int destChannel, int destStartSample, const <a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp;source, int sourceChannel, int sourceStartSample, int numSamples, Type gainToApplyToSource=Type(1)) noexcept</td></tr>
<tr class="memdesc:abb2b03021cca3f0382d602d0b9755a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds samples from another buffer to this one.  <br /></td></tr>
<tr class="memitem:ae4ad8d6eb40abc86e9940ae90c79c380" id="r_ae4ad8d6eb40abc86e9940ae90c79c380"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4ad8d6eb40abc86e9940ae90c79c380">addFrom</a> (int destChannel, int destStartSample, const Type *source, int numSamples, Type gainToApplyToSource=Type(1)) noexcept</td></tr>
<tr class="memdesc:ae4ad8d6eb40abc86e9940ae90c79c380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds samples from an array of floats to one of the channels.  <br /></td></tr>
<tr class="memitem:a1853da41f2a3d87fa6291a2bf2adca05" id="r_a1853da41f2a3d87fa6291a2bf2adca05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1853da41f2a3d87fa6291a2bf2adca05">addFromWithRamp</a> (int destChannel, int destStartSample, const Type *source, int numSamples, Type startGain, Type endGain) noexcept</td></tr>
<tr class="memdesc:a1853da41f2a3d87fa6291a2bf2adca05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds samples from an array of floats, applying a gain ramp to them.  <br /></td></tr>
<tr class="memitem:a9ec751bfa23564c011bf3940ca17b743" id="r_a9ec751bfa23564c011bf3940ca17b743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ec751bfa23564c011bf3940ca17b743">copyFrom</a> (int destChannel, int destStartSample, const <a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp;source, int sourceChannel, int sourceStartSample, int numSamples) noexcept</td></tr>
<tr class="memdesc:a9ec751bfa23564c011bf3940ca17b743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies samples from another buffer to this one.  <br /></td></tr>
<tr class="memitem:a80d6c874d56ebfbf3c0aca2d2b8c4ab7" id="r_a80d6c874d56ebfbf3c0aca2d2b8c4ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80d6c874d56ebfbf3c0aca2d2b8c4ab7">copyFrom</a> (int destChannel, int destStartSample, const Type *source, int numSamples) noexcept</td></tr>
<tr class="memdesc:a80d6c874d56ebfbf3c0aca2d2b8c4ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies samples from an array of floats into one of the channels.  <br /></td></tr>
<tr class="memitem:a2684ecc739be23105f3a2f0605e2a928" id="r_a2684ecc739be23105f3a2f0605e2a928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2684ecc739be23105f3a2f0605e2a928">copyFrom</a> (int destChannel, int destStartSample, const Type *source, int numSamples, Type gain) noexcept</td></tr>
<tr class="memdesc:a2684ecc739be23105f3a2f0605e2a928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies samples from an array of floats into one of the channels, applying a gain to it.  <br /></td></tr>
<tr class="memitem:ae1cff4483f4022ed49dc91eda31098c9" id="r_ae1cff4483f4022ed49dc91eda31098c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1cff4483f4022ed49dc91eda31098c9">copyFromWithRamp</a> (int destChannel, int destStartSample, const Type *source, int numSamples, Type startGain, Type endGain) noexcept</td></tr>
<tr class="memdesc:ae1cff4483f4022ed49dc91eda31098c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies samples from an array of floats into one of the channels, applying a gain ramp.  <br /></td></tr>
<tr class="memitem:a7f804a29a233fb110901f61e0fac071a" id="r_a7f804a29a233fb110901f61e0fac071a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRange.html">Range</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f804a29a233fb110901f61e0fac071a">findMinMax</a> (int channel, int startSample, int numSamples) const noexcept</td></tr>
<tr class="memdesc:a7f804a29a233fb110901f61e0fac071a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classRange.html" title="A general-purpose range object, that simply represents any linear range with a start and end point.">Range</a> indicating the lowest and highest sample values in a given section.  <br /></td></tr>
<tr class="memitem:af0f0099350d92091c24e8b14b149328e" id="r_af0f0099350d92091c24e8b14b149328e"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0f0099350d92091c24e8b14b149328e">getMagnitude</a> (int channel, int startSample, int numSamples) const noexcept</td></tr>
<tr class="memdesc:af0f0099350d92091c24e8b14b149328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest absolute sample value within a region of a channel.  <br /></td></tr>
<tr class="memitem:afdd67f1761872b093a2065dc8f9b3c9e" id="r_afdd67f1761872b093a2065dc8f9b3c9e"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdd67f1761872b093a2065dc8f9b3c9e">getMagnitude</a> (int startSample, int numSamples) const noexcept</td></tr>
<tr class="memdesc:afdd67f1761872b093a2065dc8f9b3c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest absolute sample value within a region on all channels.  <br /></td></tr>
<tr class="memitem:a7e2c4235fa4a6da3aca73f17b46704ac" id="r_a7e2c4235fa4a6da3aca73f17b46704ac"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e2c4235fa4a6da3aca73f17b46704ac">getRMSLevel</a> (int channel, int startSample, int numSamples) const noexcept</td></tr>
<tr class="memdesc:a7e2c4235fa4a6da3aca73f17b46704ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root mean squared level for a region of a channel.  <br /></td></tr>
<tr class="memitem:a41cbf05e4d7054e02d5844b09a8eceb5" id="r_a41cbf05e4d7054e02d5844b09a8eceb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41cbf05e4d7054e02d5844b09a8eceb5">reverse</a> (int channel, int startSample, int numSamples) const noexcept</td></tr>
<tr class="memdesc:a41cbf05e4d7054e02d5844b09a8eceb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a part of a channel.  <br /></td></tr>
<tr class="memitem:a842674c6e6bd70f27fcbdef7cc76e283" id="r_a842674c6e6bd70f27fcbdef7cc76e283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a842674c6e6bd70f27fcbdef7cc76e283">reverse</a> (int startSample, int numSamples) const noexcept</td></tr>
<tr class="memdesc:a842674c6e6bd70f27fcbdef7cc76e283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a part of the buffer.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Type&gt;<br />
class AudioBuffer&lt; Type &gt;</div><p>A multi-channel buffer containing floating point audio samples. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a068bbc97f0a351ef72dcb09060eb3c64" name="a068bbc97f0a351ef72dcb09060eb3c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068bbc97f0a351ef72dcb09060eb3c64">&#9670;&#160;</a></span>SampleType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::SampleType = Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This allows templated code that takes an <a class="el" href="classAudioBuffer.html" title="A multi-channel buffer containing floating point audio samples.">AudioBuffer</a> to access its sample type. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4f480180fae64496886e43ea2b15ddc8" name="a4f480180fae64496886e43ea2b15ddc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f480180fae64496886e43ea2b15ddc8">&#9670;&#160;</a></span>AudioBuffer() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;<a class="el" href="classAudioBuffer.html">::AudioBuffer</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty buffer with 0 channels and 0 length. </p>

</div>
</div>
<a id="ab2e7c447c820c6ef23b0f7a9cacf920d" name="ab2e7c447c820c6ef23b0f7a9cacf920d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e7c447c820c6ef23b0f7a9cacf920d">&#9670;&#160;</a></span>AudioBuffer() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;<a class="el" href="classAudioBuffer.html">::AudioBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numChannelsToAllocate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamplesToAllocate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a buffer with a specified number of channels and samples. </p>
<p>The contents of the buffer will initially be undefined, so use <a class="el" href="#a7dcadc4a02b048ae99166b5b306e552a" title="Clears all the samples in all channels and marks the buffer as cleared.">clear()</a> to set all the samples to zero.</p>
<p>The buffer will allocate its memory internally, and this will be released when the buffer is deleted. If the memory can't be allocated, this will throw a std::bad_alloc exception. </p>

</div>
</div>
<a id="ada2cf3f1e306a207f3d689d37192b823" name="ada2cf3f1e306a207f3d689d37192b823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2cf3f1e306a207f3d689d37192b823">&#9670;&#160;</a></span>AudioBuffer() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;<a class="el" href="classAudioBuffer.html">::AudioBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">Type *const *</td>          <td class="paramname"><span class="paramname"><em>dataToReferTo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numChannelsToUse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a buffer using a pre-allocated block of memory. </p>
<p>Note that if the buffer is resized or its number of channels is changed, it will re-allocate memory internally and copy the existing data to this new area, so it will then stop directly addressing this memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToReferTo</td><td>a pre-allocated array containing pointers to the data for each channel that should be used by this buffer. The buffer will only refer to this memory, it won't try to delete it when the buffer is deleted or resized. </td></tr>
    <tr><td class="paramname">numChannelsToUse</td><td>the number of channels to use - this must correspond to the number of elements in the array passed in </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to use - this must correspond to the size of the arrays passed in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcd4c606bb2fde74fea189eedcea96ec" name="afcd4c606bb2fde74fea189eedcea96ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd4c606bb2fde74fea189eedcea96ec">&#9670;&#160;</a></span>AudioBuffer() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;<a class="el" href="classAudioBuffer.html">::AudioBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">Type *const *</td>          <td class="paramname"><span class="paramname"><em>dataToReferTo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numChannelsToUse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a buffer using a pre-allocated block of memory. </p>
<p>Note that if the buffer is resized or its number of channels is changed, it will re-allocate memory internally and copy the existing data to this new area, so it will then stop directly addressing this memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToReferTo</td><td>a pre-allocated array containing pointers to the data for each channel that should be used by this buffer. The buffer will only refer to this memory, it won't try to delete it when the buffer is deleted or resized. </td></tr>
    <tr><td class="paramname">numChannelsToUse</td><td>the number of channels to use - this must correspond to the number of elements in the array passed in </td></tr>
    <tr><td class="paramname">startSample</td><td>the offset within the arrays at which the data begins </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to use - this must correspond to the size of the arrays passed in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad773e1b58a9ec886349456b5f1a926d5" name="ad773e1b58a9ec886349456b5f1a926d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad773e1b58a9ec886349456b5f1a926d5">&#9670;&#160;</a></span>AudioBuffer() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;<a class="el" href="classAudioBuffer.html">::AudioBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies another buffer. </p>
<p>This buffer will make its own copy of the other's data, unless the buffer was created using an external data buffer, in which case both buffers will just point to the same shared block of data. </p>

</div>
</div>
<a id="adf1c10e8cd0cc4ca8dcfa33f9d5ebced" name="adf1c10e8cd0cc4ca8dcfa33f9d5ebced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1c10e8cd0cc4ca8dcfa33f9d5ebced">&#9670;&#160;</a></span>~AudioBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::~<a class="el" href="classAudioBuffer.html">AudioBuffer</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This will free any memory allocated by the buffer. </p>

</div>
</div>
<a id="a4124843b0d14b6d5b3ae282366e6824d" name="a4124843b0d14b6d5b3ae282366e6824d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4124843b0d14b6d5b3ae282366e6824d">&#9670;&#160;</a></span>AudioBuffer() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;<a class="el" href="classAudioBuffer.html">::AudioBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a2a0651a32b3b54c31807de1be5c70321" name="a2a0651a32b3b54c31807de1be5c70321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0651a32b3b54c31807de1be5c70321">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp; <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies another buffer onto this one. </p>
<p>This buffer's size will be changed to that of the other buffer. </p>

</div>
</div>
<a id="a710f75c5e97718acdf82d946ac21fc9c" name="a710f75c5e97718acdf82d946ac21fc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710f75c5e97718acdf82d946ac21fc9c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAudioBuffer.html">AudioBuffer</a> &amp; <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>

</div>
</div>
<a id="a3a9ecde91bf5b96871ce3a474c1d831f" name="a3a9ecde91bf5b96871ce3a474c1d831f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9ecde91bf5b96871ce3a474c1d831f">&#9670;&#160;</a></span>getNumChannels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getNumChannels </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of channels of audio data that this buffer contains. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a74e3eeed9991f6633570b3bbcd723e2b" title="Returns the number of samples allocated in each of the buffer&#39;s channels.">getNumSamples</a>, <a class="el" href="#a91e852775811ee81a1d21574af224866" title="Returns a pointer to an array of read-only samples in one of the buffer&#39;s channels.">getReadPointer</a>, <a class="el" href="#a10cfe91eb4965895bc258cee02409d3b" title="Returns a writeable pointer to one of the buffer&#39;s channels.">getWritePointer</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classADSR.html#a883ba7e39999c2c77786cca1b7926694">ADSR::applyEnvelopeToBuffer()</a>, <a class="el" href="#a88f19397f068366e13aa53a0b6f92913">AudioBuffer&lt; float &gt;::makeCopyOf()</a>, <a class="el" href="#a2a0651a32b3b54c31807de1be5c70321">AudioBuffer&lt; float &gt;::operator=()</a>, and <a class="el" href="group__juce__audio__basics-buffers.html#ga73bcc9cfaf60a2beb7a69b39bbf0c02f">operator==()</a>.</p>

</div>
</div>
<a id="a74e3eeed9991f6633570b3bbcd723e2b" name="a74e3eeed9991f6633570b3bbcd723e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e3eeed9991f6633570b3bbcd723e2b">&#9670;&#160;</a></span>getNumSamples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getNumSamples </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of samples allocated in each of the buffer's channels. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3a9ecde91bf5b96871ce3a474c1d831f" title="Returns the number of channels of audio data that this buffer contains.">getNumChannels</a>, <a class="el" href="#a91e852775811ee81a1d21574af224866" title="Returns a pointer to an array of read-only samples in one of the buffer&#39;s channels.">getReadPointer</a>, <a class="el" href="#a10cfe91eb4965895bc258cee02409d3b" title="Returns a writeable pointer to one of the buffer&#39;s channels.">getWritePointer</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classADSR.html#a883ba7e39999c2c77786cca1b7926694">ADSR::applyEnvelopeToBuffer()</a>, <a class="el" href="classAudioProcessor.html#a733377c6d541c099dc5857be77cd1af1">AudioProcessor::getBusBuffer()</a>, <a class="el" href="#a88f19397f068366e13aa53a0b6f92913">AudioBuffer&lt; float &gt;::makeCopyOf()</a>, and <a class="el" href="#a2a0651a32b3b54c31807de1be5c70321">AudioBuffer&lt; float &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a91e852775811ee81a1d21574af224866" name="a91e852775811ee81a1d21574af224866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e852775811ee81a1d21574af224866">&#9670;&#160;</a></span>getReadPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type * <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getReadPointer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channelNumber</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to an array of read-only samples in one of the buffer's channels. </p>
<p>For speed, this doesn't check whether the channel number is out of range, so be careful when using it!</p>
<p>If you need to write to the data, do NOT call this method and const_cast the result! Instead, you must call getWritePointer so that the buffer knows you're planning on modifying the data. </p>

<p class="reference">Referenced by <a class="el" href="#a88f19397f068366e13aa53a0b6f92913">AudioBuffer&lt; float &gt;::makeCopyOf()</a>.</p>

</div>
</div>
<a id="a71651918c90d036e0966aae1881cae48" name="a71651918c90d036e0966aae1881cae48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71651918c90d036e0966aae1881cae48">&#9670;&#160;</a></span>getReadPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type * <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getReadPointer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channelNumber</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sampleIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to an array of read-only samples in one of the buffer's channels. </p>
<p>For speed, this doesn't check whether the channel number or index are out of range, so be careful when using it!</p>
<p>If you need to write to the data, do NOT call this method and const_cast the result! Instead, you must call getWritePointer so that the buffer knows you're planning on modifying the data. </p>

</div>
</div>
<a id="a10cfe91eb4965895bc258cee02409d3b" name="a10cfe91eb4965895bc258cee02409d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cfe91eb4965895bc258cee02409d3b">&#9670;&#160;</a></span>getWritePointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type * <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getWritePointer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channelNumber</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a writeable pointer to one of the buffer's channels. </p>
<p>For speed, this doesn't check whether the channel number is out of range, so be careful when using it!</p>
<p>Note that if you're not planning on writing to the data, you should always use getReadPointer instead.</p>
<p>This will mark the buffer as not cleared and the hasBeenCleared method will return false after this call. If you retain this write pointer and write some data to the buffer after calling its clear method, subsequent clear calls will do nothing. To avoid this either call this method each time you need to write data, or use the setNotClear method to force the internal cleared flag to false.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ada26c9e1814e37f3e2c8b1248e916bfe" title="Forces the internal cleared flag of the buffer to false.">setNotClear</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classADSR.html#a883ba7e39999c2c77786cca1b7926694">ADSR::applyEnvelopeToBuffer()</a>.</p>

</div>
</div>
<a id="af747c38dec0ab271b682949e646cd5c8" name="af747c38dec0ab271b682949e646cd5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af747c38dec0ab271b682949e646cd5c8">&#9670;&#160;</a></span>getWritePointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type * <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getWritePointer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channelNumber</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sampleIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a writeable pointer to one of the buffer's channels. </p>
<p>For speed, this doesn't check whether the channel number or index are out of range, so be careful when using it!</p>
<p>Note that if you're not planning on writing to the data, you should use getReadPointer instead.</p>
<p>This will mark the buffer as not cleared and the hasBeenCleared method will return false after this call. If you retain this write pointer and write some data to the buffer after calling its clear method, subsequent clear calls will do nothing. To avoid this either call this method each time you need to write data, or use the setNotClear method to force the internal cleared flag to false.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ada26c9e1814e37f3e2c8b1248e916bfe" title="Forces the internal cleared flag of the buffer to false.">setNotClear</a> </dd></dl>

</div>
</div>
<a id="a7f935a348a10bc8548a9046c745d10ee" name="a7f935a348a10bc8548a9046c745d10ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f935a348a10bc8548a9046c745d10ee">&#9670;&#160;</a></span>getArrayOfReadPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type *const  * <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getArrayOfReadPointers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of pointers to the channels in the buffer. </p>
<p>Don't modify any of the pointers that are returned, and bear in mind that these will become invalid if the buffer is resized. </p>

</div>
</div>
<a id="a68d9da790b234a055abab08f94fb7b29" name="a68d9da790b234a055abab08f94fb7b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d9da790b234a055abab08f94fb7b29">&#9670;&#160;</a></span>getArrayOfWritePointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type *const  * <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getArrayOfWritePointers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of pointers to the channels in the buffer. </p>
<p>Don't modify any of the pointers that are returned, and bear in mind that these will become invalid if the buffer is resized.</p>
<p>This will mark the buffer as not cleared and the hasBeenCleared method will return false after this call. If you retain this write pointer and write some data to the buffer after calling its clear method, subsequent clear calls will do nothing. To avoid this either call this method each time you need to write data, or use the setNotClear method to force the internal cleared flag to false.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ada26c9e1814e37f3e2c8b1248e916bfe" title="Forces the internal cleared flag of the buffer to false.">setNotClear</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classAudioProcessor.html#a733377c6d541c099dc5857be77cd1af1">AudioProcessor::getBusBuffer()</a>.</p>

</div>
</div>
<a id="a4434de94aa03d7db6d7ef06977ddf0ac" name="a4434de94aa03d7db6d7ef06977ddf0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4434de94aa03d7db6d7ef06977ddf0ac">&#9670;&#160;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::setSize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newNumChannels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newNumSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepExistingContent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clearExtraSpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>avoidReallocating</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the buffer's size or number of channels. </p>
<p>This can expand or contract the buffer's length, and add or remove channels.</p>
<p>Note that if keepExistingContent and avoidReallocating are both true, then it will only avoid reallocating if neither the channel count or length in samples increase.</p>
<p>If the required memory can't be allocated, this will throw a std::bad_alloc exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newNumChannels</td><td>the new number of channels. </td></tr>
    <tr><td class="paramname">newNumSamples</td><td>the new number of samples. </td></tr>
    <tr><td class="paramname">keepExistingContent</td><td>if this is true, it will try to preserve as much of the old data as it can in the new buffer. </td></tr>
    <tr><td class="paramname">clearExtraSpace</td><td>if this is true, then any extra channels or space that is allocated will also be cleared. If false, then this space is left uninitialised. </td></tr>
    <tr><td class="paramname">avoidReallocating</td><td>if this is true, then changing the buffer's size won't reduce the amount of memory that is currently allocated (but it will still increase it if the new size is bigger than the amount it currently has). If this is false, then a new allocation will be done so that the buffer uses the minimum amount of memory that it needs. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="#a88f19397f068366e13aa53a0b6f92913">AudioBuffer&lt; float &gt;::makeCopyOf()</a>, and <a class="el" href="#a2a0651a32b3b54c31807de1be5c70321">AudioBuffer&lt; float &gt;::operator=()</a>.</p>

</div>
</div>
<a id="ad37378c42606504558b6de1476a1cb1c" name="ad37378c42606504558b6de1476a1cb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37378c42606504558b6de1476a1cb1c">&#9670;&#160;</a></span>setDataToReferTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::setDataToReferTo </td>
          <td>(</td>
          <td class="paramtype">Type *const *</td>          <td class="paramname"><span class="paramname"><em>dataToReferTo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newNumChannels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newNumSamples</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this buffer point to a pre-allocated set of channel data arrays. </p>
<p>There's also a constructor that lets you specify arrays like this, but this lets you change the channels dynamically.</p>
<p>Note that if the buffer is resized or its number of channels is changed, it will re-allocate memory internally and copy the existing data to this new area, so it will then stop directly addressing this memory.</p>
<p>The hasBeenCleared method will return false after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToReferTo</td><td>a pre-allocated array containing pointers to the data for each channel that should be used by this buffer. The buffer will only refer to this memory, it won't try to delete it when the buffer is deleted or resized. </td></tr>
    <tr><td class="paramname">newNumChannels</td><td>the number of channels to use - this must correspond to the number of elements in the array passed in </td></tr>
    <tr><td class="paramname">newStartSample</td><td>the offset within the arrays at which the data begins </td></tr>
    <tr><td class="paramname">newNumSamples</td><td>the number of samples to use - this must correspond to the size of the arrays passed in </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="#a0aff1f124d400ca44fde84c6fe3da2f9">AudioBuffer&lt; float &gt;::setDataToReferTo()</a>.</p>

</div>
</div>
<a id="a0aff1f124d400ca44fde84c6fe3da2f9" name="a0aff1f124d400ca44fde84c6fe3da2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aff1f124d400ca44fde84c6fe3da2f9">&#9670;&#160;</a></span>setDataToReferTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::setDataToReferTo </td>
          <td>(</td>
          <td class="paramtype">Type *const *</td>          <td class="paramname"><span class="paramname"><em>dataToReferTo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newNumChannels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newNumSamples</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this buffer point to a pre-allocated set of channel data arrays. </p>
<p>There's also a constructor that lets you specify arrays like this, but this lets you change the channels dynamically.</p>
<p>Note that if the buffer is resized or its number of channels is changed, it will re-allocate memory internally and copy the existing data to this new area, so it will then stop directly addressing this memory.</p>
<p>The hasBeenCleared method will return false after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToReferTo</td><td>a pre-allocated array containing pointers to the data for each channel that should be used by this buffer. The buffer will only refer to this memory, it won't try to delete it when the buffer is deleted or resized. </td></tr>
    <tr><td class="paramname">newNumChannels</td><td>the number of channels to use - this must correspond to the number of elements in the array passed in </td></tr>
    <tr><td class="paramname">newNumSamples</td><td>the number of samples to use - this must correspond to the size of the arrays passed in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88f19397f068366e13aa53a0b6f92913" name="a88f19397f068366e13aa53a0b6f92913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f19397f068366e13aa53a0b6f92913">&#9670;&#160;</a></span>makeCopyOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<div class="memtemplate">
template&lt;typename OtherType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::makeCopyOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; OtherType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>avoidReallocating</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this buffer to match the given one, and copies all of its content across. </p>
<p>The source buffer can contain a different floating point type, so this can be used to convert between 32 and 64 bit float buffer types.</p>
<p>The hasBeenCleared method will return false after this call if the other buffer contains data. </p>

</div>
</div>
<a id="a7dcadc4a02b048ae99166b5b306e552a" name="a7dcadc4a02b048ae99166b5b306e552a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcadc4a02b048ae99166b5b306e552a">&#9670;&#160;</a></span>clear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all the samples in all channels and marks the buffer as cleared. </p>
<p>This method will do nothing if the buffer has been marked as cleared (i.e. the hasBeenCleared method returns true.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acc922971fe78c785110e46d30c210d9c" title="Returns true if the buffer has been entirely cleared.">hasBeenCleared</a>, <a class="el" href="#ada26c9e1814e37f3e2c8b1248e916bfe" title="Forces the internal cleared flag of the buffer to false.">setNotClear</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classADSR.html#a883ba7e39999c2c77786cca1b7926694">ADSR::applyEnvelopeToBuffer()</a>, <a class="el" href="#ad773e1b58a9ec886349456b5f1a926d5">AudioBuffer&lt; float &gt;::AudioBuffer()</a>, <a class="el" href="#a88f19397f068366e13aa53a0b6f92913">AudioBuffer&lt; float &gt;::makeCopyOf()</a>, and <a class="el" href="#a2a0651a32b3b54c31807de1be5c70321">AudioBuffer&lt; float &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a97d34c7bc5dfd19fa9450d112972422b" name="a97d34c7bc5dfd19fa9450d112972422b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d34c7bc5dfd19fa9450d112972422b">&#9670;&#160;</a></span>clear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a specified region of all the channels. </p>
<p>This will mark the buffer as cleared if the entire buffer contents are cleared.</p>
<p>For speed, this doesn't check whether the channel and sample number are in-range, so be careful!</p>
<p>This method will do nothing if the buffer has been marked as cleared (i.e. the hasBeenCleared method returns true.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acc922971fe78c785110e46d30c210d9c" title="Returns true if the buffer has been entirely cleared.">hasBeenCleared</a>, <a class="el" href="#ada26c9e1814e37f3e2c8b1248e916bfe" title="Forces the internal cleared flag of the buffer to false.">setNotClear</a> </dd></dl>

</div>
</div>
<a id="a3c0cc34d68718a0f24bcea846cf92f61" name="a3c0cc34d68718a0f24bcea846cf92f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0cc34d68718a0f24bcea846cf92f61">&#9670;&#160;</a></span>clear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a specified region of just one channel. </p>
<p>For speed, this doesn't check whether the channel and sample number are in-range, so be careful!</p>
<p>This method will do nothing if the buffer has been marked as cleared (i.e. the hasBeenCleared method returns true.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acc922971fe78c785110e46d30c210d9c" title="Returns true if the buffer has been entirely cleared.">hasBeenCleared</a>, <a class="el" href="#ada26c9e1814e37f3e2c8b1248e916bfe" title="Forces the internal cleared flag of the buffer to false.">setNotClear</a> </dd></dl>

</div>
</div>
<a id="acc922971fe78c785110e46d30c210d9c" name="acc922971fe78c785110e46d30c210d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc922971fe78c785110e46d30c210d9c">&#9670;&#160;</a></span>hasBeenCleared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::hasBeenCleared </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the buffer has been entirely cleared. </p>
<p>Note that this does not actually measure the contents of the buffer - it simply returns a flag that is set when the buffer is cleared, and which is reset whenever functions like getWritePointer are invoked. That means the method is quick, but it may return false negatives when in fact the buffer is still empty. </p>

<p class="reference">Referenced by <a class="el" href="#a88f19397f068366e13aa53a0b6f92913">AudioBuffer&lt; float &gt;::makeCopyOf()</a>.</p>

</div>
</div>
<a id="ada26c9e1814e37f3e2c8b1248e916bfe" name="ada26c9e1814e37f3e2c8b1248e916bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada26c9e1814e37f3e2c8b1248e916bfe">&#9670;&#160;</a></span>setNotClear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::setNotClear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the internal cleared flag of the buffer to false. </p>
<p>This may be useful in the case where you are holding on to a write pointer and call the clear method before writing some data. You can then use this method to mark the buffer as containing data so that subsequent clear calls will succeed. However a better solution is to call getWritePointer each time you need to write data. </p>

</div>
</div>
<a id="afa9b351b6e3cba941cf7c44860851991" name="afa9b351b6e3cba941cf7c44860851991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9b351b6e3cba941cf7c44860851991">&#9670;&#160;</a></span>getSample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getSample </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sampleIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sample from the buffer. </p>
<p>The channel and index are not checked - they are expected to be in-range. If not, an assertion will be thrown, but in a release build, you're into 'undefined behaviour' territory. </p>

</div>
</div>
<a id="a8aba905085e81fefb8ef4c8589c9e7d8" name="a8aba905085e81fefb8ef4c8589c9e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aba905085e81fefb8ef4c8589c9e7d8">&#9670;&#160;</a></span>setSample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::setSample </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a sample in the buffer. </p>
<p>The channel and index are not checked - they are expected to be in-range. If not, an assertion will be thrown, but in a release build, you're into 'undefined behaviour' territory.</p>
<p>The hasBeenCleared method will return false after this call. </p>

</div>
</div>
<a id="ab46e9ad400252255daa1086b354454b8" name="ab46e9ad400252255daa1086b354454b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46e9ad400252255daa1086b354454b8">&#9670;&#160;</a></span>addSample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::addSample </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>valueToAdd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a value to a sample in the buffer. </p>
<p>The channel and index are not checked - they are expected to be in-range. If not, an assertion will be thrown, but in a release build, you're into 'undefined behaviour' territory.</p>
<p>The hasBeenCleared method will return false after this call. </p>

</div>
</div>
<a id="a9ffc61d339e455d4bddc7cf055a63ee3" name="a9ffc61d339e455d4bddc7cf055a63ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffc61d339e455d4bddc7cf055a63ee3">&#9670;&#160;</a></span>applyGain() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::applyGain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>gain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a gain multiple to a region of one channel. </p>
<p>For speed, this doesn't check whether the channel and sample number are in-range, so be careful! </p>

<p class="reference">Referenced by <a class="el" href="classADSR.html#a883ba7e39999c2c77786cca1b7926694">ADSR::applyEnvelopeToBuffer()</a>, and <a class="el" href="#a0c4794d6dbfd6d0c20d041fffc9939af">AudioBuffer&lt; float &gt;::applyGain()</a>.</p>

</div>
</div>
<a id="a25c9a05ff546379ba7bed697e616bfb3" name="a25c9a05ff546379ba7bed697e616bfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c9a05ff546379ba7bed697e616bfb3">&#9670;&#160;</a></span>applyGain() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::applyGain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>gain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a gain multiple to a region of all the channels. </p>
<p>For speed, this doesn't check whether the sample numbers are in-range, so be careful! </p>

</div>
</div>
<a id="a0c4794d6dbfd6d0c20d041fffc9939af" name="a0c4794d6dbfd6d0c20d041fffc9939af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4794d6dbfd6d0c20d041fffc9939af">&#9670;&#160;</a></span>applyGain() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::applyGain </td>
          <td>(</td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>gain</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a gain multiple to all the audio data. </p>

</div>
</div>
<a id="ab0542e5b626b36087f0054e795695682" name="ab0542e5b626b36087f0054e795695682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0542e5b626b36087f0054e795695682">&#9670;&#160;</a></span>applyGainRamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::applyGainRamp </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>startGain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>endGain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a range of gains to a region of a channel. </p>
<p>The gain that is applied to each sample will vary from startGain on the first sample to endGain on the last Sample, so it can be used to do basic fades.</p>
<p>For speed, this doesn't check whether the sample numbers are in-range, so be careful! </p>

</div>
</div>
<a id="af5cde88e72248367626419733fc58fc2" name="af5cde88e72248367626419733fc58fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cde88e72248367626419733fc58fc2">&#9670;&#160;</a></span>applyGainRamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::applyGainRamp </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>startGain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>endGain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a range of gains to a region of all channels. </p>
<p>The gain that is applied to each sample will vary from startGain on the first sample to endGain on the last Sample, so it can be used to do basic fades.</p>
<p>For speed, this doesn't check whether the sample numbers are in-range, so be careful! </p>

</div>
</div>
<a id="abb2b03021cca3f0382d602d0b9755a08" name="abb2b03021cca3f0382d602d0b9755a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2b03021cca3f0382d602d0b9755a08">&#9670;&#160;</a></span>addFrom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::addFrom </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sourceChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sourceStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>gainToApplyToSource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Type&#160;(1)</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds samples from another buffer to this one. </p>
<p>The hasBeenCleared method will return false after this call if samples have been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destChannel</td><td>the channel within this buffer to add the samples to </td></tr>
    <tr><td class="paramname">destStartSample</td><td>the start sample within this buffer's channel </td></tr>
    <tr><td class="paramname">source</td><td>the source buffer to add from </td></tr>
    <tr><td class="paramname">sourceChannel</td><td>the channel within the source buffer to read from </td></tr>
    <tr><td class="paramname">sourceStartSample</td><td>the offset within the source buffer's channel to start reading samples from </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to process </td></tr>
    <tr><td class="paramname">gainToApplyToSource</td><td>an optional gain to apply to the source samples before they are added to this buffer's samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9ec751bfa23564c011bf3940ca17b743" title="Copies samples from another buffer to this one.">copyFrom</a> </dd></dl>

</div>
</div>
<a id="ae4ad8d6eb40abc86e9940ae90c79c380" name="ae4ad8d6eb40abc86e9940ae90c79c380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ad8d6eb40abc86e9940ae90c79c380">&#9670;&#160;</a></span>addFrom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::addFrom </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>gainToApplyToSource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Type&#160;(1)</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds samples from an array of floats to one of the channels. </p>
<p>The hasBeenCleared method will return false after this call if samples have been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destChannel</td><td>the channel within this buffer to add the samples to </td></tr>
    <tr><td class="paramname">destStartSample</td><td>the start sample within this buffer's channel </td></tr>
    <tr><td class="paramname">source</td><td>the source data to use </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to process </td></tr>
    <tr><td class="paramname">gainToApplyToSource</td><td>an optional gain to apply to the source samples before they are added to this buffer's samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9ec751bfa23564c011bf3940ca17b743" title="Copies samples from another buffer to this one.">copyFrom</a> </dd></dl>

</div>
</div>
<a id="a1853da41f2a3d87fa6291a2bf2adca05" name="a1853da41f2a3d87fa6291a2bf2adca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1853da41f2a3d87fa6291a2bf2adca05">&#9670;&#160;</a></span>addFromWithRamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::addFromWithRamp </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>startGain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>endGain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds samples from an array of floats, applying a gain ramp to them. </p>
<p>The hasBeenCleared method will return false after this call if samples have been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destChannel</td><td>the channel within this buffer to add the samples to </td></tr>
    <tr><td class="paramname">destStartSample</td><td>the start sample within this buffer's channel </td></tr>
    <tr><td class="paramname">source</td><td>the source data to use </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to process </td></tr>
    <tr><td class="paramname">startGain</td><td>the gain to apply to the first sample (this is multiplied with the source samples before they are added to this buffer) </td></tr>
    <tr><td class="paramname">endGain</td><td>The gain that would apply to the sample after the final sample. The gain that applies to the final sample is (numSamples - 1) / numSamples * (endGain - startGain). This ensures a continuous ramp when supplying the same value in endGain and startGain in subsequent blocks. The gain is linearly interpolated between the first and last samples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ec751bfa23564c011bf3940ca17b743" name="a9ec751bfa23564c011bf3940ca17b743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec751bfa23564c011bf3940ca17b743">&#9670;&#160;</a></span>copyFrom() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sourceChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sourceStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies samples from another buffer to this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destChannel</td><td>the channel within this buffer to copy the samples to </td></tr>
    <tr><td class="paramname">destStartSample</td><td>the start sample within this buffer's channel </td></tr>
    <tr><td class="paramname">source</td><td>the source buffer to read from </td></tr>
    <tr><td class="paramname">sourceChannel</td><td>the channel within the source buffer to read from </td></tr>
    <tr><td class="paramname">sourceStartSample</td><td>the offset within the source buffer's channel to start reading samples from </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abb2b03021cca3f0382d602d0b9755a08" title="Adds samples from another buffer to this one.">addFrom</a> </dd></dl>

</div>
</div>
<a id="a80d6c874d56ebfbf3c0aca2d2b8c4ab7" name="a80d6c874d56ebfbf3c0aca2d2b8c4ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d6c874d56ebfbf3c0aca2d2b8c4ab7">&#9670;&#160;</a></span>copyFrom() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies samples from an array of floats into one of the channels. </p>
<p>The hasBeenCleared method will return false after this call if samples have been copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destChannel</td><td>the channel within this buffer to copy the samples to </td></tr>
    <tr><td class="paramname">destStartSample</td><td>the start sample within this buffer's channel </td></tr>
    <tr><td class="paramname">source</td><td>the source buffer to read from </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abb2b03021cca3f0382d602d0b9755a08" title="Adds samples from another buffer to this one.">addFrom</a> </dd></dl>

</div>
</div>
<a id="a2684ecc739be23105f3a2f0605e2a928" name="a2684ecc739be23105f3a2f0605e2a928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2684ecc739be23105f3a2f0605e2a928">&#9670;&#160;</a></span>copyFrom() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>gain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies samples from an array of floats into one of the channels, applying a gain to it. </p>
<p>The hasBeenCleared method will return false after this call if samples have been copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destChannel</td><td>the channel within this buffer to copy the samples to </td></tr>
    <tr><td class="paramname">destStartSample</td><td>the start sample within this buffer's channel </td></tr>
    <tr><td class="paramname">source</td><td>the source buffer to read from </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to process </td></tr>
    <tr><td class="paramname">gain</td><td>the gain to apply</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abb2b03021cca3f0382d602d0b9755a08" title="Adds samples from another buffer to this one.">addFrom</a> </dd></dl>

</div>
</div>
<a id="ae1cff4483f4022ed49dc91eda31098c9" name="ae1cff4483f4022ed49dc91eda31098c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cff4483f4022ed49dc91eda31098c9">&#9670;&#160;</a></span>copyFromWithRamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::copyFromWithRamp </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destChannel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destStartSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>startGain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type</td>          <td class="paramname"><span class="paramname"><em>endGain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies samples from an array of floats into one of the channels, applying a gain ramp. </p>
<p>The hasBeenCleared method will return false after this call if samples have been copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destChannel</td><td>the channel within this buffer to copy the samples to </td></tr>
    <tr><td class="paramname">destStartSample</td><td>the start sample within this buffer's channel </td></tr>
    <tr><td class="paramname">source</td><td>the source buffer to read from </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to process </td></tr>
    <tr><td class="paramname">startGain</td><td>the gain to apply to the first sample (this is multiplied with the source samples before they are copied to this buffer) </td></tr>
    <tr><td class="paramname">endGain</td><td>The gain that would apply to the sample after the final sample. The gain that applies to the final sample is (numSamples - 1) / numSamples * (endGain - startGain). This ensures a continuous ramp when supplying the same value in endGain and startGain in subsequent blocks. The gain is linearly interpolated between the first and last samples.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abb2b03021cca3f0382d602d0b9755a08" title="Adds samples from another buffer to this one.">addFrom</a> </dd></dl>

</div>
</div>
<a id="a7f804a29a233fb110901f61e0fac071a" name="a7f804a29a233fb110901f61e0fac071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f804a29a233fb110901f61e0fac071a">&#9670;&#160;</a></span>findMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; Type &gt; <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::findMinMax </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classRange.html" title="A general-purpose range object, that simply represents any linear range with a start and end point.">Range</a> indicating the lowest and highest sample values in a given section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to read from </td></tr>
    <tr><td class="paramname">startSample</td><td>the start sample within the channel </td></tr>
    <tr><td class="paramname">numSamples</td><td>the number of samples to check </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="#af0f0099350d92091c24e8b14b149328e">AudioBuffer&lt; float &gt;::getMagnitude()</a>.</p>

</div>
</div>
<a id="af0f0099350d92091c24e8b14b149328e" name="af0f0099350d92091c24e8b14b149328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f0099350d92091c24e8b14b149328e">&#9670;&#160;</a></span>getMagnitude() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getMagnitude </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the highest absolute sample value within a region of a channel. </p>

</div>
</div>
<a id="afdd67f1761872b093a2065dc8f9b3c9e" name="afdd67f1761872b093a2065dc8f9b3c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd67f1761872b093a2065dc8f9b3c9e">&#9670;&#160;</a></span>getMagnitude() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getMagnitude </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the highest absolute sample value within a region on all channels. </p>

</div>
</div>
<a id="a7e2c4235fa4a6da3aca73f17b46704ac" name="a7e2c4235fa4a6da3aca73f17b46704ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2c4235fa4a6da3aca73f17b46704ac">&#9670;&#160;</a></span>getRMSLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::getRMSLevel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the root mean squared level for a region of a channel. </p>

</div>
</div>
<a id="a41cbf05e4d7054e02d5844b09a8eceb5" name="a41cbf05e4d7054e02d5844b09a8eceb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cbf05e4d7054e02d5844b09a8eceb5">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::reverse </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>channel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses a part of a channel. </p>

</div>
</div>
<a id="a842674c6e6bd70f27fcbdef7cc76e283" name="a842674c6e6bd70f27fcbdef7cc76e283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842674c6e6bd70f27fcbdef7cc76e283">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAudioBuffer.html">AudioBuffer</a>&lt; Type &gt;::reverse </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startSample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses a part of the buffer. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
