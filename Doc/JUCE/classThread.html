<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JUCE: Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- main-nav -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classThread-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Thread Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__juce__core.html">juce_core</a> &raquo; <a class="el" href="group__juce__core-threads.html">threads</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Encapsulates a thread.  
 <a href="#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Thread:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classThread__inherit__graph.svg" width="318" height="323"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Listener" id="r_Listener"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThread_1_1Listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to receive callbacks for thread exit calls.  <a href="classThread_1_1Listener.html#details">More...</a><br /></td></tr>
<tr class="memitem:RealtimeOptions" id="r_RealtimeOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread_1_1RealtimeOptions.html">RealtimeOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A selection of options available when creating realtime threads.  <a href="structThread_1_1RealtimeOptions.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aae22d3d18dffe1adbbc2baf564e0383b" id="r_aae22d3d18dffe1adbbc2baf564e0383b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a> { <br />
&#160;&#160;<a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383bade3706d29d1ad44cd7fdb9a5696491e2">highest</a> = 2
, <a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383ba8d966b2253a917086c8604959e152243">high</a> = 1
, <a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383bafea087517c26fadd409bd4b9dc642555">normal</a> = 0
, <a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383ba53cced8d281a1a0ace3cb6594daaa4f7">low</a> = -1
, <br />
&#160;&#160;<a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383bad229bbf31eaeebc7c88897732d8b932d">background</a> = -2
<br />
 }</td></tr>
<tr class="memdesc:aae22d3d18dffe1adbbc2baf564e0383b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different runtime priorities of non-realtime threads.  <a href="#aae22d3d18dffe1adbbc2baf564e0383b">More...</a><br /></td></tr>
<tr class="memitem:adcf5808753df4373be08d38938880f65" id="r_adcf5808753df4373be08d38938880f65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf5808753df4373be08d38938880f65">ThreadID</a> = void*</td></tr>
<tr class="memdesc:adcf5808753df4373be08d38938880f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value type used for thread IDs.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4da8a17f4d2a9ae7625a31ee9c33a4e5" id="r_a4da8a17f4d2a9ae7625a31ee9c33a4e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4da8a17f4d2a9ae7625a31ee9c33a4e5">Thread</a> (const <a class="el" href="classString.html">String</a> &amp;threadName, size_t threadStackSize=<a class="el" href="#a8f524d41ddb44b0cc43d4bb39eabbc81">osDefaultStackSize</a>)</td></tr>
<tr class="memdesc:a4da8a17f4d2a9ae7625a31ee9c33a4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread.  <br /></td></tr>
<tr class="memitem:a026b23628e1727050e864e00489c0baf" id="r_a026b23628e1727050e864e00489c0baf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a026b23628e1727050e864e00489c0baf">~Thread</a> ()</td></tr>
<tr class="memdesc:a026b23628e1727050e864e00489c0baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="memitem:aae90dfabab3e1776cf01a26e7ee3a620" id="r_aae90dfabab3e1776cf01a26e7ee3a620"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae90dfabab3e1776cf01a26e7ee3a620">run</a> ()=0</td></tr>
<tr class="memdesc:aae90dfabab3e1776cf01a26e7ee3a620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be implemented to perform the thread's actual code.  <br /></td></tr>
<tr class="memitem:a2951d9e21e5f3c2415a8cae68ff7f3e4" id="r_a2951d9e21e5f3c2415a8cae68ff7f3e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4">startThread</a> ()</td></tr>
<tr class="memdesc:a2951d9e21e5f3c2415a8cae68ff7f3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to start a new thread with default ('<a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383bafea087517c26fadd409bd4b9dc642555" title="The OS default.">Priority::normal</a>') priority.  <br /></td></tr>
<tr class="memitem:a1cbd05a5c1e23417fbcbf5b96f7a433e" id="r_a1cbd05a5c1e23417fbcbf5b96f7a433e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cbd05a5c1e23417fbcbf5b96f7a433e">startThread</a> (<a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a> newPriority)</td></tr>
<tr class="memdesc:a1cbd05a5c1e23417fbcbf5b96f7a433e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to start a new thread with a given priority.  <br /></td></tr>
<tr class="memitem:a17c0849ec96a936beebc645ce0708faf" id="r_a17c0849ec96a936beebc645ce0708faf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17c0849ec96a936beebc645ce0708faf">startRealtimeThread</a> (const <a class="el" href="structThread_1_1RealtimeOptions.html">RealtimeOptions</a> &amp;options)</td></tr>
<tr class="memdesc:a17c0849ec96a936beebc645ce0708faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the thread with realtime performance characteristics on platforms that support it.  <br /></td></tr>
<tr class="memitem:a18583d51411d6a34c59b63f0adff4697" id="r_a18583d51411d6a34c59b63f0adff4697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18583d51411d6a34c59b63f0adff4697">stopThread</a> (int timeOutMilliseconds)</td></tr>
<tr class="memdesc:a18583d51411d6a34c59b63f0adff4697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to stop the thread running.  <br /></td></tr>
<tr class="memitem:afc4e7957f1c3a3f98218324c0fdc3beb" id="r_afc4e7957f1c3a3f98218324c0fdc3beb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc4e7957f1c3a3f98218324c0fdc3beb">isThreadRunning</a> () const</td></tr>
<tr class="memdesc:afc4e7957f1c3a3f98218324c0fdc3beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the thread is currently active.  <br /></td></tr>
<tr class="memitem:affe168e27c6ee50b0d10522810772268" id="r_affe168e27c6ee50b0d10522810772268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affe168e27c6ee50b0d10522810772268">signalThreadShouldExit</a> ()</td></tr>
<tr class="memdesc:affe168e27c6ee50b0d10522810772268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag to tell the thread it should stop.  <br /></td></tr>
<tr class="memitem:ab89b68d53514e0b3978460aab3202fd7" id="r_ab89b68d53514e0b3978460aab3202fd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab89b68d53514e0b3978460aab3202fd7">threadShouldExit</a> () const</td></tr>
<tr class="memdesc:ab89b68d53514e0b3978460aab3202fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the thread has been told to stop running.  <br /></td></tr>
<tr class="memitem:ad9b6494f25d5d8eb07ed6fc96178eac5" id="r_ad9b6494f25d5d8eb07ed6fc96178eac5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9b6494f25d5d8eb07ed6fc96178eac5">waitForThreadToExit</a> (int timeOutMilliseconds) const</td></tr>
<tr class="memdesc:ad9b6494f25d5d8eb07ed6fc96178eac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the thread to stop.  <br /></td></tr>
<tr class="memitem:aad3e509718eb01ac3c61418f8b350c2b" id="r_aad3e509718eb01ac3c61418f8b350c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad3e509718eb01ac3c61418f8b350c2b">addListener</a> (<a class="el" href="classThread_1_1Listener.html">Listener</a> *)</td></tr>
<tr class="memdesc:aad3e509718eb01ac3c61418f8b350c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a listener to this thread which will receive a callback when signalThreadShouldExit was called on this thread.  <br /></td></tr>
<tr class="memitem:abec45c6a6d42076b256bd48d57817778" id="r_abec45c6a6d42076b256bd48d57817778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abec45c6a6d42076b256bd48d57817778">removeListener</a> (<a class="el" href="classThread_1_1Listener.html">Listener</a> *)</td></tr>
<tr class="memdesc:abec45c6a6d42076b256bd48d57817778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a listener added with addListener.  <br /></td></tr>
<tr class="memitem:aaaac0a1f90490d701f37da4605a84068" id="r_aaaac0a1f90490d701f37da4605a84068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaac0a1f90490d701f37da4605a84068">isRealtime</a> () const</td></tr>
<tr class="memdesc:aaaac0a1f90490d701f37da4605a84068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a> represents a realtime thread.  <br /></td></tr>
<tr class="memitem:a614605563fceeac6f03d507bc35bdce4" id="r_a614605563fceeac6f03d507bc35bdce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a614605563fceeac6f03d507bc35bdce4">setAffinityMask</a> (<a class="el" href="group__juce__core-maths.html#gabd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> affinityMask)</td></tr>
<tr class="memdesc:a614605563fceeac6f03d507bc35bdce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the affinity mask for the thread.  <br /></td></tr>
<tr class="memitem:a7b70b0d7036575c101e779d4a67fb99d" id="r_a7b70b0d7036575c101e779d4a67fb99d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b70b0d7036575c101e779d4a67fb99d">wait</a> (double timeOutMilliseconds) const</td></tr>
<tr class="memdesc:a7b70b0d7036575c101e779d4a67fb99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the execution of this thread until either the specified timeout period has elapsed, or another thread calls the <a class="el" href="#a0b4d5a1ffaa35cc13f323a0524012a2b" title="Wakes up the thread.">notify()</a> method to wake it up.  <br /></td></tr>
<tr class="memitem:a0b4d5a1ffaa35cc13f323a0524012a2b" id="r_a0b4d5a1ffaa35cc13f323a0524012a2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b4d5a1ffaa35cc13f323a0524012a2b">notify</a> () const</td></tr>
<tr class="memdesc:a0b4d5a1ffaa35cc13f323a0524012a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up the thread.  <br /></td></tr>
<tr class="memitem:a39ca822734b9b20ab32eeba774c9a803" id="r_a39ca822734b9b20ab32eeba774c9a803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adcf5808753df4373be08d38938880f65">ThreadID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ca822734b9b20ab32eeba774c9a803">getThreadId</a> () const noexcept</td></tr>
<tr class="memdesc:a39ca822734b9b20ab32eeba774c9a803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this thread.  <br /></td></tr>
<tr class="memitem:a84eb62c0e47873d28c4aeda0281d6359" id="r_a84eb62c0e47873d28c4aeda0281d6359"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classString.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84eb62c0e47873d28c4aeda0281d6359">getThreadName</a> () const noexcept</td></tr>
<tr class="memdesc:a84eb62c0e47873d28c4aeda0281d6359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the thread.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0083c4d5a99074e3a44e01584b98495f" id="r_a0083c4d5a99074e3a44e01584b98495f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0083c4d5a99074e3a44e01584b98495f">launch</a> (std::function&lt; void()&gt; functionToRun)</td></tr>
<tr class="memdesc:a0083c4d5a99074e3a44e01584b98495f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a lambda or function on its own thread with the default priority.  <br /></td></tr>
<tr class="memitem:a6ab3f81bc885603bcf7893feaf2ca083" id="r_a6ab3f81bc885603bcf7893feaf2ca083"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab3f81bc885603bcf7893feaf2ca083">launch</a> (<a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a> priority, std::function&lt; void()&gt; functionToRun)</td></tr>
<tr class="memdesc:a6ab3f81bc885603bcf7893feaf2ca083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a lambda or function on its own thread with a custom priority.  <br /></td></tr>
<tr class="memitem:ac92778089556fd0b5ab9c31557669ce8" id="r_ac92778089556fd0b5ab9c31557669ce8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac92778089556fd0b5ab9c31557669ce8">currentThreadShouldExit</a> ()</td></tr>
<tr class="memdesc:ac92778089556fd0b5ab9c31557669ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the current thread has been told to stop running.  <br /></td></tr>
<tr class="memitem:ac21eb5ae8c32bc2ecacba904f3411802" id="r_ac21eb5ae8c32bc2ecacba904f3411802"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac21eb5ae8c32bc2ecacba904f3411802">setCurrentThreadAffinityMask</a> (<a class="el" href="group__juce__core-maths.html#gabd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> affinityMask)</td></tr>
<tr class="memdesc:ac21eb5ae8c32bc2ecacba904f3411802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the affinity mask for the caller thread.  <br /></td></tr>
<tr class="memitem:a4ee1ddee32aa82ac90bc567cb7427926" id="r_a4ee1ddee32aa82ac90bc567cb7427926"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ee1ddee32aa82ac90bc567cb7427926">sleep</a> (int milliseconds)</td></tr>
<tr class="memdesc:a4ee1ddee32aa82ac90bc567cb7427926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the execution of the current thread until the specified timeout period has elapsed (note that this may not be exact).  <br /></td></tr>
<tr class="memitem:aaf47a344b3b715e49ffcbc6119c72cdc" id="r_aaf47a344b3b715e49ffcbc6119c72cdc"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf47a344b3b715e49ffcbc6119c72cdc">yield</a> ()</td></tr>
<tr class="memdesc:aaf47a344b3b715e49ffcbc6119c72cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the current thread's CPU time-slot and allows a new thread to run.  <br /></td></tr>
<tr class="memitem:abd4762b20144186ffc28280cedd224e9" id="r_abd4762b20144186ffc28280cedd224e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#adcf5808753df4373be08d38938880f65">ThreadID</a> <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd4762b20144186ffc28280cedd224e9">getCurrentThreadId</a> ()</td></tr>
<tr class="memdesc:abd4762b20144186ffc28280cedd224e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an id that identifies the caller thread.  <br /></td></tr>
<tr class="memitem:a94e1d4eaacb9cca70ac0e396278560fa" id="r_a94e1d4eaacb9cca70ac0e396278560fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classThread.html">Thread</a> *<a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e1d4eaacb9cca70ac0e396278560fa">getCurrentThread</a> ()</td></tr>
<tr class="memdesc:a94e1d4eaacb9cca70ac0e396278560fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the thread object that is currently running.  <br /></td></tr>
<tr class="memitem:a8ba2a683ea8111c08db83092360b7226" id="r_a8ba2a683ea8111c08db83092360b7226"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba2a683ea8111c08db83092360b7226">setCurrentThreadName</a> (const <a class="el" href="classString.html">String</a> &amp;newThreadName)</td></tr>
<tr class="memdesc:a8ba2a683ea8111c08db83092360b7226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name of the caller thread.  <br /></td></tr>
<tr class="memitem:a414755620d63dbeada96b1de5309c778" id="r_a414755620d63dbeada96b1de5309c778"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a414755620d63dbeada96b1de5309c778">initialiseJUCE</a> (void *jniEnv, void *jContext)</td></tr>
<tr class="memdesc:a414755620d63dbeada96b1de5309c778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the JUCE subsystem for projects not created by the Projucer.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8f524d41ddb44b0cc43d4bb39eabbc81" id="r_a8f524d41ddb44b0cc43d4bb39eabbc81"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f524d41ddb44b0cc43d4bb39eabbc81">osDefaultStackSize</a> { 0 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a76828ab40831e791f5246cb15003ace8" id="r_a76828ab40831e791f5246cb15003ace8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76828ab40831e791f5246cb15003ace8">getPriority</a> () const</td></tr>
<tr class="memdesc:a76828ab40831e791f5246cb15003ace8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current priority of this thread.  <br /></td></tr>
<tr class="memitem:a0aa09f7a5eb11b7cbf821c9b72110950" id="r_a0aa09f7a5eb11b7cbf821c9b72110950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aa09f7a5eb11b7cbf821c9b72110950">setPriority</a> (<a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a> newPriority)</td></tr>
<tr class="memdesc:a0aa09f7a5eb11b7cbf821c9b72110950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to set the priority for this thread.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a thread. </p>
<p>Subclasses derive from <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a> and implement the <a class="el" href="#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code.">run()</a> method, in which they do their business. The thread can then be started with the <a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4" title="Attempts to start a new thread with default (&#39;Priority::normal&#39;) priority.">startThread()</a> or <a class="el" href="#a17c0849ec96a936beebc645ce0708faf" title="Starts the thread with realtime performance characteristics on platforms that support it.">startRealtimeThread()</a> methods and controlled with various other methods.</p>
<p>This class also contains some thread-related static methods, such as <a class="el" href="#a4ee1ddee32aa82ac90bc567cb7427926" title="Suspends the execution of the current thread until the specified timeout period has elapsed (note tha...">sleep()</a>, <a class="el" href="#aaf47a344b3b715e49ffcbc6119c72cdc" title="Yields the current thread&#39;s CPU time-slot and allows a new thread to run.">yield()</a>, <a class="el" href="#abd4762b20144186ffc28280cedd224e9" title="Returns an id that identifies the caller thread.">getCurrentThreadId()</a> etc.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCriticalSection.html" title="A re-entrant mutex.">CriticalSection</a>, <a class="el" href="classWaitableEvent.html" title="Allows threads to wait for events triggered by other threads.">WaitableEvent</a>, <a class="el" href="classProcess.html" title="Represents the current executable&#39;s process.">Process</a>, <a class="el" href="classThreadWithProgressWindow.html" title="A thread that automatically pops up a modal dialog box with a progress bar and cancel button while it...">ThreadWithProgressWindow</a>, <a class="el" href="classMessageManagerLock.html" title="Used to make sure that the calling thread has exclusive access to the message loop.">MessageManagerLock</a> </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="adcf5808753df4373be08d38938880f65" name="adcf5808753df4373be08d38938880f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf5808753df4373be08d38938880f65">&#9670;&#160;</a></span>ThreadID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adcf5808753df4373be08d38938880f65">Thread::ThreadID</a> = void*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value type used for thread IDs. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abd4762b20144186ffc28280cedd224e9" title="Returns an id that identifies the caller thread.">getCurrentThreadId()</a>, <a class="el" href="#a39ca822734b9b20ab32eeba774c9a803" title="Returns the ID of this thread.">getThreadId()</a> </dd></dl>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="aae22d3d18dffe1adbbc2baf564e0383b" name="aae22d3d18dffe1adbbc2baf564e0383b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae22d3d18dffe1adbbc2baf564e0383b">&#9670;&#160;</a></span>Priority</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Thread::Priority</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different runtime priorities of non-realtime threads. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4" title="Attempts to start a new thread with default (&#39;Priority::normal&#39;) priority.">startThread</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aae22d3d18dffe1adbbc2baf564e0383bade3706d29d1ad44cd7fdb9a5696491e2" name="aae22d3d18dffe1adbbc2baf564e0383bade3706d29d1ad44cd7fdb9a5696491e2"></a>highest&#160;</td><td class="fielddoc"><p>The highest possible priority that isn't a dedicated realtime thread. </p>
</td></tr>
<tr><td class="fieldname"><a id="aae22d3d18dffe1adbbc2baf564e0383ba8d966b2253a917086c8604959e152243" name="aae22d3d18dffe1adbbc2baf564e0383ba8d966b2253a917086c8604959e152243"></a>high&#160;</td><td class="fielddoc"><p>Makes use of performance cores and higher clocks. </p>
</td></tr>
<tr><td class="fieldname"><a id="aae22d3d18dffe1adbbc2baf564e0383bafea087517c26fadd409bd4b9dc642555" name="aae22d3d18dffe1adbbc2baf564e0383bafea087517c26fadd409bd4b9dc642555"></a>normal&#160;</td><td class="fielddoc"><p>The OS default. </p>
<p>It will balance out across all cores. </p>
</td></tr>
<tr><td class="fieldname"><a id="aae22d3d18dffe1adbbc2baf564e0383ba53cced8d281a1a0ace3cb6594daaa4f7" name="aae22d3d18dffe1adbbc2baf564e0383ba53cced8d281a1a0ace3cb6594daaa4f7"></a>low&#160;</td><td class="fielddoc"><p>Uses efficiency cores when possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="aae22d3d18dffe1adbbc2baf564e0383bad229bbf31eaeebc7c88897732d8b932d" name="aae22d3d18dffe1adbbc2baf564e0383bad229bbf31eaeebc7c88897732d8b932d"></a>background&#160;</td><td class="fielddoc"><p>Restricted to efficiency cores on platforms that have them. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4da8a17f4d2a9ae7625a31ee9c33a4e5" name="a4da8a17f4d2a9ae7625a31ee9c33a4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da8a17f4d2a9ae7625a31ee9c33a4e5">&#9670;&#160;</a></span>Thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>threadName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>threadStackSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a8f524d41ddb44b0cc43d4bb39eabbc81">osDefaultStackSize</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread. </p>
<p>When first created, the thread is not running. Use the <a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4" title="Attempts to start a new thread with default (&#39;Priority::normal&#39;) priority.">startThread()</a> method to start it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadName</td><td>The name of the thread which typically appears in debug logs and profiles. </td></tr>
    <tr><td class="paramname">threadStackSize</td><td>The size of the stack of the thread. If this value is zero then the default stack size of the OS will be used. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="#a8f524d41ddb44b0cc43d4bb39eabbc81">osDefaultStackSize</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a94e1d4eaacb9cca70ac0e396278560fa">getCurrentThread()</a>.</p>

</div>
</div>
<a id="a026b23628e1727050e864e00489c0baf" name="a026b23628e1727050e864e00489c0baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026b23628e1727050e864e00489c0baf">&#9670;&#160;</a></span>~Thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Thread::~Thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>You must never attempt to delete a <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a> object while it's still running - always call <a class="el" href="#a18583d51411d6a34c59b63f0adff4697" title="Attempts to stop the thread running.">stopThread()</a> and make sure your thread has stopped before deleting the object. Failing to do so will throw an assertion, and put you firmly into undefined behaviour territory. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="aae90dfabab3e1776cf01a26e7ee3a620" name="aae90dfabab3e1776cf01a26e7ee3a620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae90dfabab3e1776cf01a26e7ee3a620">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Thread::run </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be implemented to perform the thread's actual code. </p>
<p>Remember that the thread must regularly check the <a class="el" href="#ab89b68d53514e0b3978460aab3202fd7" title="Checks whether the thread has been told to stop running.">threadShouldExit()</a> method whilst running, and if this returns true it should return from the <a class="el" href="#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code.">run()</a> method as soon as possible to avoid being forcibly killed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab89b68d53514e0b3978460aab3202fd7" title="Checks whether the thread has been told to stop running.">threadShouldExit</a>, <a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4" title="Attempts to start a new thread with default (&#39;Priority::normal&#39;) priority.">startThread</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classTimeSliceThread.html#a02663a9825fd2eef3393863e0b6a87bf">TimeSliceThread::contains()</a>.</p>

</div>
</div>
<a id="a2951d9e21e5f3c2415a8cae68ff7f3e4" name="a2951d9e21e5f3c2415a8cae68ff7f3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2951d9e21e5f3c2415a8cae68ff7f3e4">&#9670;&#160;</a></span>startThread() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::startThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to start a new thread with default ('<a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383bafea087517c26fadd409bd4b9dc642555" title="The OS default.">Priority::normal</a>') priority. </p>
<p>This will cause the thread's <a class="el" href="#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code.">run()</a> method to be called by a new thread. If this thread is already running, <a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4" title="Attempts to start a new thread with default (&#39;Priority::normal&#39;) priority.">startThread()</a> won't do anything.</p>
<p>If a thread cannot be created with the requested priority, this will return false and <a class="el" href="#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code.">Thread::run()</a> will not be called. An exception to this is the Android platform, which always starts a thread and attempts to upgrade the thread after creation.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the thread started successfully. false if it was unsuccessful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a18583d51411d6a34c59b63f0adff4697" title="Attempts to stop the thread running.">stopThread</a> </dd></dl>

</div>
</div>
<a id="a1cbd05a5c1e23417fbcbf5b96f7a433e" name="a1cbd05a5c1e23417fbcbf5b96f7a433e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbd05a5c1e23417fbcbf5b96f7a433e">&#9670;&#160;</a></span>startThread() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::startThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a></td>          <td class="paramname"><span class="paramname"><em>newPriority</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to start a new thread with a given priority. </p>
<p>This will cause the thread's <a class="el" href="#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code.">run()</a> method to be called by a new thread. If this thread is already running, <a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4" title="Attempts to start a new thread with default (&#39;Priority::normal&#39;) priority.">startThread()</a> won't do anything.</p>
<p>If a thread cannot be created with the requested priority, this will return false and <a class="el" href="#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code.">Thread::run()</a> will not be called. An exception to this is the Android platform, which always starts a thread and attempts to upgrade the thread after creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newPriority</td><td><a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b" title="The different runtime priorities of non-realtime threads.">Priority</a> the thread should be assigned. This parameter is ignored on Linux.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread started successfully, false if it was unsuccesful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4" title="Attempts to start a new thread with default (&#39;Priority::normal&#39;) priority.">startThread</a>, <a class="el" href="#a0aa09f7a5eb11b7cbf821c9b72110950" title="Attempts to set the priority for this thread.">setPriority</a>, <a class="el" href="#a17c0849ec96a936beebc645ce0708faf" title="Starts the thread with realtime performance characteristics on platforms that support it.">startRealtimeThread</a> </dd></dl>

</div>
</div>
<a id="a17c0849ec96a936beebc645ce0708faf" name="a17c0849ec96a936beebc645ce0708faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c0849ec96a936beebc645ce0708faf">&#9670;&#160;</a></span>startRealtimeThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::startRealtimeThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structThread_1_1RealtimeOptions.html">RealtimeOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the thread with realtime performance characteristics on platforms that support it. </p>
<p>You cannot change the options of a running realtime thread, nor switch a non-realtime thread to a realtime thread. To make these changes you must first stop the thread and then restart with different options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Realtime options the thread should be created with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2951d9e21e5f3c2415a8cae68ff7f3e4" title="Attempts to start a new thread with default (&#39;Priority::normal&#39;) priority.">startThread</a>, <a class="el" href="structThread_1_1RealtimeOptions.html" title="A selection of options available when creating realtime threads.">RealtimeOptions</a> </dd></dl>

</div>
</div>
<a id="a18583d51411d6a34c59b63f0adff4697" name="a18583d51411d6a34c59b63f0adff4697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18583d51411d6a34c59b63f0adff4697">&#9670;&#160;</a></span>stopThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::stopThread </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeOutMilliseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to stop the thread running. </p>
<p>This method will cause the <a class="el" href="#ab89b68d53514e0b3978460aab3202fd7" title="Checks whether the thread has been told to stop running.">threadShouldExit()</a> method to return true and call <a class="el" href="#a0b4d5a1ffaa35cc13f323a0524012a2b" title="Wakes up the thread.">notify()</a> in case the thread is currently waiting.</p>
<p>Hopefully the thread will then respond to this by exiting cleanly, and the stopThread method will wait for a given time-period for this to happen.</p>
<p>If the thread is stuck and fails to respond after the timeout, it gets forcibly killed, which is a very bad thing to happen, as it could still be holding locks, etc. which are needed by other parts of your program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOutMilliseconds</td><td>The number of milliseconds to wait for the thread to finish before killing it by force. A negative value in here will wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread was cleanly stopped before the timeout, or false if it had to be killed by force. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#affe168e27c6ee50b0d10522810772268" title="Sets a flag to tell the thread it should stop.">signalThreadShouldExit</a>, <a class="el" href="#ab89b68d53514e0b3978460aab3202fd7" title="Checks whether the thread has been told to stop running.">threadShouldExit</a>, <a class="el" href="#ad9b6494f25d5d8eb07ed6fc96178eac5" title="Waits for the thread to stop.">waitForThreadToExit</a>, <a class="el" href="#afc4e7957f1c3a3f98218324c0fdc3beb" title="Returns true if the thread is currently active.">isThreadRunning</a> </dd></dl>

</div>
</div>
<a id="a0083c4d5a99074e3a44e01584b98495f" name="a0083c4d5a99074e3a44e01584b98495f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0083c4d5a99074e3a44e01584b98495f">&#9670;&#160;</a></span>launch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::launch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;</td>          <td class="paramname"><span class="paramname"><em>functionToRun</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a lambda or function on its own thread with the default priority. </p>
<p>This will spin up a <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a> object which calls the function and then exits. Bear in mind that starting and stopping a thread can be a fairly heavyweight operation, so you might prefer to use a <a class="el" href="classThreadPool.html" title="A set of threads that will run a list of jobs.">ThreadPool</a> if you're kicking off a lot of short background tasks.</p>
<p>Also note that using an anonymous thread makes it very difficult to interrupt the function when you need to stop it, e.g. when your app quits. So it's up to you to deal with situations where the function may fail to stop in time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functionToRun</td><td>The lambda to be called from the new <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread started successfully, or false if it failed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0083c4d5a99074e3a44e01584b98495f" title="Invokes a lambda or function on its own thread with the default priority.">launch</a>. </dd></dl>

</div>
</div>
<a id="a6ab3f81bc885603bcf7893feaf2ca083" name="a6ab3f81bc885603bcf7893feaf2ca083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab3f81bc885603bcf7893feaf2ca083">&#9670;&#160;</a></span>launch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::launch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;</td>          <td class="paramname"><span class="paramname"><em>functionToRun</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a lambda or function on its own thread with a custom priority. </p>
<p>This will spin up a <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a> object which calls the function and then exits. Bear in mind that starting and stopping a thread can be a fairly heavyweight operation, so you might prefer to use a <a class="el" href="classThreadPool.html" title="A set of threads that will run a list of jobs.">ThreadPool</a> if you're kicking off a lot of short background tasks.</p>
<p>Also note that using an anonymous thread makes it very difficult to interrupt the function when you need to stop it, e.g. when your app quits. So it's up to you to deal with situations where the function may fail to stop in time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The priority the thread is started with. </td></tr>
    <tr><td class="paramname">functionToRun</td><td>The lambda to be called from the new <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread started successfully, or false if it failed. </dd></dl>

</div>
</div>
<a id="afc4e7957f1c3a3f98218324c0fdc3beb" name="afc4e7957f1c3a3f98218324c0fdc3beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4e7957f1c3a3f98218324c0fdc3beb">&#9670;&#160;</a></span>isThreadRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::isThreadRunning </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the thread is currently active. </p>

<p class="reference">Referenced by <a class="el" href="classMidiOutput.html#a3209663ab4f21ae008e2861cd8477d59">MidiOutput::isBackgroundThreadRunning()</a>.</p>

</div>
</div>
<a id="affe168e27c6ee50b0d10522810772268" name="affe168e27c6ee50b0d10522810772268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe168e27c6ee50b0d10522810772268">&#9670;&#160;</a></span>signalThreadShouldExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::signalThreadShouldExit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a flag to tell the thread it should stop. </p>
<p>Calling this means that the <a class="el" href="#ab89b68d53514e0b3978460aab3202fd7" title="Checks whether the thread has been told to stop running.">threadShouldExit()</a> method will then return true. The thread should be regularly checking this to see whether it should exit.</p>
<p>If your thread makes use of <a class="el" href="#a7b70b0d7036575c101e779d4a67fb99d" title="Suspends the execution of this thread until either the specified timeout period has elapsed,...">wait()</a>, you might want to call <a class="el" href="#a0b4d5a1ffaa35cc13f323a0524012a2b" title="Wakes up the thread.">notify()</a> after calling this method, to interrupt any waits that might be in progress, and allow it to reach a point where it can exit.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab89b68d53514e0b3978460aab3202fd7" title="Checks whether the thread has been told to stop running.">threadShouldExit</a>, <a class="el" href="#ad9b6494f25d5d8eb07ed6fc96178eac5" title="Waits for the thread to stop.">waitForThreadToExit</a> </dd></dl>

</div>
</div>
<a id="ab89b68d53514e0b3978460aab3202fd7" name="ab89b68d53514e0b3978460aab3202fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89b68d53514e0b3978460aab3202fd7">&#9670;&#160;</a></span>threadShouldExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::threadShouldExit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the thread has been told to stop running. </p>
<p>Threads need to check this regularly, and if it returns true, they should return from their <a class="el" href="#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code.">run()</a> method at the first possible opportunity.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#affe168e27c6ee50b0d10522810772268" title="Sets a flag to tell the thread it should stop.">signalThreadShouldExit</a>, <a class="el" href="#ac92778089556fd0b5ab9c31557669ce8" title="Checks whether the current thread has been told to stop running.">currentThreadShouldExit</a> </dd></dl>

</div>
</div>
<a id="ac92778089556fd0b5ab9c31557669ce8" name="ac92778089556fd0b5ab9c31557669ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92778089556fd0b5ab9c31557669ce8">&#9670;&#160;</a></span>currentThreadShouldExit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::currentThreadShouldExit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the current thread has been told to stop running. </p>
<p>On the message thread, this will always return false, otherwise it will return <a class="el" href="#ab89b68d53514e0b3978460aab3202fd7" title="Checks whether the thread has been told to stop running.">threadShouldExit()</a> called on the current thread.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab89b68d53514e0b3978460aab3202fd7" title="Checks whether the thread has been told to stop running.">threadShouldExit</a> </dd></dl>

</div>
</div>
<a id="ad9b6494f25d5d8eb07ed6fc96178eac5" name="ad9b6494f25d5d8eb07ed6fc96178eac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b6494f25d5d8eb07ed6fc96178eac5">&#9670;&#160;</a></span>waitForThreadToExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::waitForThreadToExit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeOutMilliseconds</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the thread to stop. </p>
<p>This will wait until <a class="el" href="#afc4e7957f1c3a3f98218324c0fdc3beb" title="Returns true if the thread is currently active.">isThreadRunning()</a> is false or until a timeout expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOutMilliseconds</td><td>the time to wait, in milliseconds. If this value is less than zero, it will wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread exits, or false if the timeout expires first. </dd></dl>

</div>
</div>
<a id="aad3e509718eb01ac3c61418f8b350c2b" name="aad3e509718eb01ac3c61418f8b350c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3e509718eb01ac3c61418f8b350c2b">&#9670;&#160;</a></span>addListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::addListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classThread_1_1Listener.html">Listener</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a listener to this thread which will receive a callback when signalThreadShouldExit was called on this thread. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#affe168e27c6ee50b0d10522810772268" title="Sets a flag to tell the thread it should stop.">signalThreadShouldExit</a>, <a class="el" href="#abec45c6a6d42076b256bd48d57817778" title="Removes a listener added with addListener.">removeListener</a> </dd></dl>

</div>
</div>
<a id="abec45c6a6d42076b256bd48d57817778" name="abec45c6a6d42076b256bd48d57817778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec45c6a6d42076b256bd48d57817778">&#9670;&#160;</a></span>removeListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::removeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classThread_1_1Listener.html">Listener</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a listener added with addListener. </p>

</div>
</div>
<a id="aaaac0a1f90490d701f37da4605a84068" name="aaaac0a1f90490d701f37da4605a84068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaac0a1f90490d701f37da4605a84068">&#9670;&#160;</a></span>isRealtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::isRealtime </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a> represents a realtime thread. </p>

</div>
</div>
<a id="a614605563fceeac6f03d507bc35bdce4" name="a614605563fceeac6f03d507bc35bdce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614605563fceeac6f03d507bc35bdce4">&#9670;&#160;</a></span>setAffinityMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::setAffinityMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#gabd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a></td>          <td class="paramname"><span class="paramname"><em>affinityMask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the affinity mask for the thread. </p>
<p>This will only have an effect next time the thread is started - i.e. if the thread is already running when called, it'll have no effect.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac21eb5ae8c32bc2ecacba904f3411802" title="Changes the affinity mask for the caller thread.">setCurrentThreadAffinityMask</a> </dd></dl>

</div>
</div>
<a id="ac21eb5ae8c32bc2ecacba904f3411802" name="ac21eb5ae8c32bc2ecacba904f3411802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21eb5ae8c32bc2ecacba904f3411802">&#9670;&#160;</a></span>setCurrentThreadAffinityMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::setCurrentThreadAffinityMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#gabd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a></td>          <td class="paramname"><span class="paramname"><em>affinityMask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the affinity mask for the caller thread. </p>
<p>This will change the affinity mask for the thread that calls this static method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a614605563fceeac6f03d507bc35bdce4" title="Sets the affinity mask for the thread.">setAffinityMask</a> </dd></dl>

<p class="reference">References <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>.</p>

</div>
</div>
<a id="a4ee1ddee32aa82ac90bc567cb7427926" name="a4ee1ddee32aa82ac90bc567cb7427926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee1ddee32aa82ac90bc567cb7427926">&#9670;&#160;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>milliseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspends the execution of the current thread until the specified timeout period has elapsed (note that this may not be exact). </p>
<p>The timeout period must not be negative and whilst sleeping the thread cannot be woken up so it should only be used for short periods of time and when other methods such as using a <a class="el" href="classWaitableEvent.html" title="Allows threads to wait for events triggered by other threads.">WaitableEvent</a> or <a class="el" href="classCriticalSection.html" title="A re-entrant mutex.">CriticalSection</a> are not possible. </p>

<p class="reference">References <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>.</p>

</div>
</div>
<a id="aaf47a344b3b715e49ffcbc6119c72cdc" name="aaf47a344b3b715e49ffcbc6119c72cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf47a344b3b715e49ffcbc6119c72cdc">&#9670;&#160;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::yield </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Yields the current thread's CPU time-slot and allows a new thread to run. </p>
<p>If there are no other threads of equal or higher priority currently running then this will return immediately and the current thread will continue to run. </p>

<p class="reference">References <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>.</p>

</div>
</div>
<a id="a7b70b0d7036575c101e779d4a67fb99d" name="a7b70b0d7036575c101e779d4a67fb99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b70b0d7036575c101e779d4a67fb99d">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::wait </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>timeOutMilliseconds</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspends the execution of this thread until either the specified timeout period has elapsed, or another thread calls the <a class="el" href="#a0b4d5a1ffaa35cc13f323a0524012a2b" title="Wakes up the thread.">notify()</a> method to wake it up. </p>
<p>A negative timeout value means that the method will wait indefinitely.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the event has been signalled, false if the timeout expires. </dd></dl>

</div>
</div>
<a id="a0b4d5a1ffaa35cc13f323a0524012a2b" name="a0b4d5a1ffaa35cc13f323a0524012a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4d5a1ffaa35cc13f323a0524012a2b">&#9670;&#160;</a></span>notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::notify </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakes up the thread. </p>
<p>If the thread has called the <a class="el" href="#a7b70b0d7036575c101e779d4a67fb99d" title="Suspends the execution of this thread until either the specified timeout period has elapsed,...">wait()</a> method, this will wake it up.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7b70b0d7036575c101e779d4a67fb99d" title="Suspends the execution of this thread until either the specified timeout period has elapsed,...">wait</a> </dd></dl>

</div>
</div>
<a id="abd4762b20144186ffc28280cedd224e9" name="abd4762b20144186ffc28280cedd224e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4762b20144186ffc28280cedd224e9">&#9670;&#160;</a></span>getCurrentThreadId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adcf5808753df4373be08d38938880f65">ThreadID</a> <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::getCurrentThreadId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an id that identifies the caller thread. </p>
<p>To find the ID of a particular thread object, use <a class="el" href="#a39ca822734b9b20ab32eeba774c9a803" title="Returns the ID of this thread.">getThreadId()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique identifier that identifies the calling thread. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a39ca822734b9b20ab32eeba774c9a803" title="Returns the ID of this thread.">getThreadId</a> </dd></dl>

<p class="reference">References <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>.</p>

<p class="reference">Referenced by <a class="el" href="classThreadLocalValue.html#acfba4720f04999b3160aa73455e10c66">ThreadLocalValue&lt; Type &gt;::get()</a>, and <a class="el" href="classThreadLocalValue.html#a78af45671b2b057f0f584a75f79ff5b5">ThreadLocalValue&lt; Type &gt;::releaseCurrentThreadStorage()</a>.</p>

</div>
</div>
<a id="a94e1d4eaacb9cca70ac0e396278560fa" name="a94e1d4eaacb9cca70ac0e396278560fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e1d4eaacb9cca70ac0e396278560fa">&#9670;&#160;</a></span>getCurrentThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThread.html">Thread</a> *<a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::getCurrentThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the thread object that is currently running. </p>
<p>Note that the main UI thread (or other non-JUCE threads) don't have a <a class="el" href="classThread.html" title="Encapsulates a thread.">Thread</a> object associated with them, so this will return nullptr. </p>

<p class="reference">References <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>, and <a class="el" href="#a4da8a17f4d2a9ae7625a31ee9c33a4e5">Thread()</a>.</p>

</div>
</div>
<a id="a39ca822734b9b20ab32eeba774c9a803" name="a39ca822734b9b20ab32eeba774c9a803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ca822734b9b20ab32eeba774c9a803">&#9670;&#160;</a></span>getThreadId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adcf5808753df4373be08d38938880f65">ThreadID</a> Thread::getThreadId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this thread. </p>
<p>That means the ID of this thread object - not of the thread that's calling the method. This can change when the thread is started and stopped, and will be invalid if the thread's not actually running.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abd4762b20144186ffc28280cedd224e9" title="Returns an id that identifies the caller thread.">getCurrentThreadId</a> </dd></dl>

</div>
</div>
<a id="a84eb62c0e47873d28c4aeda0281d6359" name="a84eb62c0e47873d28c4aeda0281d6359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84eb62c0e47873d28c4aeda0281d6359">&#9670;&#160;</a></span>getThreadName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classString.html">String</a> &amp; Thread::getThreadName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the thread. </p>
<p>This is the name that gets set in the constructor. </p>

<p class="reference">References <a class="el" href="#a84eb62c0e47873d28c4aeda0281d6359">getThreadName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a84eb62c0e47873d28c4aeda0281d6359">getThreadName()</a>.</p>

</div>
</div>
<a id="a8ba2a683ea8111c08db83092360b7226" name="a8ba2a683ea8111c08db83092360b7226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba2a683ea8111c08db83092360b7226">&#9670;&#160;</a></span>setCurrentThreadName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::setCurrentThreadName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newThreadName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the name of the caller thread. </p>
<p>Different OSes may place different length or content limits on this name. </p>

<p class="reference">References <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>.</p>

</div>
</div>
<a id="a414755620d63dbeada96b1de5309c778" name="a414755620d63dbeada96b1de5309c778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414755620d63dbeada96b1de5309c778">&#9670;&#160;</a></span>initialiseJUCE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::initialiseJUCE </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>jniEnv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>jContext</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises the JUCE subsystem for projects not created by the Projucer. </p>
<p>On Android, JUCE needs to be initialised once before it is used. The Projucer will automatically generate the necessary java code to do this. However, if you are using JUCE without the Projucer or are creating a library made with JUCE intended for use in non-JUCE apks, then you must call this method manually once on apk startup.</p>
<p>You can call this method from C++ or directly from java by calling the following java method:</p>
<div class="fragment"><div class="line">com.rmsl.juce.Java.initialiseJUCE (myContext);</div>
</div><!-- fragment --><p>Note that the above java method is only available in Android Studio projects created by the Projucer. If you need to call this from another type of project then you need to add the following java file to your project:</p>
<div class="fragment"><div class="line"><span class="keyword">package </span>com.rmsl.juce;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Java</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> { System.loadLibrary (<span class="stringliteral">&quot;juce_jni&quot;</span>); }</div>
<div class="line">    <span class="keyword">public</span> native <span class="keyword">static</span> <span class="keywordtype">void</span> initialiseJUCE (Context context);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jniEnv</td><td>this is a pointer to JNI's JNIEnv variable. Any callback from Java into C++ will have this passed in as it's first parameter. </td></tr>
    <tr><td class="paramname">jContext</td><td>this is a jobject referring to your app/service/receiver/ provider's Context. JUCE needs this for many of it's internal functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76828ab40831e791f5246cb15003ace8" name="a76828ab40831e791f5246cb15003ace8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76828ab40831e791f5246cb15003ace8">&#9670;&#160;</a></span>getPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a> Thread::getPriority </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current priority of this thread. </p>
<p>This can only be called from the target thread. Doing so from another thread will cause an assert.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0aa09f7a5eb11b7cbf821c9b72110950" title="Attempts to set the priority for this thread.">setPriority</a> </dd></dl>

</div>
</div>
<a id="a0aa09f7a5eb11b7cbf821c9b72110950" name="a0aa09f7a5eb11b7cbf821c9b72110950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa09f7a5eb11b7cbf821c9b72110950">&#9670;&#160;</a></span>setPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::setPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b">Priority</a></td>          <td class="paramname"><span class="paramname"><em>newPriority</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to set the priority for this thread. </p>
<p>Returns true if the new priority was set successfully, false if not.</p>
<p>This can only be called from the target thread. Doing so from another thread will cause an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newPriority</td><td>The new priority to be applied to the thread. Note: This has no effect on Linux platforms, subsequent calls to 'getPriority' will return this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aae22d3d18dffe1adbbc2baf564e0383b" title="The different runtime priorities of non-realtime threads.">Priority</a> </dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a8f524d41ddb44b0cc43d4bb39eabbc81" name="a8f524d41ddb44b0cc43d4bb39eabbc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f524d41ddb44b0cc43d4bb39eabbc81">&#9670;&#160;</a></span>osDefaultStackSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Thread::osDefaultStackSize { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="#a4da8a17f4d2a9ae7625a31ee9c33a4e5">Thread()</a>, and <a class="el" href="classThreadPool.html#ada483e083fa0f8889c77effac7c11e59">ThreadPool::ThreadPool()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
