<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JUCE: OpenGLContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- main-nav -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classOpenGLContext-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">OpenGLContext Class Reference<div class="ingroups"><a class="el" href="group__juce__opengl.html">juce_opengl</a> &raquo; <a class="el" href="group__juce__opengl-opengl.html">opengl</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Creates an OpenGL context, which can be attached to a component.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a290ba62cfd70359da387047556f42b0a" id="r_a290ba62cfd70359da387047556f42b0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a290ba62cfd70359da387047556f42b0a">TextureMagnificationFilter</a> { <a class="el" href="#a290ba62cfd70359da387047556f42b0aae8efea5c05a9c52d15f3d027bafe76be">nearest</a>
, <a class="el" href="#a290ba62cfd70359da387047556f42b0aafd6e8b3423b615a0068231b07db5cbd1">linear</a>
 }</td></tr>
<tr class="memdesc:a290ba62cfd70359da387047556f42b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Texture magnification filters, used by <a class="el" href="#aab1cd9a903ab462292b108f232244983" title="Sets the texture magnification filter.">setTextureMagnificationFilter()</a>.  <a href="#a290ba62cfd70359da387047556f42b0a">More...</a><br /></td></tr>
<tr class="memitem:a3a6b8eeed7dbc7c7c649528252c07d02" id="r_a3a6b8eeed7dbc7c7c649528252c07d02"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02">OpenGLVersion</a> { <a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02abfbb3238e2943fa532a03e1473ac1baf">defaultGLVersion</a> = 0
, <a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02a360335be2efbcff04897b872de9b8e45">openGL3_2</a>
, <a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02acefb7dbb349a2f190d131bab6c028877">openGL4_1</a>
, <a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02a6cafe048a3db4fc2dba20ea2cd1575b9">openGL4_3</a>
 }</td></tr>
<tr class="memdesc:a3a6b8eeed7dbc7c7c649528252c07d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL versions, used by <a class="el" href="#a45a3bcd0cfcf94796ed43113a1866315" title="Sets a preference for the version of GL that this context should use, if possible.">setOpenGLVersionRequired()</a>.  <a href="#a3a6b8eeed7dbc7c7c649528252c07d02">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9be23e3642f28848a26cd00669f0b4d7" id="r_a9be23e3642f28848a26cd00669f0b4d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be23e3642f28848a26cd00669f0b4d7">OpenGLContext</a> ()</td></tr>
<tr class="memitem:ac1f6be39c9063b52dcfa60b94a2e5407" id="r_ac1f6be39c9063b52dcfa60b94a2e5407"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f6be39c9063b52dcfa60b94a2e5407">~OpenGLContext</a> ()</td></tr>
<tr class="memdesc:ac1f6be39c9063b52dcfa60b94a2e5407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="memitem:adbb9e06c8783a85db58f8b666675e577" id="r_adbb9e06c8783a85db58f8b666675e577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb9e06c8783a85db58f8b666675e577">setRenderer</a> (<a class="el" href="classOpenGLRenderer.html">OpenGLRenderer</a> *) noexcept</td></tr>
<tr class="memdesc:adbb9e06c8783a85db58f8b666675e577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the context an <a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a> to use to do the drawing.  <br /></td></tr>
<tr class="memitem:ad320cd274bba96c11dc1ea32310ad37c" id="r_ad320cd274bba96c11dc1ea32310ad37c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad320cd274bba96c11dc1ea32310ad37c">attachTo</a> (<a class="el" href="classComponent.html">Component</a> &amp;)</td></tr>
<tr class="memdesc:ad320cd274bba96c11dc1ea32310ad37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches the context to a target component.  <br /></td></tr>
<tr class="memitem:a7504aa8928c854732090ee9583e9f37d" id="r_a7504aa8928c854732090ee9583e9f37d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7504aa8928c854732090ee9583e9f37d">detach</a> ()</td></tr>
<tr class="memdesc:a7504aa8928c854732090ee9583e9f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the context from its target component and deletes any native resources.  <br /></td></tr>
<tr class="memitem:ac2a9392e74c56fd8a0ee45d1a845b0f0" id="r_ac2a9392e74c56fd8a0ee45d1a845b0f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2a9392e74c56fd8a0ee45d1a845b0f0">isAttached</a> () const noexcept</td></tr>
<tr class="memdesc:ac2a9392e74c56fd8a0ee45d1a845b0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the context is attached to a component and is on-screen.  <br /></td></tr>
<tr class="memitem:a6a23094578b2e07302385828fcc6f4b4" id="r_a6a23094578b2e07302385828fcc6f4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponent.html">Component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a23094578b2e07302385828fcc6f4b4">getTargetComponent</a> () const noexcept</td></tr>
<tr class="memdesc:a6a23094578b2e07302385828fcc6f4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component to which this context is currently attached, or nullptr.  <br /></td></tr>
<tr class="memitem:aeb49920c5ee4e4694fa4cbd1700b2acb" id="r_aeb49920c5ee4e4694fa4cbd1700b2acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb49920c5ee4e4694fa4cbd1700b2acb">setPixelFormat</a> (const <a class="el" href="classOpenGLPixelFormat.html">OpenGLPixelFormat</a> &amp;preferredPixelFormat) noexcept</td></tr>
<tr class="memdesc:aeb49920c5ee4e4694fa4cbd1700b2acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel format which you'd like to use for the target GL surface.  <br /></td></tr>
<tr class="memitem:aab1cd9a903ab462292b108f232244983" id="r_aab1cd9a903ab462292b108f232244983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab1cd9a903ab462292b108f232244983">setTextureMagnificationFilter</a> (<a class="el" href="#a290ba62cfd70359da387047556f42b0a">TextureMagnificationFilter</a> magFilterMode) noexcept</td></tr>
<tr class="memdesc:aab1cd9a903ab462292b108f232244983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture magnification filter.  <br /></td></tr>
<tr class="memitem:a0129ecf603a0cc3034e4809a23812e4a" id="r_a0129ecf603a0cc3034e4809a23812e4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0129ecf603a0cc3034e4809a23812e4a">setNativeSharedContext</a> (void *nativeContextToShareWith) noexcept</td></tr>
<tr class="memdesc:a0129ecf603a0cc3034e4809a23812e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a context with which you'd like this context's resources to be shared.  <br /></td></tr>
<tr class="memitem:ab3e6fd6e0d9104a249f029833f6b4172" id="r_ab3e6fd6e0d9104a249f029833f6b4172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3e6fd6e0d9104a249f029833f6b4172">setMultisamplingEnabled</a> (bool) noexcept</td></tr>
<tr class="memdesc:ab3e6fd6e0d9104a249f029833f6b4172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables multisampling on platforms where this is implemented.  <br /></td></tr>
<tr class="memitem:af33252b1d42af69915c77401f8c0ba31" id="r_af33252b1d42af69915c77401f8c0ba31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af33252b1d42af69915c77401f8c0ba31">areShadersAvailable</a> () const</td></tr>
<tr class="memdesc:af33252b1d42af69915c77401f8c0ba31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if shaders can be used in this context.  <br /></td></tr>
<tr class="memitem:a1d669937c6b0251bf5139a79a498051b" id="r_a1d669937c6b0251bf5139a79a498051b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d669937c6b0251bf5139a79a498051b">isTextureNpotSupported</a> () const</td></tr>
<tr class="memdesc:a1d669937c6b0251bf5139a79a498051b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if non-power-of-two textures are supported in this context.  <br /></td></tr>
<tr class="memitem:a45a3bcd0cfcf94796ed43113a1866315" id="r_a45a3bcd0cfcf94796ed43113a1866315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45a3bcd0cfcf94796ed43113a1866315">setOpenGLVersionRequired</a> (<a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02">OpenGLVersion</a>) noexcept</td></tr>
<tr class="memdesc:a45a3bcd0cfcf94796ed43113a1866315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a preference for the version of GL that this context should use, if possible.  <br /></td></tr>
<tr class="memitem:aaa4cf6bbdb662b106cd44c203b8abb1a" id="r_aaa4cf6bbdb662b106cd44c203b8abb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4cf6bbdb662b106cd44c203b8abb1a">setComponentPaintingEnabled</a> (bool shouldPaintComponent) noexcept</td></tr>
<tr class="memdesc:aaa4cf6bbdb662b106cd44c203b8abb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the use of the GL context to perform 2D rendering of the component to which it is attached.  <br /></td></tr>
<tr class="memitem:a7c305575ef3337ae64940db3c00abdc6" id="r_a7c305575ef3337ae64940db3c00abdc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c305575ef3337ae64940db3c00abdc6">setContinuousRepainting</a> (bool shouldContinuouslyRepaint) noexcept</td></tr>
<tr class="memdesc:a7c305575ef3337ae64940db3c00abdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables continuous repainting.  <br /></td></tr>
<tr class="memitem:acc0fc11c02ebbe4af1cc234eb5d8b84a" id="r_acc0fc11c02ebbe4af1cc234eb5d8b84a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc0fc11c02ebbe4af1cc234eb5d8b84a">triggerRepaint</a> ()</td></tr>
<tr class="memdesc:acc0fc11c02ebbe4af1cc234eb5d8b84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously causes a repaint to be made.  <br /></td></tr>
<tr class="memitem:afbf415dad41c71003e404af1833a2b2b" id="r_afbf415dad41c71003e404af1833a2b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classReferenceCountedObject.html">ReferenceCountedObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf415dad41c71003e404af1833a2b2b">getAssociatedObject</a> (const char *<a class="el" href="group__juce__audio__plugin__client-Unity.html#ga010e50efcb9d6d393b9414f09f368dbc">name</a>) const</td></tr>
<tr class="memdesc:afbf415dad41c71003e404af1833a2b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This retrieves an object that was previously stored with <a class="el" href="#a51ee6e2d70c172820a4fb26722497892" title="Attaches a named object to the context, which will be deleted when the context is destroyed.">setAssociatedObject()</a>.  <br /></td></tr>
<tr class="memitem:a51ee6e2d70c172820a4fb26722497892" id="r_a51ee6e2d70c172820a4fb26722497892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51ee6e2d70c172820a4fb26722497892">setAssociatedObject</a> (const char *<a class="el" href="group__juce__audio__plugin__client-Unity.html#ga010e50efcb9d6d393b9414f09f368dbc">name</a>, <a class="el" href="classReferenceCountedObject.html">ReferenceCountedObject</a> *newObject)</td></tr>
<tr class="memdesc:a51ee6e2d70c172820a4fb26722497892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a named object to the context, which will be deleted when the context is destroyed.  <br /></td></tr>
<tr class="memitem:a318c8cc5821b9b2b2a9f726c623385f8" id="r_a318c8cc5821b9b2b2a9f726c623385f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a318c8cc5821b9b2b2a9f726c623385f8">makeActive</a> () const noexcept</td></tr>
<tr class="memdesc:a318c8cc5821b9b2b2a9f726c623385f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this context the currently active one.  <br /></td></tr>
<tr class="memitem:a5c5bce957be244229d9293d3303bff40" id="r_a5c5bce957be244229d9293d3303bff40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c5bce957be244229d9293d3303bff40">isActive</a> () const noexcept</td></tr>
<tr class="memdesc:a5c5bce957be244229d9293d3303bff40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this context is currently active for the calling thread.  <br /></td></tr>
<tr class="memitem:a909377fc5880a61d28db1909b8d09e03" id="r_a909377fc5880a61d28db1909b8d09e03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a909377fc5880a61d28db1909b8d09e03">swapBuffers</a> ()</td></tr>
<tr class="memdesc:a909377fc5880a61d28db1909b8d09e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the buffers (if the context can do this).  <br /></td></tr>
<tr class="memitem:a046fe0f0de71000ee940d825d5dc57e0" id="r_a046fe0f0de71000ee940d825d5dc57e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a046fe0f0de71000ee940d825d5dc57e0">setSwapInterval</a> (int numFramesPerSwap)</td></tr>
<tr class="memdesc:a046fe0f0de71000ee940d825d5dc57e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the context checks the vertical sync before swapping.  <br /></td></tr>
<tr class="memitem:a91717bbaa5243bda49b93e7048eff88f" id="r_a91717bbaa5243bda49b93e7048eff88f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91717bbaa5243bda49b93e7048eff88f">getSwapInterval</a> () const</td></tr>
<tr class="memdesc:a91717bbaa5243bda49b93e7048eff88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current swap-sync interval.  <br /></td></tr>
<tr class="memitem:a48062bbab36b278a5ff95831dc8c333d" id="r_a48062bbab36b278a5ff95831dc8c333d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a48062bbab36b278a5ff95831dc8c333d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48062bbab36b278a5ff95831dc8c333d">executeOnGLThread</a> (T &amp;&amp;functor, bool blockUntilFinished)</td></tr>
<tr class="memdesc:a48062bbab36b278a5ff95831dc8c333d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a lambda, function or functor on the OpenGL thread with an active context.  <br /></td></tr>
<tr class="memitem:a5ae7fe1aa47448f75ef67f89cd9db798" id="r_a5ae7fe1aa47448f75ef67f89cd9db798"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae7fe1aa47448f75ef67f89cd9db798">getRenderingScale</a> () const noexcept</td></tr>
<tr class="memdesc:a5ae7fe1aa47448f75ef67f89cd9db798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scale factor that relates the context component's size to the number of physical pixels it covers on the screen.  <br /></td></tr>
<tr class="memitem:a39b86efe11ffe091002d530d302e14bc" id="r_a39b86efe11ffe091002d530d302e14bc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39b86efe11ffe091002d530d302e14bc">getFrameBufferID</a> () const noexcept</td></tr>
<tr class="memdesc:a39b86efe11ffe091002d530d302e14bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this context is backed by a frame buffer, this returns its ID number, or 0 if the context does not use a framebuffer.  <br /></td></tr>
<tr class="memitem:a1993e86d7de92ade91f14b8023c5ac7c" id="r_a1993e86d7de92ade91f14b8023c5ac7c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1993e86d7de92ade91f14b8023c5ac7c">getRawContext</a> () const noexcept</td></tr>
<tr class="memdesc:a1993e86d7de92ade91f14b8023c5ac7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an OS-dependent handle to some kind of underlying OS-provided GL context.  <br /></td></tr>
<tr class="memitem:a4e0c5f2d071182c599ba4952ca7cb4f2" id="r_a4e0c5f2d071182c599ba4952ca7cb4f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e0c5f2d071182c599ba4952ca7cb4f2">isCoreProfile</a> () const</td></tr>
<tr class="memdesc:a4e0c5f2d071182c599ba4952ca7cb4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this context is using the core profile.  <br /></td></tr>
<tr class="memitem:a51e518038caadcdd5899f7e9494d801a" id="r_a51e518038caadcdd5899f7e9494d801a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e518038caadcdd5899f7e9494d801a">copyTexture</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;targetClipArea, const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;anchorPosAndTextureSize, int contextWidth, int contextHeight, bool textureOriginIsBottomLeft, bool blend=true)</td></tr>
<tr class="memdesc:a51e518038caadcdd5899f7e9494d801a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the currently selected texture into this context at its original size.  <br /></td></tr>
<tr class="memitem:a1eb85ffda148dac618e28fae654aab0a" id="r_a1eb85ffda148dac618e28fae654aab0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eb85ffda148dac618e28fae654aab0a">setImageCacheSize</a> (size_t cacheSizeBytes) noexcept</td></tr>
<tr class="memdesc:a1eb85ffda148dac618e28fae654aab0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the amount of GPU memory that the internal cache for Images is allowed to use.  <br /></td></tr>
<tr class="memitem:a370e786a96eac9fa8486eff23ab2da9c" id="r_a370e786a96eac9fa8486eff23ab2da9c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a370e786a96eac9fa8486eff23ab2da9c">getImageCacheSize</a> () const noexcept</td></tr>
<tr class="memdesc:a370e786a96eac9fa8486eff23ab2da9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of GPU memory that the internal cache for Images is allowed to use.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad5fbc172e7190ebc3ff2e7e292cfc640" id="r_ad5fbc172e7190ebc3ff2e7e292cfc640"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenGLContext.html">OpenGLContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5fbc172e7190ebc3ff2e7e292cfc640">getContextAttachedTo</a> (<a class="el" href="classComponent.html">Component</a> &amp;component) noexcept</td></tr>
<tr class="memdesc:ad5fbc172e7190ebc3ff2e7e292cfc640"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given component has an <a class="el" href="classOpenGLContext.html" title="Creates an OpenGL context, which can be attached to a component.">OpenGLContext</a> attached, then this will return it.  <br /></td></tr>
<tr class="memitem:a5a3ece9be728d97e0343ae17a71f6562" id="r_a5a3ece9be728d97e0343ae17a71f6562"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a3ece9be728d97e0343ae17a71f6562">deactivateCurrentContext</a> ()</td></tr>
<tr class="memdesc:a5a3ece9be728d97e0343ae17a71f6562"><td class="mdescLeft">&#160;</td><td class="mdescRight">If any context is active on the current thread, this deactivates it.  <br /></td></tr>
<tr class="memitem:a973a56d782042cc9080a56722dca77d3" id="r_a973a56d782042cc9080a56722dca77d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenGLContext.html">OpenGLContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a973a56d782042cc9080a56722dca77d3">getCurrentContext</a> ()</td></tr>
<tr class="memdesc:a973a56d782042cc9080a56722dca77d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the context that's currently in active use by the calling thread, or nullptr if no context is active.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3e204724fd78bbc272023525226caad7" id="r_a3e204724fd78bbc272023525226caad7"><td class="memItemLeft" align="right" valign="top">OpenGLExtensionFunctions&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e204724fd78bbc272023525226caad7">extensions</a></td></tr>
<tr class="memdesc:a3e204724fd78bbc272023525226caad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure holds a set of dynamically loaded GL functions for use on this context.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Creates an OpenGL context, which can be attached to a component. </p>
<p>To render some OpenGL, you should create an instance of an <a class="el" href="classOpenGLContext.html" title="Creates an OpenGL context, which can be attached to a component.">OpenGLContext</a>, and call <a class="el" href="#ad320cd274bba96c11dc1ea32310ad37c" title="Attaches the context to a target component.">attachTo()</a> to make it use a component as its render target.</p>
<p>To provide threaded rendering, you can supply an <a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a> object that will be used to render each frame.</p>
<p>Before your target component or <a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a> is deleted, you MUST call <a class="el" href="#a7504aa8928c854732090ee9583e9f37d" title="Detaches the context from its target component and deletes any native resources.">detach()</a> or delete the <a class="el" href="classOpenGLContext.html" title="Creates an OpenGL context, which can be attached to a component.">OpenGLContext</a> to allow the background thread to stop and the native resources to be freed safely.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a> </dd></dl>
</div><a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a290ba62cfd70359da387047556f42b0a" name="a290ba62cfd70359da387047556f42b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290ba62cfd70359da387047556f42b0a">&#9670;&#160;</a></span>TextureMagnificationFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a290ba62cfd70359da387047556f42b0a">OpenGLContext::TextureMagnificationFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Texture magnification filters, used by <a class="el" href="#aab1cd9a903ab462292b108f232244983" title="Sets the texture magnification filter.">setTextureMagnificationFilter()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a290ba62cfd70359da387047556f42b0aae8efea5c05a9c52d15f3d027bafe76be" name="a290ba62cfd70359da387047556f42b0aae8efea5c05a9c52d15f3d027bafe76be"></a>nearest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a290ba62cfd70359da387047556f42b0aafd6e8b3423b615a0068231b07db5cbd1" name="a290ba62cfd70359da387047556f42b0aafd6e8b3423b615a0068231b07db5cbd1"></a>linear&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3a6b8eeed7dbc7c7c649528252c07d02" name="a3a6b8eeed7dbc7c7c649528252c07d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6b8eeed7dbc7c7c649528252c07d02">&#9670;&#160;</a></span>OpenGLVersion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02">OpenGLContext::OpenGLVersion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenGL versions, used by <a class="el" href="#a45a3bcd0cfcf94796ed43113a1866315" title="Sets a preference for the version of GL that this context should use, if possible.">setOpenGLVersionRequired()</a>. </p>
<p>The Core profile doesn't include some legacy functionality, including the fixed-function pipeline.</p>
<p>The Compatibility profile is backwards-compatible, and includes functionality deprecated in the Core profile. However, not all implementations provide compatibility profiles targeting later versions of OpenGL. To run on the broadest range of hardware, using the 3.2 Core profile is recommended. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3a6b8eeed7dbc7c7c649528252c07d02abfbb3238e2943fa532a03e1473ac1baf" name="a3a6b8eeed7dbc7c7c649528252c07d02abfbb3238e2943fa532a03e1473ac1baf"></a>defaultGLVersion&#160;</td><td class="fielddoc"><p>Whatever the device decides to give us, normally a compatibility profile. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3a6b8eeed7dbc7c7c649528252c07d02a360335be2efbcff04897b872de9b8e45" name="a3a6b8eeed7dbc7c7c649528252c07d02a360335be2efbcff04897b872de9b8e45"></a>openGL3_2&#160;</td><td class="fielddoc"><p>3.2 Core profile </p>
</td></tr>
<tr><td class="fieldname"><a id="a3a6b8eeed7dbc7c7c649528252c07d02acefb7dbb349a2f190d131bab6c028877" name="a3a6b8eeed7dbc7c7c649528252c07d02acefb7dbb349a2f190d131bab6c028877"></a>openGL4_1&#160;</td><td class="fielddoc"><p>4.1 Core profile, the latest supported by macOS at time of writing </p>
</td></tr>
<tr><td class="fieldname"><a id="a3a6b8eeed7dbc7c7c649528252c07d02a6cafe048a3db4fc2dba20ea2cd1575b9" name="a3a6b8eeed7dbc7c7c649528252c07d02a6cafe048a3db4fc2dba20ea2cd1575b9"></a>openGL4_3&#160;</td><td class="fielddoc"><p>4.3 Core profile, will enable improved debugging support when building in Debug </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9be23e3642f28848a26cd00669f0b4d7" name="a9be23e3642f28848a26cd00669f0b4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be23e3642f28848a26cd00669f0b4d7">&#9670;&#160;</a></span>OpenGLContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenGLContext::OpenGLContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="#ad5fbc172e7190ebc3ff2e7e292cfc640">getContextAttachedTo()</a>, and <a class="el" href="#a973a56d782042cc9080a56722dca77d3">getCurrentContext()</a>.</p>

</div>
</div>
<a id="ac1f6be39c9063b52dcfa60b94a2e5407" name="ac1f6be39c9063b52dcfa60b94a2e5407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f6be39c9063b52dcfa60b94a2e5407">&#9670;&#160;</a></span>~OpenGLContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenGLContext::~OpenGLContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="adbb9e06c8783a85db58f8b666675e577" name="adbb9e06c8783a85db58f8b666675e577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb9e06c8783a85db58f8b666675e577">&#9670;&#160;</a></span>setRenderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenGLRenderer.html">OpenGLRenderer</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the context an <a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a> to use to do the drawing. </p>
<p>The object that you give it will not be owned by the context, so it's the caller's responsibility to manage its lifetime and make sure that it doesn't get deleted while the context may be using it. To stop the context using a renderer, just call this method with a null pointer. Note: This must be called BEFORE attaching your context to a target component! </p>

</div>
</div>
<a id="ad320cd274bba96c11dc1ea32310ad37c" name="ad320cd274bba96c11dc1ea32310ad37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad320cd274bba96c11dc1ea32310ad37c">&#9670;&#160;</a></span>attachTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::attachTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classComponent.html">Component</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches the context to a target component. </p>
<p>If the component is not fully visible, this call will wait until the component is shown before actually creating a native context for it.</p>
<p>When a native context is created, a thread is started, and will be used to call the <a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a> methods. The context will be floated above the target component, and when the target moves, it will track it. If the component is hidden/shown, the context may be deleted and re-created. </p>

<p class="reference">References <a class="el" href="group__juce__audio__plugin__client-detail.html#ga43f72e6eba2a77ceba6172bb1a5e35bf">Component</a>.</p>

</div>
</div>
<a id="a7504aa8928c854732090ee9583e9f37d" name="a7504aa8928c854732090ee9583e9f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7504aa8928c854732090ee9583e9f37d">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::detach </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the context from its target component and deletes any native resources. </p>
<p>If the context has not been attached, this will do nothing. Otherwise, it will block until the context and its thread have been cleaned up. </p>

</div>
</div>
<a id="ac2a9392e74c56fd8a0ee45d1a845b0f0" name="ac2a9392e74c56fd8a0ee45d1a845b0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a9392e74c56fd8a0ee45d1a845b0f0">&#9670;&#160;</a></span>isAttached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGLContext::isAttached </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the context is attached to a component and is on-screen. </p>
<p>Note that if you call <a class="el" href="#ad320cd274bba96c11dc1ea32310ad37c" title="Attaches the context to a target component.">attachTo()</a> for a non-visible component, this method will return false until the component is made visible. </p>

</div>
</div>
<a id="a6a23094578b2e07302385828fcc6f4b4" name="a6a23094578b2e07302385828fcc6f4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a23094578b2e07302385828fcc6f4b4">&#9670;&#160;</a></span>getTargetComponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponent.html">Component</a> * OpenGLContext::getTargetComponent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the component to which this context is currently attached, or nullptr. </p>

<p class="reference">References <a class="el" href="group__juce__audio__plugin__client-detail.html#ga43f72e6eba2a77ceba6172bb1a5e35bf">Component</a>, and <a class="el" href="#a6a23094578b2e07302385828fcc6f4b4">getTargetComponent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a6a23094578b2e07302385828fcc6f4b4">getTargetComponent()</a>.</p>

</div>
</div>
<a id="ad5fbc172e7190ebc3ff2e7e292cfc640" name="ad5fbc172e7190ebc3ff2e7e292cfc640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fbc172e7190ebc3ff2e7e292cfc640">&#9670;&#160;</a></span>getContextAttachedTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenGLContext.html">OpenGLContext</a> * OpenGLContext::getContextAttachedTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classComponent.html">Component</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>component</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the given component has an <a class="el" href="classOpenGLContext.html" title="Creates an OpenGL context, which can be attached to a component.">OpenGLContext</a> attached, then this will return it. </p>

<p class="reference">References <a class="el" href="group__juce__audio__plugin__client-detail.html#ga43f72e6eba2a77ceba6172bb1a5e35bf">Component</a>, <a class="el" href="#ad5fbc172e7190ebc3ff2e7e292cfc640">getContextAttachedTo()</a>, and <a class="el" href="#a9be23e3642f28848a26cd00669f0b4d7">OpenGLContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#ad5fbc172e7190ebc3ff2e7e292cfc640">getContextAttachedTo()</a>.</p>

</div>
</div>
<a id="aeb49920c5ee4e4694fa4cbd1700b2acb" name="aeb49920c5ee4e4694fa4cbd1700b2acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49920c5ee4e4694fa4cbd1700b2acb">&#9670;&#160;</a></span>setPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setPixelFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenGLPixelFormat.html">OpenGLPixelFormat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>preferredPixelFormat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pixel format which you'd like to use for the target GL surface. </p>
<p>Note: This must be called BEFORE attaching your context to a target component! </p>

<p class="reference">References <a class="el" href="#aeb49920c5ee4e4694fa4cbd1700b2acb">setPixelFormat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#aeb49920c5ee4e4694fa4cbd1700b2acb">setPixelFormat()</a>.</p>

</div>
</div>
<a id="aab1cd9a903ab462292b108f232244983" name="aab1cd9a903ab462292b108f232244983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1cd9a903ab462292b108f232244983">&#9670;&#160;</a></span>setTextureMagnificationFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setTextureMagnificationFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a290ba62cfd70359da387047556f42b0a">TextureMagnificationFilter</a></td>          <td class="paramname"><span class="paramname"><em>magFilterMode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture magnification filter. </p>
<p>By default the texture magnification filter is linear. However, for faster rendering you may want to use the 'nearest' magnification filter. This option will not affect any textures created before this function was called. </p>

</div>
</div>
<a id="a0129ecf603a0cc3034e4809a23812e4a" name="a0129ecf603a0cc3034e4809a23812e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0129ecf603a0cc3034e4809a23812e4a">&#9670;&#160;</a></span>setNativeSharedContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setNativeSharedContext </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>nativeContextToShareWith</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a context with which you'd like this context's resources to be shared. </p>
<p>The object passed-in here is a platform-dependent native context object, and must not be deleted while this context may still be using it! To turn off sharing, you can call this method with a null pointer. Note: This must be called BEFORE attaching your context to a target component! </p>

</div>
</div>
<a id="ab3e6fd6e0d9104a249f029833f6b4172" name="ab3e6fd6e0d9104a249f029833f6b4172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e6fd6e0d9104a249f029833f6b4172">&#9670;&#160;</a></span>setMultisamplingEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setMultisamplingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables multisampling on platforms where this is implemented. </p>
<p>If enabling this, you must call this method before <a class="el" href="#ad320cd274bba96c11dc1ea32310ad37c" title="Attaches the context to a target component.">attachTo()</a>. </p>

</div>
</div>
<a id="af33252b1d42af69915c77401f8c0ba31" name="af33252b1d42af69915c77401f8c0ba31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33252b1d42af69915c77401f8c0ba31">&#9670;&#160;</a></span>areShadersAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGLContext::areShadersAvailable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if shaders can be used in this context. </p>

</div>
</div>
<a id="a1d669937c6b0251bf5139a79a498051b" name="a1d669937c6b0251bf5139a79a498051b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d669937c6b0251bf5139a79a498051b">&#9670;&#160;</a></span>isTextureNpotSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGLContext::isTextureNpotSupported </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if non-power-of-two textures are supported in this context. </p>

</div>
</div>
<a id="a45a3bcd0cfcf94796ed43113a1866315" name="a45a3bcd0cfcf94796ed43113a1866315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a3bcd0cfcf94796ed43113a1866315">&#9670;&#160;</a></span>setOpenGLVersionRequired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setOpenGLVersionRequired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02">OpenGLVersion</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a preference for the version of GL that this context should use, if possible. </p>
<p>Some platforms may ignore this value. </p>

</div>
</div>
<a id="aaa4cf6bbdb662b106cd44c203b8abb1a" name="aaa4cf6bbdb662b106cd44c203b8abb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4cf6bbdb662b106cd44c203b8abb1a">&#9670;&#160;</a></span>setComponentPaintingEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setComponentPaintingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shouldPaintComponent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables the use of the GL context to perform 2D rendering of the component to which it is attached. </p>
<p>If this is false, then only your <a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a> will be used to perform any rendering. If true, then each time your target's paint() method needs to be called, an OpenGLGraphicsContext will be used to render it, (after calling your <a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a> if there is one).</p>
<p>By default this is set to true. If you're not using any paint() method functionality and are doing all your rendering in an <a class="el" href="classOpenGLRenderer.html" title="A base class that should be implemented by classes which want to render openGL on a background thread...">OpenGLRenderer</a>, you should disable it to improve performance.</p>
<p>Note: This must be called BEFORE attaching your context to a target component! </p>

</div>
</div>
<a id="a7c305575ef3337ae64940db3c00abdc6" name="a7c305575ef3337ae64940db3c00abdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c305575ef3337ae64940db3c00abdc6">&#9670;&#160;</a></span>setContinuousRepainting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setContinuousRepainting </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shouldContinuouslyRepaint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables continuous repainting. </p>
<p>If set to true, the context will run a loop, re-rendering itself without waiting for <a class="el" href="#acc0fc11c02ebbe4af1cc234eb5d8b84a" title="Asynchronously causes a repaint to be made.">triggerRepaint()</a> to be called, at a frequency determined by the swap interval (see setSwapInterval). If false, then after each render callback, it will wait for another call to <a class="el" href="#acc0fc11c02ebbe4af1cc234eb5d8b84a" title="Asynchronously causes a repaint to be made.">triggerRepaint()</a> before rendering again. This is disabled by default. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a046fe0f0de71000ee940d825d5dc57e0" title="Sets whether the context checks the vertical sync before swapping.">setSwapInterval</a> </dd></dl>

</div>
</div>
<a id="acc0fc11c02ebbe4af1cc234eb5d8b84a" name="acc0fc11c02ebbe4af1cc234eb5d8b84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0fc11c02ebbe4af1cc234eb5d8b84a">&#9670;&#160;</a></span>triggerRepaint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::triggerRepaint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously causes a repaint to be made. </p>

</div>
</div>
<a id="afbf415dad41c71003e404af1833a2b2b" name="afbf415dad41c71003e404af1833a2b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf415dad41c71003e404af1833a2b2b">&#9670;&#160;</a></span>getAssociatedObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classReferenceCountedObject.html">ReferenceCountedObject</a> * OpenGLContext::getAssociatedObject </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This retrieves an object that was previously stored with <a class="el" href="#a51ee6e2d70c172820a4fb26722497892" title="Attaches a named object to the context, which will be deleted when the context is destroyed.">setAssociatedObject()</a>. </p>
<p>If no object is found with the given name, this will return nullptr. This method must only be called from within the GL rendering methods. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a51ee6e2d70c172820a4fb26722497892" title="Attaches a named object to the context, which will be deleted when the context is destroyed.">setAssociatedObject</a> </dd></dl>

<p class="reference">References <a class="el" href="group__juce__audio__plugin__client-Unity.html#ga010e50efcb9d6d393b9414f09f368dbc">name</a>.</p>

</div>
</div>
<a id="a51ee6e2d70c172820a4fb26722497892" name="a51ee6e2d70c172820a4fb26722497892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ee6e2d70c172820a4fb26722497892">&#9670;&#160;</a></span>setAssociatedObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setAssociatedObject </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classReferenceCountedObject.html">ReferenceCountedObject</a> *</td>          <td class="paramname"><span class="paramname"><em>newObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a named object to the context, which will be deleted when the context is destroyed. </p>
<p>This allows you to store an object which will be released before the context is deleted. The main purpose is for caching GL objects such as shader programs, which will become invalid when the context is deleted.</p>
<p>This method must only be called from within the GL rendering methods. </p>

<p class="reference">References <a class="el" href="group__juce__audio__plugin__client-Unity.html#ga010e50efcb9d6d393b9414f09f368dbc">name</a>.</p>

</div>
</div>
<a id="a318c8cc5821b9b2b2a9f726c623385f8" name="a318c8cc5821b9b2b2a9f726c623385f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318c8cc5821b9b2b2a9f726c623385f8">&#9670;&#160;</a></span>makeActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGLContext::makeActive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this context the currently active one. </p>
<p>You should never need to call this in normal use - the context will already be active when <a class="el" href="classOpenGLRenderer.html#a34077b4eaeb3207814b9e4302f724912" title="Called when you should render the next openGL frame.">OpenGLRenderer::renderOpenGL()</a> is invoked. </p>

</div>
</div>
<a id="a5c5bce957be244229d9293d3303bff40" name="a5c5bce957be244229d9293d3303bff40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5bce957be244229d9293d3303bff40">&#9670;&#160;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGLContext::isActive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this context is currently active for the calling thread. </p>

<p class="reference">References <a class="el" href="#a5c5bce957be244229d9293d3303bff40">isActive()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a5c5bce957be244229d9293d3303bff40">isActive()</a>.</p>

</div>
</div>
<a id="a5a3ece9be728d97e0343ae17a71f6562" name="a5a3ece9be728d97e0343ae17a71f6562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3ece9be728d97e0343ae17a71f6562">&#9670;&#160;</a></span>deactivateCurrentContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::deactivateCurrentContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If any context is active on the current thread, this deactivates it. </p>
<p>Note that on some platforms, like Android, this isn't possible. </p>

<p class="reference">References <a class="el" href="#a5a3ece9be728d97e0343ae17a71f6562">deactivateCurrentContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a5a3ece9be728d97e0343ae17a71f6562">deactivateCurrentContext()</a>.</p>

</div>
</div>
<a id="a973a56d782042cc9080a56722dca77d3" name="a973a56d782042cc9080a56722dca77d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973a56d782042cc9080a56722dca77d3">&#9670;&#160;</a></span>getCurrentContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenGLContext.html">OpenGLContext</a> * OpenGLContext::getCurrentContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the context that's currently in active use by the calling thread, or nullptr if no context is active. </p>

<p class="reference">References <a class="el" href="#a973a56d782042cc9080a56722dca77d3">getCurrentContext()</a>, and <a class="el" href="#a9be23e3642f28848a26cd00669f0b4d7">OpenGLContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a973a56d782042cc9080a56722dca77d3">getCurrentContext()</a>.</p>

</div>
</div>
<a id="a909377fc5880a61d28db1909b8d09e03" name="a909377fc5880a61d28db1909b8d09e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909377fc5880a61d28db1909b8d09e03">&#9670;&#160;</a></span>swapBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::swapBuffers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the buffers (if the context can do this). </p>
<p>There's normally no need to call this directly - the buffers will be swapped automatically after your <a class="el" href="classOpenGLRenderer.html#a34077b4eaeb3207814b9e4302f724912" title="Called when you should render the next openGL frame.">OpenGLRenderer::renderOpenGL()</a> method has been called. </p>

<p class="reference">References <a class="el" href="#a909377fc5880a61d28db1909b8d09e03">swapBuffers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a909377fc5880a61d28db1909b8d09e03">swapBuffers()</a>.</p>

</div>
</div>
<a id="a046fe0f0de71000ee940d825d5dc57e0" name="a046fe0f0de71000ee940d825d5dc57e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046fe0f0de71000ee940d825d5dc57e0">&#9670;&#160;</a></span>setSwapInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGLContext::setSwapInterval </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numFramesPerSwap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the context checks the vertical sync before swapping. </p>
<p>The value is the number of frames to allow between buffer-swapping. This is fairly system-dependent, but 0 turns off syncing, 1 makes it swap on frame-boundaries, and greater numbers indicate that it should swap less often.</p>
<p>By default, this will be set to 1.</p>
<p>Returns true if it sets the value successfully - some platforms won't support this setting.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7c305575ef3337ae64940db3c00abdc6" title="Enables or disables continuous repainting.">setContinuousRepainting</a> </dd></dl>

<p class="reference">References <a class="el" href="#a046fe0f0de71000ee940d825d5dc57e0">setSwapInterval()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a046fe0f0de71000ee940d825d5dc57e0">setSwapInterval()</a>.</p>

</div>
</div>
<a id="a91717bbaa5243bda49b93e7048eff88f" name="a91717bbaa5243bda49b93e7048eff88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91717bbaa5243bda49b93e7048eff88f">&#9670;&#160;</a></span>getSwapInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenGLContext::getSwapInterval </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current swap-sync interval. </p>
<p>See <a class="el" href="#a046fe0f0de71000ee940d825d5dc57e0" title="Sets whether the context checks the vertical sync before swapping.">setSwapInterval()</a> for info about the value returned. </p>

<p class="reference">References <a class="el" href="#a91717bbaa5243bda49b93e7048eff88f">getSwapInterval()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a91717bbaa5243bda49b93e7048eff88f">getSwapInterval()</a>.</p>

</div>
</div>
<a id="a48062bbab36b278a5ff95831dc8c333d" name="a48062bbab36b278a5ff95831dc8c333d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48062bbab36b278a5ff95831dc8c333d">&#9670;&#160;</a></span>executeOnGLThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::executeOnGLThread </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>blockUntilFinished</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a lambda, function or functor on the OpenGL thread with an active context. </p>
<p>This method will attempt to execute functor on the OpenGL thread. If blockUntilFinished is true then the method will block until the functor has finished executing.</p>
<p>This function can only be called if the context is attached to a component. Otherwise, this function will assert.</p>
<p>This function is useful when you need to execute house-keeping tasks such as allocating, deallocating textures or framebuffers. As such, the functor will execute without locking the message thread. Therefore, it is not intended for any drawing commands or GUI code. Any GUI code should be executed in the <a class="el" href="classOpenGLRenderer.html#a34077b4eaeb3207814b9e4302f724912" title="Called when you should render the next openGL frame.">OpenGLRenderer::renderOpenGL</a> callback instead. </p>

<p class="reference">References <a class="el" href="#a48062bbab36b278a5ff95831dc8c333d">executeOnGLThread()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a48062bbab36b278a5ff95831dc8c333d">executeOnGLThread()</a>.</p>

</div>
</div>
<a id="a5ae7fe1aa47448f75ef67f89cd9db798" name="a5ae7fe1aa47448f75ef67f89cd9db798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae7fe1aa47448f75ef67f89cd9db798">&#9670;&#160;</a></span>getRenderingScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OpenGLContext::getRenderingScale </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a scale factor that relates the context component's size to the number of physical pixels it covers on the screen. </p>
<p>In special cases it will be the same as <a class="el" href="structDisplays_1_1Display.html#a611a3fe584fa04e86538866af0e5d788" title="The scale factor of this display.">Displays::Display::scale</a>, but it also includes AffineTransforms that affect the rendered area, and will be correctly reported not just in standalone applications but plugins as well.</p>
<p>Note that this should only be called during an <a class="el" href="classOpenGLRenderer.html#a34077b4eaeb3207814b9e4302f724912" title="Called when you should render the next openGL frame.">OpenGLRenderer::renderOpenGL()</a> callback - at other times the value it returns is undefined. </p>

<p class="reference">References <a class="el" href="#a5ae7fe1aa47448f75ef67f89cd9db798">getRenderingScale()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a5ae7fe1aa47448f75ef67f89cd9db798">getRenderingScale()</a>.</p>

</div>
</div>
<a id="a39b86efe11ffe091002d530d302e14bc" name="a39b86efe11ffe091002d530d302e14bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b86efe11ffe091002d530d302e14bc">&#9670;&#160;</a></span>getFrameBufferID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int OpenGLContext::getFrameBufferID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this context is backed by a frame buffer, this returns its ID number, or 0 if the context does not use a framebuffer. </p>

</div>
</div>
<a id="a1993e86d7de92ade91f14b8023c5ac7c" name="a1993e86d7de92ade91f14b8023c5ac7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1993e86d7de92ade91f14b8023c5ac7c">&#9670;&#160;</a></span>getRawContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * OpenGLContext::getRawContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an OS-dependent handle to some kind of underlying OS-provided GL context. </p>
<p>The exact type of the value returned will depend on the OS and may change if the implementation changes. If you want to use this, digging around in the native code is probably the best way to find out what it is. </p>

<p class="reference">References <a class="el" href="#a1993e86d7de92ade91f14b8023c5ac7c">getRawContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a1993e86d7de92ade91f14b8023c5ac7c">getRawContext()</a>.</p>

</div>
</div>
<a id="a4e0c5f2d071182c599ba4952ca7cb4f2" name="a4e0c5f2d071182c599ba4952ca7cb4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0c5f2d071182c599ba4952ca7cb4f2">&#9670;&#160;</a></span>isCoreProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGLContext::isCoreProfile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this context is using the core profile. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3a6b8eeed7dbc7c7c649528252c07d02" title="OpenGL versions, used by setOpenGLVersionRequired().">OpenGLVersion</a> </dd></dl>

<p class="reference">References <a class="el" href="#a4e0c5f2d071182c599ba4952ca7cb4f2">isCoreProfile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a4e0c5f2d071182c599ba4952ca7cb4f2">isCoreProfile()</a>.</p>

</div>
</div>
<a id="a51e518038caadcdd5899f7e9494d801a" name="a51e518038caadcdd5899f7e9494d801a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e518038caadcdd5899f7e9494d801a">&#9670;&#160;</a></span>copyTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::copyTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>targetClipArea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>anchorPosAndTextureSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>contextWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>contextHeight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>textureOriginIsBottomLeft</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>blend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the currently selected texture into this context at its original size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetClipArea</td><td>the target area to draw into (in top-left origin coords) </td></tr>
    <tr><td class="paramname">anchorPosAndTextureSize</td><td>the position of this rectangle is the texture's top-left anchor position in the target space, and the size must be the total size of the texture. </td></tr>
    <tr><td class="paramname">contextWidth</td><td>the width of the context or framebuffer that is being drawn into, used for scaling of the coordinates. </td></tr>
    <tr><td class="paramname">contextHeight</td><td>the height of the context or framebuffer that is being drawn into, used for vertical flipping of the y coordinates. </td></tr>
    <tr><td class="paramname">textureOriginIsBottomLeft</td><td>if true, the texture's origin is treated as being at (0, 0). If false, it is assumed to be (0, 1) </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="#a51e518038caadcdd5899f7e9494d801a">copyTexture()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a51e518038caadcdd5899f7e9494d801a">copyTexture()</a>.</p>

</div>
</div>
<a id="a1eb85ffda148dac618e28fae654aab0a" name="a1eb85ffda148dac618e28fae654aab0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb85ffda148dac618e28fae654aab0a">&#9670;&#160;</a></span>setImageCacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGLContext::setImageCacheSize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>cacheSizeBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the amount of GPU memory that the internal cache for Images is allowed to use. </p>

<p class="reference">References <a class="el" href="#a1eb85ffda148dac618e28fae654aab0a">setImageCacheSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a1eb85ffda148dac618e28fae654aab0a">setImageCacheSize()</a>.</p>

</div>
</div>
<a id="a370e786a96eac9fa8486eff23ab2da9c" name="a370e786a96eac9fa8486eff23ab2da9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370e786a96eac9fa8486eff23ab2da9c">&#9670;&#160;</a></span>getImageCacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OpenGLContext::getImageCacheSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of GPU memory that the internal cache for Images is allowed to use. </p>

<p class="reference">References <a class="el" href="#a370e786a96eac9fa8486eff23ab2da9c">getImageCacheSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a370e786a96eac9fa8486eff23ab2da9c">getImageCacheSize()</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a3e204724fd78bbc272023525226caad7" name="a3e204724fd78bbc272023525226caad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e204724fd78bbc272023525226caad7">&#9670;&#160;</a></span>extensions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenGLExtensionFunctions OpenGLContext::extensions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This structure holds a set of dynamically loaded GL functions for use on this context. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
