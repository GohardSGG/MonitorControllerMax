<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JUCE: LockingAsyncUpdater Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- main-nav -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classLockingAsyncUpdater-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LockingAsyncUpdater Class Reference<span class="mlabels"><span class="mlabel final">final</span></span><div class="ingroups"><a class="el" href="group__juce__events.html">juce_events</a> &raquo; <a class="el" href="group__juce__events-broadcasters.html">broadcasters</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A bit like an <a class="el" href="classAsyncUpdater.html" title="Has a callback method that is triggered asynchronously.">AsyncUpdater</a>, but guarantees that after <a class="el" href="#a40a4313dc8d7511465a1b5065a4bccc2" title="This will stop any pending updates from happening.">cancelPendingUpdate()</a> returns, the async function will never be called until <a class="el" href="#a52b8d1cc94c432985d94837dc4ecfbaa" title="Causes the callback to be triggered at a later time.">triggerAsyncUpdate()</a> is called again.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab5d1258de86889fef5ad9a0407cd6352" id="r_ab5d1258de86889fef5ad9a0407cd6352"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5d1258de86889fef5ad9a0407cd6352">LockingAsyncUpdater</a> (std::function&lt; void()&gt; callbackToUse)</td></tr>
<tr class="memdesc:ab5d1258de86889fef5ad9a0407cd6352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classLockingAsyncUpdater.html" title="A bit like an AsyncUpdater, but guarantees that after cancelPendingUpdate() returns,...">LockingAsyncUpdater</a> object that will call the provided callback on the main thread when triggered.  <br /></td></tr>
<tr class="memitem:a99603e6c4f92bec6d267f04ba4918c9f" id="r_a99603e6c4f92bec6d267f04ba4918c9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99603e6c4f92bec6d267f04ba4918c9f">LockingAsyncUpdater</a> (<a class="el" href="classLockingAsyncUpdater.html">LockingAsyncUpdater</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a99603e6c4f92bec6d267f04ba4918c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="memitem:a705b191c6d87f12db1b627cc2fe04e0f" id="r_a705b191c6d87f12db1b627cc2fe04e0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLockingAsyncUpdater.html">LockingAsyncUpdater</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a705b191c6d87f12db1b627cc2fe04e0f">operator=</a> (<a class="el" href="classLockingAsyncUpdater.html">LockingAsyncUpdater</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a705b191c6d87f12db1b627cc2fe04e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="memitem:a659888c84fd903a9aae07b9fee0f082f" id="r_a659888c84fd903a9aae07b9fee0f082f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a659888c84fd903a9aae07b9fee0f082f">~LockingAsyncUpdater</a> ()</td></tr>
<tr class="memdesc:a659888c84fd903a9aae07b9fee0f082f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="memitem:a52b8d1cc94c432985d94837dc4ecfbaa" id="r_a52b8d1cc94c432985d94837dc4ecfbaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52b8d1cc94c432985d94837dc4ecfbaa">triggerAsyncUpdate</a> ()</td></tr>
<tr class="memdesc:a52b8d1cc94c432985d94837dc4ecfbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the callback to be triggered at a later time.  <br /></td></tr>
<tr class="memitem:a40a4313dc8d7511465a1b5065a4bccc2" id="r_a40a4313dc8d7511465a1b5065a4bccc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40a4313dc8d7511465a1b5065a4bccc2">cancelPendingUpdate</a> () noexcept</td></tr>
<tr class="memdesc:a40a4313dc8d7511465a1b5065a4bccc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will stop any pending updates from happening.  <br /></td></tr>
<tr class="memitem:a21db62177c203ae34240cf6b8b91d22c" id="r_a21db62177c203ae34240cf6b8b91d22c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21db62177c203ae34240cf6b8b91d22c">handleUpdateNowIfNeeded</a> ()</td></tr>
<tr class="memdesc:a21db62177c203ae34240cf6b8b91d22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an update has been triggered and is pending, this will invoke it synchronously.  <br /></td></tr>
<tr class="memitem:afcb3d7d2ed49c7e253d7d97a1a47aeb0" id="r_afcb3d7d2ed49c7e253d7d97a1a47aeb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcb3d7d2ed49c7e253d7d97a1a47aeb0">isUpdatePending</a> () const noexcept</td></tr>
<tr class="memdesc:afcb3d7d2ed49c7e253d7d97a1a47aeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there's an update callback in the pipeline.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A bit like an <a class="el" href="classAsyncUpdater.html" title="Has a callback method that is triggered asynchronously.">AsyncUpdater</a>, but guarantees that after <a class="el" href="#a40a4313dc8d7511465a1b5065a4bccc2" title="This will stop any pending updates from happening.">cancelPendingUpdate()</a> returns, the async function will never be called until <a class="el" href="#a52b8d1cc94c432985d94837dc4ecfbaa" title="Causes the callback to be triggered at a later time.">triggerAsyncUpdate()</a> is called again. </p>
<p>This is an important guarantee for writing classes with async behaviour that can still be destroyed safely from a background thread.</p>
<p>Note that all of the member functions of this type have a chance of blocking, so this class is unsuitable for broadcasting changes from a realtime thread. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab5d1258de86889fef5ad9a0407cd6352" name="ab5d1258de86889fef5ad9a0407cd6352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d1258de86889fef5ad9a0407cd6352">&#9670;&#160;</a></span>LockingAsyncUpdater() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LockingAsyncUpdater::LockingAsyncUpdater </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;</td>          <td class="paramname"><span class="paramname"><em>callbackToUse</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classLockingAsyncUpdater.html" title="A bit like an AsyncUpdater, but guarantees that after cancelPendingUpdate() returns,...">LockingAsyncUpdater</a> object that will call the provided callback on the main thread when triggered. </p>
<p>Note that the <a class="el" href="classLockingAsyncUpdater.html" title="A bit like an AsyncUpdater, but guarantees that after cancelPendingUpdate() returns,...">LockingAsyncUpdater</a> takes an internal mutex before calling the provided callback. Therefore, in order to avoid deadlocks, you should (ideally) ensure that no locks are taken inside the callbackToUse. If you do need to take a lock inside the callback, make sure that you do not hold the same lock while calling any of the <a class="el" href="classLockingAsyncUpdater.html" title="A bit like an AsyncUpdater, but guarantees that after cancelPendingUpdate() returns,...">LockingAsyncUpdater</a> member functions. </p>

<p class="reference">Referenced by <a class="el" href="#afcb3d7d2ed49c7e253d7d97a1a47aeb0">isUpdatePending()</a>, <a class="el" href="#a99603e6c4f92bec6d267f04ba4918c9f">LockingAsyncUpdater()</a>, and <a class="el" href="#a705b191c6d87f12db1b627cc2fe04e0f">operator=()</a>.</p>

</div>
</div>
<a id="a99603e6c4f92bec6d267f04ba4918c9f" name="a99603e6c4f92bec6d267f04ba4918c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99603e6c4f92bec6d267f04ba4918c9f">&#9670;&#160;</a></span>LockingAsyncUpdater() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LockingAsyncUpdater::LockingAsyncUpdater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLockingAsyncUpdater.html">LockingAsyncUpdater</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

<p class="reference">References <a class="el" href="#ab5d1258de86889fef5ad9a0407cd6352">LockingAsyncUpdater()</a>.</p>

</div>
</div>
<a id="a659888c84fd903a9aae07b9fee0f082f" name="a659888c84fd903a9aae07b9fee0f082f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659888c84fd903a9aae07b9fee0f082f">&#9670;&#160;</a></span>~LockingAsyncUpdater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LockingAsyncUpdater::~LockingAsyncUpdater </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If there are any pending callbacks when the object is deleted, these are lost. The async callback is guaranteed not to be called again once the destructor has completed. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a705b191c6d87f12db1b627cc2fe04e0f" name="a705b191c6d87f12db1b627cc2fe04e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b191c6d87f12db1b627cc2fe04e0f">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLockingAsyncUpdater.html">LockingAsyncUpdater</a> &amp; LockingAsyncUpdater::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLockingAsyncUpdater.html">LockingAsyncUpdater</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

<p class="reference">References <a class="el" href="#ab5d1258de86889fef5ad9a0407cd6352">LockingAsyncUpdater()</a>.</p>

</div>
</div>
<a id="a52b8d1cc94c432985d94837dc4ecfbaa" name="a52b8d1cc94c432985d94837dc4ecfbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b8d1cc94c432985d94837dc4ecfbaa">&#9670;&#160;</a></span>triggerAsyncUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LockingAsyncUpdater::triggerAsyncUpdate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the callback to be triggered at a later time. </p>
<p>This method returns quickly, after which a callback to the handleAsyncUpdate() method will be made by the impl thread as soon as possible.</p>
<p>If an update callback is already pending but hasn't started yet, calling this method will have no effect.</p>
<p>It's thread-safe to call this method from any thread, BUT beware of calling it from a real-time (e.g. audio) thread, because it unconditionally locks a mutex. This may block, e.g. if this is called from a background thread while the async callback is in progress on the main thread. </p>

</div>
</div>
<a id="a40a4313dc8d7511465a1b5065a4bccc2" name="a40a4313dc8d7511465a1b5065a4bccc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a4313dc8d7511465a1b5065a4bccc2">&#9670;&#160;</a></span>cancelPendingUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LockingAsyncUpdater::cancelPendingUpdate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will stop any pending updates from happening. </p>
<p>If a callback is already in progress on another thread, this will block until the callback has finished before returning. </p>

</div>
</div>
<a id="a21db62177c203ae34240cf6b8b91d22c" name="a21db62177c203ae34240cf6b8b91d22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21db62177c203ae34240cf6b8b91d22c">&#9670;&#160;</a></span>handleUpdateNowIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LockingAsyncUpdater::handleUpdateNowIfNeeded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an update has been triggered and is pending, this will invoke it synchronously. </p>
<p>Use this as a kind of "flush" operation - if an update is pending, the handleAsyncUpdate() method will be called immediately; if no update is pending, then nothing will be done.</p>
<p>Because this may invoke the callback, this method must only be called on the main event thread. </p>

<p class="reference">References <a class="el" href="#a21db62177c203ae34240cf6b8b91d22c">handleUpdateNowIfNeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a21db62177c203ae34240cf6b8b91d22c">handleUpdateNowIfNeeded()</a>.</p>

</div>
</div>
<a id="afcb3d7d2ed49c7e253d7d97a1a47aeb0" name="afcb3d7d2ed49c7e253d7d97a1a47aeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb3d7d2ed49c7e253d7d97a1a47aeb0">&#9670;&#160;</a></span>isUpdatePending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LockingAsyncUpdater::isUpdatePending </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there's an update callback in the pipeline. </p>

<p class="reference">References <a class="el" href="#afcb3d7d2ed49c7e253d7d97a1a47aeb0">isUpdatePending()</a>, <a class="el" href="group__juce__core-system.html#ga851b02724a8158a7f746c66b5758b3dd">JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR</a>, and <a class="el" href="#ab5d1258de86889fef5ad9a0407cd6352">LockingAsyncUpdater()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#afcb3d7d2ed49c7e253d7d97a1a47aeb0">isUpdatePending()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
