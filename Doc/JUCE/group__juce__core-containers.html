<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JUCE: containers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- main-nav -->
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">containers <div class="ingroups"><a class="el" href="group__juce__core.html">juce_core</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AbstractFifo" id="r_AbstractFifo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractFifo.html">AbstractFifo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the logic required to implement a lock-free FIFO.  <a href="classAbstractFifo.html#details">More...</a><br /></td></tr>
<tr class="memitem:AbstractFifo_3A_3AScopedReadWrite_3C_20mode_20_3E" id="r_AbstractFifo_3A_3AScopedReadWrite_3C_20mode_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractFifo_1_1ScopedReadWrite.html">AbstractFifo::ScopedReadWrite&lt; mode &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a scoped reader/writer.  <a href="classAbstractFifo_1_1ScopedReadWrite.html#details">More...</a><br /></td></tr>
<tr class="memitem:Array_3C_20ElementType_2C_20TypeOfCriticalSectionToUse_2C_20minimumAllocatedSize_20_3E" id="r_Array_3C_20ElementType_2C_20TypeOfCriticalSectionToUse_2C_20minimumAllocatedSize_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html">Array&lt; ElementType, TypeOfCriticalSectionToUse, minimumAllocatedSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a resizable array of primitive or copy-by-value objects.  <a href="classArray.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArrayAllocationBase_3C_20ElementType_2C_20TypeOfCriticalSectionToUse_20_3E" id="r_ArrayAllocationBase_3C_20ElementType_2C_20TypeOfCriticalSectionToUse_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayAllocationBase.html">ArrayAllocationBase&lt; ElementType, TypeOfCriticalSectionToUse &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements some basic array storage allocation functions.  <a href="classArrayAllocationBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArrayBase_3C_20ElementType_2C_20TypeOfCriticalSectionToUse_20_3E" id="r_ArrayBase_3C_20ElementType_2C_20TypeOfCriticalSectionToUse_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayBase.html">ArrayBase&lt; ElementType, TypeOfCriticalSectionToUse &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic object container.  <a href="classArrayBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicObject" id="r_DynamicObject"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynamicObject.html">DynamicObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a dynamically implemented object.  <a href="classDynamicObject.html#details">More...</a><br /></td></tr>
<tr class="memitem:DefaultElementComparator_3C_20ElementType_20_3E" id="r_DefaultElementComparator_3C_20ElementType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDefaultElementComparator.html">DefaultElementComparator&lt; ElementType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple ElementComparator class that can be used to sort an array of objects that support the '&lt;' operator.  <a href="classDefaultElementComparator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Enumerated_3C_20Index_2C_20Value_20_3E" id="r_Enumerated_3C_20Index_2C_20Value_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEnumerated.html">Enumerated&lt; Index, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned when dereferencing an <a class="el" href="classEnumerateIterator.html" title="An iterator that wraps some other iterator, keeping track of the relative position of that iterator b...">EnumerateIterator</a>.  <a href="structEnumerated.html#details">More...</a><br /></td></tr>
<tr class="memitem:EnumerateIterator_3C_20Iter_2C_20Index_20_3E" id="r_EnumerateIterator_3C_20Iter_2C_20Index_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEnumerateIterator.html">EnumerateIterator&lt; Iter, Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that wraps some other iterator, keeping track of the relative position of that iterator based on calls to arithmetic operators such as <a class="el" href="classEnumerateIterator.html#af790e993ecafcb04b06bb211c39a68dc" title="Increments the iterator and the index.">operator++()</a>, <a class="el" href="classEnumerateIterator.html#a61da931f2c68c74ad2b3e85467fd1dd6" title="Decrements the iterator and the index.">operator--()</a>, <a class="el" href="classEnumerateIterator.html#ab61c70044de8361c7364e7a38ff2e8bf" title="Returns the result of adding an integral value to this iterator.">operator+()</a>, and <a class="el" href="classEnumerateIterator.html#a3c6ef7394a3d53e7dea16661cca9db69" title="Subtracts another enumerate iterator from this one, producing the same result as subtracting the two ...">operator-()</a>.  <a href="classEnumerateIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:IteratorPair_3C_20Begin_2C_20End_20_3E" id="r_IteratorPair_3C_20Begin_2C_20End_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorPair.html">IteratorPair&lt; Begin, End &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a pair of iterators, providing member <a class="el" href="classIteratorPair.html#a4d122eca12d030b59488f57fee3b8242" title="Returns the begin iterator.">begin()</a> and <a class="el" href="classIteratorPair.html#a8028b8e715c4067a9c2753ca6d4b188c" title="Returns the end iterator.">end()</a> functions that return those iterators.  <a href="classIteratorPair.html#details">More...</a><br /></td></tr>
<tr class="memitem:FixedSizeFunction_3C_20len_2C_20Ret_28Args_2E_2E_2E_29_3E" id="r_FixedSizeFunction_3C_20len_2C_20Ret_28Args_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFixedSizeFunction_3_01len_00_01Ret_07Args_8_8_8_08_4.html">FixedSizeFunction&lt; len, Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type similar to <span class="tt">std::function</span> that holds a callable object.  <a href="classFixedSizeFunction_3_01len_00_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:DefaultHashFunctions" id="r_DefaultHashFunctions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDefaultHashFunctions.html">DefaultHashFunctions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class to generate hash functions for some primitive types, intended for use with the <a class="el" href="classHashMap.html" title="Holds a set of mappings between some key/value pairs.">HashMap</a> class.  <a href="structDefaultHashFunctions.html#details">More...</a><br /></td></tr>
<tr class="memitem:HashMap_3C_20KeyType_2C_20ValueType_2C_20HashFunctionType_2C_20TypeOfCriticalSectionToUse_20_3E" id="r_HashMap_3C_20KeyType_2C_20ValueType_2C_20HashFunctionType_2C_20TypeOfCriticalSectionToUse_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHashMap.html">HashMap&lt; KeyType, ValueType, HashFunctionType, TypeOfCriticalSectionToUse &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a set of mappings between some key/value pairs.  <a href="classHashMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:HashMap_3C_20KeyType_2C_20ValueType_2C_20HashFunctionType_2C_20TypeOfCriticalSectionToUse_20_3E_3A_3AIterator" id="r_HashMap_3C_20KeyType_2C_20ValueType_2C_20HashFunctionType_2C_20TypeOfCriticalSectionToUse_20_3E_3A_3AIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHashMap_1_1Iterator.html">HashMap&lt; KeyType, ValueType, HashFunctionType, TypeOfCriticalSectionToUse &gt;::Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the items in a <a class="el" href="classHashMap.html" title="Holds a set of mappings between some key/value pairs.">HashMap</a>.  <a href="structHashMap_1_1Iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinkedListPointer_3C_20ObjectType_20_3E" id="r_LinkedListPointer_3C_20ObjectType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedListPointer.html">LinkedListPointer&lt; ObjectType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to manipulate singly-linked lists of objects.  <a href="classLinkedListPointer.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinkedListPointer_3C_20ObjectType_20_3E_3A_3AAppender" id="r_LinkedListPointer_3C_20ObjectType_20_3E_3A_3AAppender"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedListPointer_1_1Appender.html">LinkedListPointer&lt; ObjectType &gt;::Appender</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows efficient repeated insertions into a list.  <a href="classLinkedListPointer_1_1Appender.html#details">More...</a><br /></td></tr>
<tr class="memitem:ListenerList_3C_20ListenerClass_2C_20ArrayType_20_3E" id="r_ListenerList_3C_20ListenerClass_2C_20ArrayType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classListenerList.html">ListenerList&lt; ListenerClass, ArrayType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a set of objects and can invoke a member function callback on each object in the set with a single call.  <a href="classListenerList.html#details">More...</a><br /></td></tr>
<tr class="memitem:ListenerList_3C_20ListenerClass_2C_20ArrayType_20_3E_3A_3ADummyBailOutChecker" id="r_ListenerList_3C_20ListenerClass_2C_20ArrayType_20_3E_3A_3ADummyBailOutChecker"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structListenerList_1_1DummyBailOutChecker.html">ListenerList&lt; ListenerClass, ArrayType &gt;::DummyBailOutChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy bail-out checker that always returns false.  <a href="structListenerList_1_1DummyBailOutChecker.html#details">More...</a><br /></td></tr>
<tr class="memitem:LightweightListenerList_3C_20ListenerClass_20_3E" id="r_LightweightListenerList_3C_20ListenerClass_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLightweightListenerList.html">LightweightListenerList&lt; ListenerClass &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight version of the <a class="el" href="classListenerList.html" title="Holds a set of objects and can invoke a member function callback on each object in the set with a sin...">ListenerList</a> that doesn't provide any guarantees when mutating the list from a callback, but allows callbacks to be triggered concurrently without a mutex.  <a href="classLightweightListenerList.html#details">More...</a><br /></td></tr>
<tr class="memitem:NamedValueSet" id="r_NamedValueSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNamedValueSet.html">NamedValueSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a set of named var objects.  <a href="classNamedValueSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:NamedValueSet_3A_3ANamedValue" id="r_NamedValueSet_3A_3ANamedValue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNamedValueSet_1_1NamedValue.html">NamedValueSet::NamedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for a named var object.  <a href="structNamedValueSet_1_1NamedValue.html#details">More...</a><br /></td></tr>
<tr class="memitem:Optional_3C_20Value_20_3E" id="r_Optional_3C_20Value_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptional.html">Optional&lt; Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple optional type.  <a href="classOptional.html#details">More...</a><br /></td></tr>
<tr class="memitem:OwnedArray_3C_20ObjectClass_2C_20TypeOfCriticalSectionToUse_20_3E" id="r_OwnedArray_3C_20ObjectClass_2C_20TypeOfCriticalSectionToUse_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOwnedArray.html">OwnedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array designed for holding objects.  <a href="classOwnedArray.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropertySet" id="r_PropertySet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPropertySet.html">PropertySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of named property values, which can be strings, integers, floating point, etc.  <a href="classPropertySet.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReferenceCountedArray_3C_20ObjectClass_2C_20TypeOfCriticalSectionToUse_20_3E" id="r_ReferenceCountedArray_3C_20ObjectClass_2C_20TypeOfCriticalSectionToUse_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReferenceCountedArray.html">ReferenceCountedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a list of objects derived from <a class="el" href="classReferenceCountedObject.html" title="A base class which provides methods for reference-counting.">ReferenceCountedObject</a>, or which implement basic reference-count handling methods.  <a href="classReferenceCountedArray.html#details">More...</a><br /></td></tr>
<tr class="memitem:ScopedValueSetter_3C_20ValueType_20_3E" id="r_ScopedValueSetter_3C_20ValueType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScopedValueSetter.html">ScopedValueSetter&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class providing an RAII-based mechanism for temporarily setting and then re-setting a value.  <a href="classScopedValueSetter.html#details">More...</a><br /></td></tr>
<tr class="memitem:SingleThreadedAbstractFifo" id="r_SingleThreadedAbstractFifo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSingleThreadedAbstractFifo.html">SingleThreadedAbstractFifo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the logic for a single-threaded FIFO.  <a href="classSingleThreadedAbstractFifo.html#details">More...</a><br /></td></tr>
<tr class="memitem:SortedSet_3C_20ElementType_2C_20TypeOfCriticalSectionToUse_20_3E" id="r_SortedSet_3C_20ElementType_2C_20TypeOfCriticalSectionToUse_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSortedSet.html">SortedSet&lt; ElementType, TypeOfCriticalSectionToUse &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a set of unique primitive objects, such as ints or doubles.  <a href="classSortedSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:Span_3C_20Value_2C_20Extent_20_3E" id="r_Span_3C_20Value_2C_20Extent_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpan.html">Span&lt; Value, Extent &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning view over contiguous objects stored in an <a class="el" href="classArray.html" title="Holds a resizable array of primitive or copy-by-value objects.">Array</a> or vector or other similar container.  <a href="classSpan.html#details">More...</a><br /></td></tr>
<tr class="memitem:SparseSet_3C_20Type_20_3E" id="r_SparseSet_3C_20Type_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseSet.html">SparseSet&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a set of primitive values, storing them as a set of ranges.  <a href="classSparseSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:var" id="r_var"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvar.html">var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant class, that can be used to hold a range of primitive values.  <a href="classvar.html#details">More...</a><br /></td></tr>
<tr class="memitem:var_3A_3ANativeFunctionArgs" id="r_var_3A_3ANativeFunctionArgs"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvar_1_1NativeFunctionArgs.html">var::NativeFunctionArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is passed to a <a class="el" href="classvar.html#ae639f9a33534812a529a97740682d992">NativeFunction</a> callback, and contains invocation details about the function's arguments and context.  <a href="structvar_1_1NativeFunctionArgs.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6a8e60aa22d333c4267596d60b9b3f28" id="r_ga6a8e60aa22d333c4267596d60b9b3f28"><td class="memTemplParams" colspan="2">template&lt;typename ListenerClass&gt; </td></tr>
<tr class="memitem:ga6a8e60aa22d333c4267596d60b9b3f28 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6a8e60aa22d333c4267596d60b9b3f28">ThreadSafeListenerList</a> = <a class="el" href="classListenerList.html">ListenerList</a>&lt;ListenerClass, <a class="el" href="classArray.html">Array</a>&lt;ListenerClass*, <a class="el" href="classCriticalSection.html">CriticalSection</a>&gt;&gt;</td></tr>
<tr class="memdesc:ga6a8e60aa22d333c4267596d60b9b3f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread safe version of the <a class="el" href="classListenerList.html" title="Holds a set of objects and can invoke a member function callback on each object in the set with a sin...">ListenerList</a> class.  <br /></td></tr>
<tr class="memitem:ga354378e9f7923b562fc44b40d3eba90c" id="r_ga354378e9f7923b562fc44b40d3eba90c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga354378e9f7923b562fc44b40d3eba90c">Nullopt</a> = std::nullopt_t</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab86cb3a5b2c630c394c580435f00d77c" id="r_gab86cb3a5b2c630c394c580435f00d77c"><td class="memTemplParams" colspan="2">template&lt;typename Begin, typename End = Begin&gt; </td></tr>
<tr class="memitem:gab86cb3a5b2c630c394c580435f00d77c template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab86cb3a5b2c630c394c580435f00d77c">makeRange</a> (Begin <a class="el" href="group__juce__core-files.html#ga3b8789907a46172ef0bdc8f656d6e355">begin</a>, End <a class="el" href="group__juce__core-files.html#ga4a3194f4f741f9bd653f28733358f62c">end</a>)</td></tr>
<tr class="memdesc:gab86cb3a5b2c630c394c580435f00d77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two iterators "begin" and "end", returns an <a class="el" href="classIteratorPair.html" title="Wraps a pair of iterators, providing member begin() and end() functions that return those iterators.">IteratorPair</a> with a member <a class="el" href="group__juce__core-files.html#ga3b8789907a46172ef0bdc8f656d6e355" title="Returns the iterator that was passed in.">begin()</a> and <a class="el" href="group__juce__core-files.html#ga4a3194f4f741f9bd653f28733358f62c" title="Returns a default-constructed sentinel value.">end()</a> function.  <br /></td></tr>
<tr class="memitem:gafe18946de9cd3ac00812deaa8e52ccc8" id="r_gafe18946de9cd3ac00812deaa8e52ccc8"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classRange.html">Range</a>, typename Index = detail::withAdlSize::AdlSignedSize&lt;Range&gt;&gt; </td></tr>
<tr class="memitem:gafe18946de9cd3ac00812deaa8e52ccc8 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe18946de9cd3ac00812deaa8e52ccc8">enumerate</a> (<a class="el" href="classRange.html">Range</a> &amp;&amp;range, Index startingValue={})</td></tr>
<tr class="memdesc:gafe18946de9cd3ac00812deaa8e52ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a range and an optional starting offset, returns an <a class="el" href="classIteratorPair.html" title="Wraps a pair of iterators, providing member begin() and end() functions that return those iterators.">IteratorPair</a> that holds EnumerateIterators wrapping the <a class="el" href="group__juce__core-files.html#ga3b8789907a46172ef0bdc8f656d6e355" title="Returns the iterator that was passed in.">begin()</a> and <a class="el" href="group__juce__core-files.html#ga4a3194f4f741f9bd653f28733358f62c" title="Returns a default-constructed sentinel value.">end()</a> of the range.  <br /></td></tr>
<tr class="memitem:gab8b7408d41348ffab3d2c8aa9cf53258" id="r_gab8b7408d41348ffab3d2c8aa9cf53258"><td class="memTemplParams" colspan="2">template&lt;size_t len, typename T&gt; </td></tr>
<tr class="memitem:gab8b7408d41348ffab3d2c8aa9cf53258 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab8b7408d41348ffab3d2c8aa9cf53258">operator!=</a> (const FixedSizeFunction&lt; len, T &gt; &amp;fn, std::nullptr_t)</td></tr>
<tr class="memitem:ga66ba356687a5d566e11a381ebe6ce2e6" id="r_ga66ba356687a5d566e11a381ebe6ce2e6"><td class="memTemplParams" colspan="2">template&lt;size_t len, typename T&gt; </td></tr>
<tr class="memitem:ga66ba356687a5d566e11a381ebe6ce2e6 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga66ba356687a5d566e11a381ebe6ce2e6">operator!=</a> (std::nullptr_t, const FixedSizeFunction&lt; len, T &gt; &amp;fn)</td></tr>
<tr class="memitem:ga4c0522132293ec361092ba074ff180c1" id="r_ga4c0522132293ec361092ba074ff180c1"><td class="memTemplParams" colspan="2">template&lt;size_t len, typename T&gt; </td></tr>
<tr class="memitem:ga4c0522132293ec361092ba074ff180c1 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4c0522132293ec361092ba074ff180c1">operator==</a> (const FixedSizeFunction&lt; len, T &gt; &amp;fn, std::nullptr_t)</td></tr>
<tr class="memitem:gac6f3be21f1d69cdaaa8bd4760639788e" id="r_gac6f3be21f1d69cdaaa8bd4760639788e"><td class="memTemplParams" colspan="2">template&lt;size_t len, typename T&gt; </td></tr>
<tr class="memitem:gac6f3be21f1d69cdaaa8bd4760639788e template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6f3be21f1d69cdaaa8bd4760639788e">operator==</a> (std::nullptr_t, const FixedSizeFunction&lt; len, T &gt; &amp;fn)</td></tr>
<tr class="memitem:gaac35c5c266b29f529de20dccdcd26fa6" id="r_gaac35c5c266b29f529de20dccdcd26fa6"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classValue.html">Value</a>&gt; </td></tr>
<tr class="memitem:gaac35c5c266b29f529de20dccdcd26fa6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOptional.html">Optional</a>&lt; std::decay_t&lt; <a class="el" href="classValue.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac35c5c266b29f529de20dccdcd26fa6">makeOptional</a> (<a class="el" href="classValue.html">Value</a> &amp;&amp;v)</td></tr>
<tr class="memitem:gab1fd5a52bf9cdcb373becc550ef04a1d" id="r_gab1fd5a52bf9cdcb373becc550ef04a1d"><td class="memTemplParams" colspan="2">template&lt;typename T, typename End&gt; </td></tr>
<tr class="memitem:gab1fd5a52bf9cdcb373becc550ef04a1d template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1fd5a52bf9cdcb373becc550ef04a1d">Span</a> (T, End) -&gt; Span&lt; std::remove_pointer_t&lt; decltype(detail::toAddress(std::declval&lt; T &gt;()))&gt; &gt;</td></tr>
<tr class="memitem:ga812ef2cb5add31d1b5bbc02f55bc5ace" id="r_ga812ef2cb5add31d1b5bbc02f55bc5ace"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N&gt; </td></tr>
<tr class="memitem:ga812ef2cb5add31d1b5bbc02f55bc5ace template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga812ef2cb5add31d1b5bbc02f55bc5ace">Span</a> (T(&amp;)[N]) -&gt; Span&lt; T, N &gt;</td></tr>
<tr class="memitem:gaba9175593b8b59c462e846730fe6d92f" id="r_gaba9175593b8b59c462e846730fe6d92f"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N&gt; </td></tr>
<tr class="memitem:gaba9175593b8b59c462e846730fe6d92f template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaba9175593b8b59c462e846730fe6d92f">Span</a> (std::array&lt; T, N &gt; &amp;) -&gt; Span&lt; T, N &gt;</td></tr>
<tr class="memitem:gad5e4583a004791de2d963fb1df3e5ca4" id="r_gad5e4583a004791de2d963fb1df3e5ca4"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N&gt; </td></tr>
<tr class="memitem:gad5e4583a004791de2d963fb1df3e5ca4 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad5e4583a004791de2d963fb1df3e5ca4">Span</a> (const std::array&lt; T, N &gt; &amp;) -&gt; Span&lt; const T, N &gt;</td></tr>
<tr class="memitem:gadfa72dc09a575cc75cd678e3b86d6d45" id="r_gadfa72dc09a575cc75cd678e3b86d6d45"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classRange.html">Range</a>&gt; </td></tr>
<tr class="memitem:gadfa72dc09a575cc75cd678e3b86d6d45 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadfa72dc09a575cc75cd678e3b86d6d45">Span</a> (<a class="el" href="classRange.html">Range</a> &amp;&amp;r) -&gt; Span&lt; std::remove_pointer_t&lt; decltype(std::data(r))&gt; &gt;</td></tr>
<tr class="memitem:ga360b996ba555a2333b467dd6edc8c11f" id="r_ga360b996ba555a2333b467dd6edc8c11f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga360b996ba555a2333b467dd6edc8c11f">operator==</a> (const <a class="el" href="classvar.html">var</a> &amp;, const <a class="el" href="classvar.html">var</a> &amp;)</td></tr>
<tr class="memdesc:ga360b996ba555a2333b467dd6edc8c11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison.  <br /></td></tr>
<tr class="memitem:ga4f872257dd6891ae4516b9b630f745fe" id="r_ga4f872257dd6891ae4516b9b630f745fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4f872257dd6891ae4516b9b630f745fe">operator!=</a> (const <a class="el" href="classvar.html">var</a> &amp;, const <a class="el" href="classvar.html">var</a> &amp;)</td></tr>
<tr class="memdesc:ga4f872257dd6891ae4516b9b630f745fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison.  <br /></td></tr>
<tr class="memitem:gafafdd2084fbdd9e82f73c09626b21018" id="r_gafafdd2084fbdd9e82f73c09626b21018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafafdd2084fbdd9e82f73c09626b21018">operator&lt;</a> (const <a class="el" href="classvar.html">var</a> &amp;, const <a class="el" href="classvar.html">var</a> &amp;)</td></tr>
<tr class="memdesc:gafafdd2084fbdd9e82f73c09626b21018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison.  <br /></td></tr>
<tr class="memitem:ga1e5668d556386876c10e47acb74ea4c9" id="r_ga1e5668d556386876c10e47acb74ea4c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1e5668d556386876c10e47acb74ea4c9">operator&lt;=</a> (const <a class="el" href="classvar.html">var</a> &amp;, const <a class="el" href="classvar.html">var</a> &amp;)</td></tr>
<tr class="memdesc:ga1e5668d556386876c10e47acb74ea4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison.  <br /></td></tr>
<tr class="memitem:gad14f3cd2b038f462293ce642f46ee5f7" id="r_gad14f3cd2b038f462293ce642f46ee5f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad14f3cd2b038f462293ce642f46ee5f7">operator&gt;</a> (const <a class="el" href="classvar.html">var</a> &amp;, const <a class="el" href="classvar.html">var</a> &amp;)</td></tr>
<tr class="memdesc:gad14f3cd2b038f462293ce642f46ee5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison.  <br /></td></tr>
<tr class="memitem:ga689d9eaaf33a1dbc9b1a8a14b1d0c43c" id="r_ga689d9eaaf33a1dbc9b1a8a14b1d0c43c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga689d9eaaf33a1dbc9b1a8a14b1d0c43c">operator&gt;=</a> (const <a class="el" href="classvar.html">var</a> &amp;, const <a class="el" href="classvar.html">var</a> &amp;)</td></tr>
<tr class="memdesc:ga689d9eaaf33a1dbc9b1a8a14b1d0c43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison.  <br /></td></tr>
<tr class="memitem:ga8512deaef9b5f1f12a8a45403a72e508" id="r_ga8512deaef9b5f1f12a8a45403a72e508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8512deaef9b5f1f12a8a45403a72e508">operator==</a> (const <a class="el" href="classvar.html">var</a> &amp;, const <a class="el" href="classString.html">String</a> &amp;)</td></tr>
<tr class="memitem:ga4672f12ca2fdc31e9ca7188101d35a95" id="r_ga4672f12ca2fdc31e9ca7188101d35a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4672f12ca2fdc31e9ca7188101d35a95">operator!=</a> (const <a class="el" href="classvar.html">var</a> &amp;, const <a class="el" href="classString.html">String</a> &amp;)</td></tr>
<tr class="memitem:ga48fb19d379d327812bd68823c7ccf694" id="r_ga48fb19d379d327812bd68823c7ccf694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga48fb19d379d327812bd68823c7ccf694">operator==</a> (const <a class="el" href="classvar.html">var</a> &amp;, const char *)</td></tr>
<tr class="memitem:ga5be7dbc7fd3b5935ad0aca0d8d39e425" id="r_ga5be7dbc7fd3b5935ad0aca0d8d39e425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5be7dbc7fd3b5935ad0aca0d8d39e425">operator!=</a> (const <a class="el" href="classvar.html">var</a> &amp;, const char *)</td></tr>
<tr class="memitem:gab3787616ae5ae65a64ac0a706e348a7c" id="r_gab3787616ae5ae65a64ac0a706e348a7c"><td class="memTemplParams" colspan="2">template&lt;typename ElementComparator, typename TargetValueType&gt; </td></tr>
<tr class="memitem:gab3787616ae5ae65a64ac0a706e348a7c template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab3787616ae5ae65a64ac0a706e348a7c">Array&lt; ElementType, TypeOfCriticalSectionToUse, minimumAllocatedSize &gt;::indexOfSorted</a> (ElementComparator &amp;comparator, TargetValueType elementToLookFor) const</td></tr>
<tr class="memdesc:gab3787616ae5ae65a64ac0a706e348a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of an element in the array, assuming that the array is sorted.  <br /></td></tr>
<tr class="memitem:ga526081df81183ddd47f9f514de483a8f" id="r_ga526081df81183ddd47f9f514de483a8f"><td class="memTemplParams" colspan="2">template&lt;class ElementComparator&gt; </td></tr>
<tr class="memitem:ga526081df81183ddd47f9f514de483a8f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga526081df81183ddd47f9f514de483a8f">Array&lt; ElementType, TypeOfCriticalSectionToUse, minimumAllocatedSize &gt;::sort</a> (ElementComparator &amp;comparator, bool retainOrderOfEquivalentItems=false)</td></tr>
<tr class="memdesc:ga526081df81183ddd47f9f514de483a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the array.  <br /></td></tr>
<tr class="memitem:ga3362aa46fe920b22b20ccc313bfe3366" id="r_ga3362aa46fe920b22b20ccc313bfe3366"><td class="memTemplParams" colspan="2">template&lt;class ElementComparator&gt; </td></tr>
<tr class="memitem:ga3362aa46fe920b22b20ccc313bfe3366 template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3362aa46fe920b22b20ccc313bfe3366">OwnedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::addSorted</a> (ElementComparator &amp;comparator, ObjectClass *newObject) noexcept</td></tr>
<tr class="memdesc:ga3362aa46fe920b22b20ccc313bfe3366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new object into the array assuming that the array is sorted.  <br /></td></tr>
<tr class="memitem:ga7ebb5f9e4bed3ffd0d5a4e980c77260b" id="r_ga7ebb5f9e4bed3ffd0d5a4e980c77260b"><td class="memTemplParams" colspan="2">template&lt;typename ElementComparator&gt; </td></tr>
<tr class="memitem:ga7ebb5f9e4bed3ffd0d5a4e980c77260b template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7ebb5f9e4bed3ffd0d5a4e980c77260b">OwnedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::indexOfSorted</a> (ElementComparator &amp;comparator, const ObjectClass *objectToLookFor) const noexcept</td></tr>
<tr class="memdesc:ga7ebb5f9e4bed3ffd0d5a4e980c77260b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of an object in the array, assuming that the array is sorted.  <br /></td></tr>
<tr class="memitem:ga9ed6587acb285ae967dcce7608af95ad" id="r_ga9ed6587acb285ae967dcce7608af95ad"><td class="memTemplParams" colspan="2">template&lt;class ElementComparator&gt; </td></tr>
<tr class="memitem:ga9ed6587acb285ae967dcce7608af95ad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9ed6587acb285ae967dcce7608af95ad">OwnedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::sort</a> (ElementComparator &amp;comparator, bool retainOrderOfEquivalentItems=false) noexcept</td></tr>
<tr class="memdesc:ga9ed6587acb285ae967dcce7608af95ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the array.  <br /></td></tr>
<tr class="memitem:gae6ed5a2756f413f59ce87a6455cf7dbd" id="r_gae6ed5a2756f413f59ce87a6455cf7dbd"><td class="memTemplParams" colspan="2">template&lt;class ElementComparator&gt; </td></tr>
<tr class="memitem:gae6ed5a2756f413f59ce87a6455cf7dbd template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6ed5a2756f413f59ce87a6455cf7dbd">ReferenceCountedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::indexOfSorted</a> (ElementComparator &amp;comparator, const ObjectClass *objectToLookFor) const noexcept</td></tr>
<tr class="memdesc:gae6ed5a2756f413f59ce87a6455cf7dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of an object in the array, assuming that the array is sorted.  <br /></td></tr>
<tr class="memitem:ga3b913b02e04ad29a6881ab4034c0f0f5" id="r_ga3b913b02e04ad29a6881ab4034c0f0f5"><td class="memTemplParams" colspan="2">template&lt;class ElementComparator&gt; </td></tr>
<tr class="memitem:ga3b913b02e04ad29a6881ab4034c0f0f5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b913b02e04ad29a6881ab4034c0f0f5">ReferenceCountedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::sort</a> (ElementComparator &amp;comparator, bool retainOrderOfEquivalentItems=false) noexcept</td></tr>
<tr class="memdesc:ga3b913b02e04ad29a6881ab4034c0f0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the array.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gacd293644b847dc4549de80a090d66625" id="r_gacd293644b847dc4549de80a090d66625"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd293644b847dc4549de80a090d66625">nullopt</a> = std::nullopt</td></tr>
<tr class="memitem:ga396d97a60bce38d4e287895df5edd520" id="r_ga396d97a60bce38d4e287895df5edd520"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga396d97a60bce38d4e287895df5edd520">dynamicExtent</a> = std::numeric_limits&lt;size_t&gt;::max()</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga6a8e60aa22d333c4267596d60b9b3f28" name="ga6a8e60aa22d333c4267596d60b9b3f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8e60aa22d333c4267596d60b9b3f28">&#9670;&#160;</a></span>ThreadSafeListenerList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ListenerClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga6a8e60aa22d333c4267596d60b9b3f28">ThreadSafeListenerList</a> = <a class="el" href="classListenerList.html">ListenerList</a>&lt;ListenerClass, <a class="el" href="classArray.html">Array</a>&lt;ListenerClass*, <a class="el" href="classCriticalSection.html">CriticalSection</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A thread safe version of the <a class="el" href="classListenerList.html" title="Holds a set of objects and can invoke a member function callback on each object in the set with a sin...">ListenerList</a> class. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classListenerList.html" title="Holds a set of objects and can invoke a member function callback on each object in the set with a sin...">ListenerList</a>, <a class="el" href="classLightweightListenerList.html" title="A lightweight version of the ListenerList that doesn&#39;t provide any guarantees when mutating the list ...">LightweightListenerList</a> </dd></dl>

</div>
</div>
<a id="ga354378e9f7923b562fc44b40d3eba90c" name="ga354378e9f7923b562fc44b40d3eba90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga354378e9f7923b562fc44b40d3eba90c">&#9670;&#160;</a></span>Nullopt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga354378e9f7923b562fc44b40d3eba90c">Nullopt</a> = std::nullopt_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gab86cb3a5b2c630c394c580435f00d77c" name="gab86cb3a5b2c630c394c580435f00d77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab86cb3a5b2c630c394c580435f00d77c">&#9670;&#160;</a></span>makeRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Begin, typename End = Begin&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto makeRange </td>
          <td>(</td>
          <td class="paramtype">Begin</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">End</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two iterators "begin" and "end", returns an <a class="el" href="classIteratorPair.html" title="Wraps a pair of iterators, providing member begin() and end() functions that return those iterators.">IteratorPair</a> with a member <a class="el" href="group__juce__core-files.html#ga3b8789907a46172ef0bdc8f656d6e355" title="Returns the iterator that was passed in.">begin()</a> and <a class="el" href="group__juce__core-files.html#ga4a3194f4f741f9bd653f28733358f62c" title="Returns a default-constructed sentinel value.">end()</a> function. </p>
<p>This pair can be used in contexts that expect an iterable range, the most significant of which is ranged-for loops. This automatically deduces the Begin and End types, so it is more concise to use than directly calling the <a class="el" href="classIteratorPair.html" title="Wraps a pair of iterators, providing member begin() and end() functions that return those iterators.">IteratorPair</a> constructor. </p>

<p class="reference">References <a class="el" href="group__juce__core-files.html#ga3b8789907a46172ef0bdc8f656d6e355">begin()</a>, and <a class="el" href="group__juce__core-files.html#ga4a3194f4f741f9bd653f28733358f62c">end()</a>.</p>

</div>
</div>
<a id="gafe18946de9cd3ac00812deaa8e52ccc8" name="gafe18946de9cd3ac00812deaa8e52ccc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe18946de9cd3ac00812deaa8e52ccc8">&#9670;&#160;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classRange.html">Range</a>, typename Index = detail::withAdlSize::AdlSignedSize&lt;Range&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRange.html">Range</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>startingValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a range and an optional starting offset, returns an <a class="el" href="classIteratorPair.html" title="Wraps a pair of iterators, providing member begin() and end() functions that return those iterators.">IteratorPair</a> that holds EnumerateIterators wrapping the <a class="el" href="group__juce__core-files.html#ga3b8789907a46172ef0bdc8f656d6e355" title="Returns the iterator that was passed in.">begin()</a> and <a class="el" href="group__juce__core-files.html#ga4a3194f4f741f9bd653f28733358f62c" title="Returns a default-constructed sentinel value.">end()</a> of the range. </p>
<p>This is useful in situations where you need to iterate some range, but also query the position of each item in the range.</p>
<p>A simple usage might look like this:</p>
<div class="fragment"><div class="line">std::list&lt;int&gt; elements { 10, 20, 30, 40, 50 };</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pair : <a class="code hl_function" href="#gafe18946de9cd3ac00812deaa8e52ccc8">enumerate</a> (elements))</div>
<div class="line">    std::cout &lt;&lt; pair.index &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; pair.value &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// output: 0 10 1 20 2 30 3 40 4 50</span></div>
<div class="ttc" id="agroup__juce__core-containers_html_gafe18946de9cd3ac00812deaa8e52ccc8"><div class="ttname"><a href="#gafe18946de9cd3ac00812deaa8e52ccc8">enumerate</a></div><div class="ttdeci">constexpr auto enumerate(Range &amp;&amp;range, Index startingValue={})</div><div class="ttdoc">Given a range and an optional starting offset, returns an IteratorPair that holds EnumerateIterators ...</div><div class="ttdef"><b>Definition</b> juce_Enumerate.h:436</div></div>
</div><!-- fragment --><p>You can also use structured bindings to concisely destructure each <a class="el" href="structEnumerated.html" title="Returned when dereferencing an EnumerateIterator.">Enumerated</a> instance:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> [index, value] : <a class="code hl_function" href="#gafe18946de9cd3ac00812deaa8e52ccc8">enumerate</a> (elements))</div>
<div class="line">    std::cout &lt;&lt; index &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; value &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
</div><!-- fragment --><p>Note that the <a class="el" href="structEnumerated.html" title="Returned when dereferencing an EnumerateIterator.">Enumerated</a> instance is returned by value. This is because each <a class="el" href="structEnumerated.html" title="Returned when dereferencing an EnumerateIterator.">Enumerated</a> instance is created on-demand when the iterator is dereferenced. As a result, the following will result in a dangling reference, and will probably trigger a compiler warning:</p>
<div class="fragment"><div class="line"><span class="comment">// BAD IDEA: creating a reference to a temporary Enumerated instance</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; [index, value] : <a class="code hl_function" href="#gafe18946de9cd3ac00812deaa8e52ccc8">enumerate</a> (elements))</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>The 'value' member of <a class="el" href="structEnumerated.html" title="Returned when dereferencing an EnumerateIterator.">Enumerated</a> automatically assumes the same type as dereferencing the wrapped iterator, which is normally a reference to an element of a container. In the following snippet, the type of '[index, value]' is 'const <a class="el" href="structEnumerated.html" title="Returned when dereferencing an EnumerateIterator.">Enumerated&lt;ptrdiff_t, int&amp;&gt;</a>', the type of 'index' is 'ptrdiff_t', and the type of 'value' is 'int&amp;'.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; elements { 10, 20, 30, 40, 50 };</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> [index, value] : <a class="code hl_function" href="#gafe18946de9cd3ac00812deaa8e52ccc8">enumerate</a> (elements))</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>By default, the constness of pair.value will match the constness of the range passed to enumerate. If you pass a mutable lvalue reference to enumerate, then each value will also be mutable. If you pass a constant lvalue reference to enumerate, then each value will be const. If you know that you don't need the iterated elements to be mutable, it's good practice to wrap the range with std::as_const before passing it to enumerate:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> [index, value] : <a class="code hl_function" href="#gafe18946de9cd3ac00812deaa8e52ccc8">enumerate</a> (std::as_const (elements)))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// value is immutable here</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gab8b7408d41348ffab3d2c8aa9cf53258" name="gab8b7408d41348ffab3d2c8aa9cf53258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8b7408d41348ffab3d2c8aa9cf53258">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t len, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const FixedSizeFunction&lt; len, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga66ba356687a5d566e11a381ebe6ce2e6" name="ga66ba356687a5d566e11a381ebe6ce2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66ba356687a5d566e11a381ebe6ce2e6">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t len, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FixedSizeFunction&lt; len, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4c0522132293ec361092ba074ff180c1" name="ga4c0522132293ec361092ba074ff180c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0522132293ec361092ba074ff180c1">&#9670;&#160;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t len, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const FixedSizeFunction&lt; len, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac6f3be21f1d69cdaaa8bd4760639788e" name="gac6f3be21f1d69cdaaa8bd4760639788e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f3be21f1d69cdaaa8bd4760639788e">&#9670;&#160;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t len, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FixedSizeFunction&lt; len, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaac35c5c266b29f529de20dccdcd26fa6" name="gaac35c5c266b29f529de20dccdcd26fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac35c5c266b29f529de20dccdcd26fa6">&#9670;&#160;</a></span>makeOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classValue.html">Value</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOptional.html">Optional</a>&lt; std::decay_t&lt; <a class="el" href="classValue.html">Value</a> &gt; &gt; makeOptional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValue.html">Value</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab1fd5a52bf9cdcb373becc550ef04a1d" name="gab1fd5a52bf9cdcb373becc550ef04a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1fd5a52bf9cdcb373becc550ef04a1d">&#9670;&#160;</a></span>Span() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename End&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Span </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">End</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  Span&lt; std::remove_pointer_t&lt; decltype(detail::toAddress(std::declval&lt; T &gt;()))&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga812ef2cb5add31d1b5bbc02f55bc5ace" name="ga812ef2cb5add31d1b5bbc02f55bc5ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga812ef2cb5add31d1b5bbc02f55bc5ace">&#9670;&#160;</a></span>Span() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Span </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em></em></span>[N]</td><td>)</td>
          <td> -&gt;  Span&lt; T, N &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaba9175593b8b59c462e846730fe6d92f" name="gaba9175593b8b59c462e846730fe6d92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba9175593b8b59c462e846730fe6d92f">&#9670;&#160;</a></span>Span() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Span </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  Span&lt; T, N &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad5e4583a004791de2d963fb1df3e5ca4" name="gad5e4583a004791de2d963fb1df3e5ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5e4583a004791de2d963fb1df3e5ca4">&#9670;&#160;</a></span>Span() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Span </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  Span&lt; const T, N &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gadfa72dc09a575cc75cd678e3b86d6d45" name="gadfa72dc09a575cc75cd678e3b86d6d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfa72dc09a575cc75cd678e3b86d6d45">&#9670;&#160;</a></span>Span() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classRange.html">Range</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRange.html">Range</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> -&gt;  Span&lt; std::remove_pointer_t&lt; decltype(std::data(r))&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga360b996ba555a2333b467dd6edc8c11f" name="ga360b996ba555a2333b467dd6edc8c11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga360b996ba555a2333b467dd6edc8c11f">&#9670;&#160;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison. </p>

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="ga4f872257dd6891ae4516b9b630f745fe" name="ga4f872257dd6891ae4516b9b630f745fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f872257dd6891ae4516b9b630f745fe">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison. </p>

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="gafafdd2084fbdd9e82f73c09626b21018" name="gafafdd2084fbdd9e82f73c09626b21018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafafdd2084fbdd9e82f73c09626b21018">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison. </p>

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

<p class="reference">Referenced by <a class="el" href="classColourGradient.html#a5a827a26faf0dcbc37a407195536462e">ColourGradient::operator&gt;=()</a>.</p>

</div>
</div>
<a id="ga1e5668d556386876c10e47acb74ea4c9" name="ga1e5668d556386876c10e47acb74ea4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e5668d556386876c10e47acb74ea4c9">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison. </p>

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="gad14f3cd2b038f462293ce642f46ee5f7" name="gad14f3cd2b038f462293ce642f46ee5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad14f3cd2b038f462293ce642f46ee5f7">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison. </p>

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="ga689d9eaaf33a1dbc9b1a8a14b1d0c43c" name="ga689d9eaaf33a1dbc9b1a8a14b1d0c43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga689d9eaaf33a1dbc9b1a8a14b1d0c43c">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the values of two var objects, using the <a class="el" href="classvar.html#a5ba20895db4514964f089c4159543b20" title="Returns true if this var has the same value as the one supplied.">var::equals()</a> comparison. </p>

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="ga8512deaef9b5f1f12a8a45403a72e508" name="ga8512deaef9b5f1f12a8a45403a72e508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8512deaef9b5f1f12a8a45403a72e508">&#9670;&#160;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="ga4672f12ca2fdc31e9ca7188101d35a95" name="ga4672f12ca2fdc31e9ca7188101d35a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4672f12ca2fdc31e9ca7188101d35a95">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="ga48fb19d379d327812bd68823c7ccf694" name="ga48fb19d379d327812bd68823c7ccf694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48fb19d379d327812bd68823c7ccf694">&#9670;&#160;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="ga5be7dbc7fd3b5935ad0aca0d8d39e425" name="ga5be7dbc7fd3b5935ad0aca0d8d39e425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be7dbc7fd3b5935ad0aca0d8d39e425">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a> bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="group__juce__audio__processors-utilities.html#ga65961b3bfbda0ffb83750d914cee38fb">JUCE_API</a>.</p>

</div>
</div>
<a id="gab3787616ae5ae65a64ac0a706e348a7c" name="gab3787616ae5ae65a64ac0a706e348a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3787616ae5ae65a64ac0a706e348a7c">&#9670;&#160;</a></span>indexOfSorted() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType, typename TypeOfCriticalSectionToUse, int minimumAllocatedSize&gt; </div>
<div class="memtemplate">
template&lt;typename ElementComparator, typename TargetValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classArray.html">Array</a>&lt; ElementType, TypeOfCriticalSectionToUse, minimumAllocatedSize &gt;::indexOfSorted </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TargetValueType</td>          <td class="paramname"><span class="paramname"><em>elementToLookFor</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the index of an element in the array, assuming that the array is sorted. </p>
<p>This will use a comparator to do a binary-chop to find the index of the given element, if it exists. If the array isn't sorted, the behaviour of this method will be unpredictable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use to compare the elements - see the <a class="el" href="classArray.html#abd6210cb3337f1cc11b89bc7b63f9c72" title="Sorts the array using a default comparison operation.">sort()</a> method for details about the form this object should take </td></tr>
    <tr><td class="paramname">elementToLookFor</td><td>the element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the element, or -1 if it's not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classArray.html#afc5417019f110034658b3c1c02af5a5e" title="Inserts a new element into the array, assuming that the array is sorted.">addSorted</a>, <a class="el" href="classArray.html#abd6210cb3337f1cc11b89bc7b63f9c72" title="Sorts the array using a default comparison operation.">sort</a> </dd></dl>

<p class="reference">References <a class="el" href="classArray.html#a807af5d19acf78c261f2b39b423cd447">getLock()</a>.</p>

</div>
</div>
<a id="ga526081df81183ddd47f9f514de483a8f" name="ga526081df81183ddd47f9f514de483a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga526081df81183ddd47f9f514de483a8f">&#9670;&#160;</a></span>sort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType, typename TypeOfCriticalSectionToUse, int minimumAllocatedSize&gt; </div>
<div class="memtemplate">
template&lt;class ElementComparator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; ElementType, TypeOfCriticalSectionToUse, minimumAllocatedSize &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>retainOrderOfEquivalentItems</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in the array. </p>
<p>This will use a comparator object to sort the elements into order. The object passed must have a method of the form: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> compareElements (ElementType first, ElementType second);</div>
</div><!-- fragment --><p>..and this method must return:</p><ul>
<li>a value of &lt; 0 if the first comes before the second</li>
<li>a value of 0 if the two objects are equivalent</li>
<li>a value of &gt; 0 if the second comes before the first</li>
</ul>
<p>To improve performance, the compareElements() method can be declared as static or const.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use for comparing elements. </td></tr>
    <tr><td class="paramname">retainOrderOfEquivalentItems</td><td>if this is true, then items which the comparator says are equivalent will be kept in the order in which they currently appear in the array. This is slower to perform, but may be important in some cases. If it's false, a faster algorithm is used, but equivalent elements may be rearranged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classArray.html#afc5417019f110034658b3c1c02af5a5e" title="Inserts a new element into the array, assuming that the array is sorted.">addSorted</a>, <a class="el" href="#gab3787616ae5ae65a64ac0a706e348a7c" title="Finds the index of an element in the array, assuming that the array is sorted.">indexOfSorted</a>, sortArray </dd></dl>

<p class="reference">References <a class="el" href="classArray.html#a807af5d19acf78c261f2b39b423cd447">getLock()</a>, and <a class="el" href="classArray.html#ae79ec3b32d0c9a80dfff8ffbc41f8523">size()</a>.</p>

</div>
</div>
<a id="ga3362aa46fe920b22b20ccc313bfe3366" name="ga3362aa46fe920b22b20ccc313bfe3366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3362aa46fe920b22b20ccc313bfe3366">&#9670;&#160;</a></span>addSorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectClass, class TypeOfCriticalSectionToUse&gt; </div>
<div class="memtemplate">
template&lt;class ElementComparator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOwnedArray.html">OwnedArray</a>&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::addSorted </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectClass *</td>          <td class="paramname"><span class="paramname"><em>newObject</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new object into the array assuming that the array is sorted. </p>
<p>This will use a comparator to find the position at which the new object should go. If the array isn't sorted, the behaviour of this method will be unpredictable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use to compare the elements - see the sort method for details about this object's structure </td></tr>
    <tr><td class="paramname">newObject</td><td>the new object to insert to the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index at which the new object was added </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOwnedArray.html#a501b3feaa7e37f081b41564917000cf9" title="Appends a new object to the end of the array.">add</a>, <a class="el" href="#ga9ed6587acb285ae967dcce7608af95ad" title="Sorts the elements in the array.">sort</a>, <a class="el" href="#ga7ebb5f9e4bed3ffd0d5a4e980c77260b" title="Finds the index of an object in the array, assuming that the array is sorted.">indexOfSorted</a> </dd></dl>

<p class="reference">References <a class="el" href="classOwnedArray.html#abe81cbaae3497fcc133c0fd15d9f17d8">getLock()</a>, and <a class="el" href="classOwnedArray.html#a795495eeab62e88e1d1f76ab99c406c6">insert()</a>.</p>

</div>
</div>
<a id="ga7ebb5f9e4bed3ffd0d5a4e980c77260b" name="ga7ebb5f9e4bed3ffd0d5a4e980c77260b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ebb5f9e4bed3ffd0d5a4e980c77260b">&#9670;&#160;</a></span>indexOfSorted() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectClass, class TypeOfCriticalSectionToUse&gt; </div>
<div class="memtemplate">
template&lt;typename ElementComparator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOwnedArray.html">OwnedArray</a>&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::indexOfSorted </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ObjectClass *</td>          <td class="paramname"><span class="paramname"><em>objectToLookFor</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of an object in the array, assuming that the array is sorted. </p>
<p>This will use a comparator to do a binary-chop to find the index of the given element, if it exists. If the array isn't sorted, the behaviour of this method will be unpredictable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use to compare the elements - see the <a class="el" href="#ga9ed6587acb285ae967dcce7608af95ad" title="Sorts the elements in the array.">sort()</a> method for details about the form this object should take </td></tr>
    <tr><td class="paramname">objectToLookFor</td><td>the object to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the element, or -1 if it's not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3362aa46fe920b22b20ccc313bfe3366" title="Inserts a new object into the array assuming that the array is sorted.">addSorted</a>, <a class="el" href="#ga9ed6587acb285ae967dcce7608af95ad" title="Sorts the elements in the array.">sort</a> </dd></dl>

<p class="reference">References <a class="el" href="classOwnedArray.html#abe81cbaae3497fcc133c0fd15d9f17d8">getLock()</a>.</p>

</div>
</div>
<a id="ga9ed6587acb285ae967dcce7608af95ad" name="ga9ed6587acb285ae967dcce7608af95ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed6587acb285ae967dcce7608af95ad">&#9670;&#160;</a></span>sort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectClass, class TypeOfCriticalSectionToUse&gt; </div>
<div class="memtemplate">
template&lt;typename ElementComparator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOwnedArray.html">OwnedArray</a>&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>retainOrderOfEquivalentItems</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the array. </p>
<p>This will use a comparator object to sort the elements into order. The object passed must have a method of the form: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> compareElements (ElementType* first, ElementType* second);</div>
</div><!-- fragment --><p>..and this method must return:</p><ul>
<li>a value of &lt; 0 if the first comes before the second</li>
<li>a value of 0 if the two objects are equivalent</li>
<li>a value of &gt; 0 if the second comes before the first</li>
</ul>
<p>To improve performance, the compareElements() method can be declared as static or const.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use for comparing elements. </td></tr>
    <tr><td class="paramname">retainOrderOfEquivalentItems</td><td>if this is true, then items which the comparator says are equivalent will be kept in the order in which they currently appear in the array. This is slower to perform, but may be important in some cases. If it's false, a faster algorithm is used, but equivalent elements may be rearranged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>sortArray, <a class="el" href="#ga7ebb5f9e4bed3ffd0d5a4e980c77260b" title="Finds the index of an object in the array, assuming that the array is sorted.">indexOfSorted</a> </dd></dl>

<p class="reference">References <a class="el" href="classOwnedArray.html#abe81cbaae3497fcc133c0fd15d9f17d8">getLock()</a>, and <a class="el" href="classOwnedArray.html#a5db444e91e2abcdcf222f5ec2a90e1ac">size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classValueTree.html#acdace65667e5bb2036310b4a91dd3a87">ValueTree::sort()</a>.</p>

</div>
</div>
<a id="gae6ed5a2756f413f59ce87a6455cf7dbd" name="gae6ed5a2756f413f59ce87a6455cf7dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ed5a2756f413f59ce87a6455cf7dbd">&#9670;&#160;</a></span>indexOfSorted() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectClass, class TypeOfCriticalSectionToUse&gt; </div>
<div class="memtemplate">
template&lt;class ElementComparator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classReferenceCountedArray.html">ReferenceCountedArray</a>&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::indexOfSorted </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ObjectClass *</td>          <td class="paramname"><span class="paramname"><em>objectToLookFor</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of an object in the array, assuming that the array is sorted. </p>
<p>This will use a comparator to do a binary-chop to find the index of the given element, if it exists. If the array isn't sorted, the behaviour of this method will be unpredictable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use to compare the elements - see the <a class="el" href="#ga3b913b02e04ad29a6881ab4034c0f0f5" title="Sorts the elements in the array.">sort()</a> method for details about the form this object should take </td></tr>
    <tr><td class="paramname">objectToLookFor</td><td>the object to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the element, or -1 if it's not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classReferenceCountedArray.html#afb1a9958a818b6c410d79fc65b23432e" title="Inserts a new object into the array assuming that the array is sorted.">addSorted</a>, <a class="el" href="#ga3b913b02e04ad29a6881ab4034c0f0f5" title="Sorts the elements in the array.">sort</a> </dd></dl>

<p class="reference">References <a class="el" href="classReferenceCountedArray.html#a71886a0fb90b8bdc439049ff52cf93e9">getLock()</a>.</p>

</div>
</div>
<a id="ga3b913b02e04ad29a6881ab4034c0f0f5" name="ga3b913b02e04ad29a6881ab4034c0f0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b913b02e04ad29a6881ab4034c0f0f5">&#9670;&#160;</a></span>sort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectClass, class TypeOfCriticalSectionToUse&gt; </div>
<div class="memtemplate">
template&lt;class ElementComparator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classReferenceCountedArray.html">ReferenceCountedArray</a>&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>retainOrderOfEquivalentItems</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the array. </p>
<p>This will use a comparator object to sort the elements into order. The object passed must have a method of the form: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> compareElements (ElementType first, ElementType second);</div>
</div><!-- fragment --><p>..and this method must return:</p><ul>
<li>a value of &lt; 0 if the first comes before the second</li>
<li>a value of 0 if the two objects are equivalent</li>
<li>a value of &gt; 0 if the second comes before the first</li>
</ul>
<p>To improve performance, the compareElements() method can be declared as static or const.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use for comparing elements. </td></tr>
    <tr><td class="paramname">retainOrderOfEquivalentItems</td><td>if this is true, then items which the comparator says are equivalent will be kept in the order in which they currently appear in the array. This is slower to perform, but may be important in some cases. If it's false, a faster algorithm is used, but equivalent elements may be rearranged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>sortArray </dd></dl>

<p class="reference">References <a class="el" href="classReferenceCountedArray.html#a71886a0fb90b8bdc439049ff52cf93e9">getLock()</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="gacd293644b847dc4549de80a090d66625" name="gacd293644b847dc4549de80a090d66625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd293644b847dc4549de80a090d66625">&#9670;&#160;</a></span>nullopt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto nullopt = std::nullopt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classjuce_1_1midi__ci_1_1PropertyExchangeResult.html#a3ece56341725dcdc62052406aebe63da">juce::midi_ci::PropertyExchangeResult::PropertyExchangeResult()</a>.</p>

</div>
</div>
<a id="ga396d97a60bce38d4e287895df5edd520" name="ga396d97a60bce38d4e287895df5edd520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga396d97a60bce38d4e287895df5edd520">&#9670;&#160;</a></span>dynamicExtent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto dynamicExtent = std::numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
