# 7. 技术风险与解决方案 (更新于 2025.12.13)

## 7.1 风险矩阵

| 风险项 | 状态 | 可能性 | 严重性 | 描述 | 解决方案 |
| :--- | :--- |:---|:---|:---|:---|
| **GUI 框架兼容性** | ✅ 已解决 | 低 | 高 | `egui` + `glow` 兼容性问题。 | 切换至 `wgpu` 后端。 |
| **网络延迟与丢包** | ✅ 已实现 | 低 | 中 | 跨机通信导致操作滞后。 | ZMQ PUB/SUB + TCP，局域网延迟 <1ms。状态保持机制解决丢包风险。 |
| **Master 故障影响** | ✅ 已实现 | 低 | 极高 | Master 崩溃导致系统全开爆音。 | Slave 具备状态保持 + 心跳超时自动重连。 |
| **OSC 端口冲突** | ✅ 已解决 | 低 | 中 | 端口占用。 | 发送/接收端口分离 (7444/7445)，支持 Settings 配置。 |
| **网络地址配置** | ✅ 已解决 | 低 | 低 | Slave 连接地址硬编码。 | Settings 页面支持配置 Master IP。 |
| **增益切换噪声** | ✅ 已验证 | 低 | 中 | Solo/Mute 切换噪声。 | 增益平滑 (ramping) 已实现。 |
| **心跳超时** | ✅ 已解决 | - | 高 | Slave 无法检测 Master 离线。 | 2秒心跳超时 + 自动重连机制。 |
| **协议版本不兼容** | ✅ 已解决 | - | 高 | 不同版本通信崩溃。 | protocol_version + magic 校验。 |

## 7.2 已验证的解决方案

### 7.2.1 根除"死亡指针" (The Weak Ref Pattern)
**问题**: C++ 版本使用裸指针管理插件列表，导致 Use-After-Free 崩溃。

**解决方案**: Rust 的所有权机制 + Registry 模式
- 使用 `Arc<RwLock<T>>` 管理共享状态
- 编译期强制生命周期检查
- 运行时零成本安全保障

### 7.2.2 分布式状态同步 (The ZMQ Snapshot Pattern)
**旧方案**: 进程内指针/共享内存，不支持跨机。

**新方案 (v4.0)**:
```
Master: ChannelLogic → RenderState → Bincode序列化 → ZMQ PUB (端口9123)
Slave:  ZMQ SUB → 反序列化 → AtomicCell缓存 → DSP无锁读取
```

**优势**:
- 天然解耦，支持跨机
- TCP 自动重连
- 状态保持（Slave 在断连时维持最后状态）

### 7.2.3 复杂 Solo 逻辑的解耦 (The Logic Core)
**问题**: v4.0 规范的交互逻辑极其复杂（混合 Solo、SUB 豁免、A/B 对比）。

**解决方案**: `InteractionManager` 状态机
- PrimaryMode + CompareMode 双层模式
- ChannelSet 基于 HashSet<String> 存储
- 自动反转逻辑（copy_set）
- 与 UI、DSP 完全分离，可单独测试

## 7.3 v2.5.8 解决的关键问题

### 7.3.1 UI Role 切换不触发网络初始化

**问题**: 用户通过 UI 切换 Role (Standalone → Slave)，但网络层不初始化。

**根因**: `reset()` 只在 DAW 恢复项目时被调用，UI 参数变化不触发。

**解决方案**: 在 Editor 中检测 Role 变化并触发热重载
```rust
// Editor.rs
if prev_role != current_role {
    interaction.request_network_restart(config);
}
```

### 7.3.2 心跳超时后线程不退出

**问题**: Slave 检测到心跳超时，但 `is_running` 标志未清理，导致无法重新初始化。

**根因**: 线程退出路径未清理 `is_running`。

**解决方案**: 所有退出路径添加清理代码
```rust
// 心跳超时
if heartbeat_timeout {
    is_running.store(false, Ordering::Release);  // 先清理
    interaction.request_network_restart(config);
    break;
}
```

### 7.3.3 Slave 模式通道可点击

**问题**: Slave 模式下用户仍可点击通道，导致本地状态与 Master 不同步。

**解决方案**: 添加 Slave 模式检查
```rust
let is_slave = params.role.value() == PluginRole::Slave;
if response.clicked() && !is_slave {
    interaction.on_channel_click(&ch.name);
}
```

### 7.3.4 布局切换后状态异常

**问题**: Master 切换布局后，Slave 的 Solo/Mute 集合包含已不存在的通道名。

**解决方案**: 布局切换时清理交互状态
```rust
if new_layout != current_layout {
    interaction.clear_on_layout_change();  // 清理 Solo/Mute/Compare
    setter.set_parameter(&params.layout, new_layout);
}
```

## 7.4 当前已验证项

### 7.4.1 音频处理正确性 ✅

| 功能 | 预期行为 | 验证状态 |
|------|---------|---------|
| Cut | 完全静音 | ✅ 已验证 |
| Dim | 衰减 -20dB | ✅ 已验证 |
| Volume | 连续音量控制 | ✅ 已验证 |
| Solo 通道 | 仅选中通道有声 | ✅ 已验证 |
| Mute 通道 | 选中通道静音 | ✅ 已验证 |

### 7.4.2 Master-Slave 通信稳定性 ✅

| 场景 | 配置 | 验证状态 |
|------|-----|---------|
| 本机测试 | 同一 DAW 内 Master + Slave | ✅ 已验证 |
| 跨实例测试 | 两个 DAW 实例 | ✅ 已验证 |
| 断连测试 | 关闭 Master | ✅ 已验证 (2秒后自动重连) |
| Role 切换 | UI 切换 Role | ✅ 已验证 |
| 心跳超时 | Master 崩溃 | ✅ 已验证 |

## 7.5 已知限制

1. **单一 Master**: 不支持多 Master 场景
2. **仅限 Windows**: 当前只在 Windows 平台测试

这些限制在当前使用场景下可接受，如有需要可在后续版本中改进。

## 7.6 调试与故障排查

### 7.6.1 日志文件位置

- 默认: `C:\Plugins\MCM_Logs\`
- Fallback: `%TEMP%\MonitorControllerMax_Logs\`

### 7.6.2 关键日志搜索

| 关键字 | 含义 |
|--------|------|
| `[ROLE]` | Role 切换事件 |
| `[HOT RELOAD]` | 热重载触发 |
| `Heartbeat timeout` | 心跳超时 |
| `reconnecting` | 重连尝试 |

### 7.6.3 常见问题

| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| Slave 无法连接 | 端口被占用/防火墙 | 检查 9123 端口，添加防火墙规则 |
| 状态不同步 | 协议版本不匹配 | 更新所有实例到相同版本 |
| UI 不响应 | Slave 模式 | Slave 模式下交互被禁用，属正常行为 |
