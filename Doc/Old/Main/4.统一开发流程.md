# 4. 统一开发流程

本文档定义了从 C++ 迁移到 Rust 的标准化作业流程。

## 4.1 IDIV 开发循环

我们沿用 IDIV (Iterative Design, Implement, Verify) 模式。

### 1. 逻辑设计 (Design)
*   明确输入（Params, OSC）、处理（Semantic Logic）、输出（RenderState）。
*   参考《MonitorControllerMax 核心逻辑与交互设计规范 (v4.0)》进行推演。

### 2. 代码实现 (Implement)
*   优先实现纯逻辑模块 (`ChannelLogic`) 并编写单元测试。
*   实现网络层 (`NetworkManager`)，确保数据包的序列化/反序列化正确。
*   最后集成到 `AudioProcessor`。

### 3. 验证 (Verify)
*   **单元测试**: 覆盖所有 Solo/Mute 组合的真值表。
*   **集成测试**: 在 DAW 中加载 Master 和 Slave，验证音频流是否符合预期。
*   **网络测试**: 在两台电脑上分别运行 Master 和 Slave，验证跨机控制。

## 4.2 构建与调试命令

使用 `xtask` 进行跨平台构建和打包。

### 4.2.1 三种构建模式

| 模式 | 命令 | 用途 | 输出目录 |
|------|------|------|---------|
| Debug | `cargo xtask bundle monitor_controller_max` | 开发调试 | `Build/Debug/` |
| Release | `cargo xtask bundle monitor_controller_max --release` | 性能测试 | `Build/Release/` |
| Production | `cargo xtask bundle monitor_controller_max --production` | 发布分发 | `Build/Production/` |

### 4.2.2 模式差异

| 特性 | Debug | Release | Production |
|------|-------|---------|------------|
| 优化级别 | 无 | `-O3` | `-O3` |
| 文件日志 | ✅ | ✅ | ❌ |
| UI 日志 | ✅ | ✅ | ✅ |
| 调试符号 | ✅ | ✅ | ❌ |

### 4.2.3 部署路径

**开发环境**:
- Debug/Release 构建自动复制到: `C:\Plugins\VST Dev\`

**生产环境**:
- Production 构建自动复制到: `C:\Program Files\Common Files\VST3\`

### 4.2.4 常用命令

```bash
# 开发构建
cargo xtask bundle monitor_controller_max

# Release 构建
cargo xtask bundle monitor_controller_max --release

# Production 构建
cargo xtask bundle monitor_controller_max --production

# 仅运行单元测试
cargo test -p monitor_controller_max

# 检查编译错误
cargo check
```

**调试提示**: 由于涉及多实例网络通信，建议使用 Wireshark 或类似工具抓包验证 ZMQ 数据流。

## 4.3 迁移 Checklist

- [x] 数据结构是否使用了 `Arc/RwLock` 替代裸指针？
- [x] DSP 循环中是否清除了所有 `unwrap()`？
- [x] **(网络)** 是否处理了 ZMQ 的非阻塞接收？
- [x] **(逻辑)** 是否实现了 v4.0 规范中的所有 Solo/Mute 规则？
- [x] **(GUI)** 是否所有尺寸都使用了 `scale.s()` 进行处理？

## 4.4 发布检查清单 (v2.5.0 新增)

### 4.4.1 代码检查

- [ ] 所有 TODO 已处理
- [ ] 无编译警告
- [ ] 版本号已更新 (`Cargo.toml`)
- [ ] 文档已同步更新

### 4.4.2 功能测试

- [ ] Standalone 模式正常工作
- [ ] Master 模式正常工作
- [ ] Slave 模式连接正常
- [ ] Slave 状态同步正常
- [ ] 心跳超时重连正常
- [ ] 热重载 OSC 端口正常
- [ ] 热重载 Network 端口正常
- [ ] Role 切换正常
- [ ] 布局切换正常
- [ ] Solo/Mute 交互正常
- [ ] Volume/Dim/Cut 正常

### 4.4.3 发布步骤

```bash
# 1. 确认版本号
cat Source/Plugin/Cargo.toml | grep version

# 2. Production 构建
cargo xtask bundle monitor_controller_max --production

# 3. 验证输出
ls Build/Production/

# 4. 打 Git Tag
git tag -a v2.5.8 -m "Release v2.5.8"
git push origin v2.5.8
```

## 4.5 日志分析流程 (v2.5.0 新增)

### 4.5.1 日志文件位置

- 默认: `C:\Plugins\MCM_Logs\MCM_*.log`
- Fallback: `%TEMP%\MonitorControllerMax_Logs\`

### 4.5.2 关键日志搜索

| 搜索关键字 | 含义 |
|-----------|------|
| `[ROLE]` | Role 切换事件 |
| `[HOT RELOAD]` | 热重载触发 |
| `Heartbeat timeout` | 心跳超时 |
| `reconnecting` | 重连尝试 |
| `ZMQ` | 网络相关 |
| `error` | 错误信息 |

### 4.5.3 网络问题调试

```powershell
# 检查端口占用
netstat -an | findstr 9123

# 添加防火墙规则 (管理员)
netsh advfirewall firewall add rule name="MCM ZMQ" dir=in action=allow protocol=tcp localport=9123
```

## 4.6 开发经验与教训 (v2.5.8 总结)

### 4.6.1 GUI 框架选型教训

**错误尝试**: 最初使用 `eframe` + `glow`，因窗口所有权冲突和 OpenGL 上下文竞争失败。

**正确方案**: 使用 `nih-plug-egui` 提供的集成，正确处理窗口嵌入和上下文管理。

### 4.6.2 并发设计原则

- **音频线程无锁**: 使用 `AtomicCell` 进行无锁快照读取
- **请求-执行分离**: UI 线程只设置请求，process() 线程执行实际操作
- **状态标志清理**: 任何线程退出路径都必须清理 `is_running`

### 4.6.3 v2.5.8 修复的关键 Bug

| Bug | 根因 | 修复 |
|-----|------|------|
| UI Role 切换不触发网络初始化 | `reset()` 只在 DAW 恢复时调用 | Editor 中检测 Role 变化并触发热重载 |
| 心跳超时后线程不退出 | `is_running` 未在超时路径清理 | 所有退出路径添加清理代码 |
| Slave 模式通道可点击 | 无 Slave 模式检查 | 添加 `!is_slave` 条件 |
| 布局切换后状态异常 | 旧通道名在新布局不存在 | 切换时调用 `clear_on_layout_change()` |

### 4.6.4 关键设计原则

1. **实例隔离**: 每个 VST 实例完全独立（日志、配置、线程）
2. **名称驱动**: 使用通道名称而非索引，支持动态配置
3. **版本兼容**: 网络协议从一开始就包含版本号
4. **防御性清理**: 任何退出路径都必须清理状态标志
5. **心跳机制**: 网络连接必须有超时检测
