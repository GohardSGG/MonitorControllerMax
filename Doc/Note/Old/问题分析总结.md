## 问题分析总结

### Clear 失败的根本原因

当前代码在进入比较模式时，只是简单地清空了对应的集合：

```rust
Action::EnterMuteCompare => {
    *self.compare.write() = CompareMode::Mute;
    self.mute_set.write().clear();  // 问题所在！
}
```

这是错误的，因为根据设计文档：

1. 进入比较模式时应该**自动反转**主模式的选择，而不是清空
2. 只有在比较模式没有用户记忆时才执行反转

### 缺失的关键逻辑

1. **自动反转**: 从 Solo L 进入 Mute Compare → mute_set 应该自动设为 {L}
2. **记忆持久性**: 用户修改比较模式后，A/B 切换应该保留修改
3. **脏标记**: 主模式修改后，只有比较模式没有记忆时才重新反转

## 实现计划

计划已写入 [plan file](vscode-webview://1obv6044kv2g89pb9723emt4edo4qv0jnprcbmj6dt4h2ls8a4sf/index.html?id=d5a3cbbc-8282-4bed-9d75-8cfa2998c473&origin=d6940c1f-0507-49ac-b3ad-ca8aeb01e706&swVersion=4&extensionId=Anthropic.claude-code&platform=electron&vscode-resource-base-authority=vscode-resource.vscode-cdn.net&parentOrigin=vscode-file%3A%2F%2Fvscode-app&session=6a8e9b15-417b-4262-8574-da9e8470696e)，核心改动包括：

1. **重构数据结构**: 添加 `solo_has_memory` 和 `mute_has_memory` 标记
2. **实现自动反转**: 进入比较模式时执行反转逻辑
3. **实现记忆系统**: 用户修改时设置记忆标记
4. **SUB 特殊处理**: 添加 `user_mute_sub` 用于双击强制静音

准备好开始实现了吗？

Claude’s Plan

# MonitorControllerMax 交互逻辑完整实现计划

## 问题分析

### 当前存在的问题

1. **Clear 不生效**: 在进入比较模式时调用 `mute_set.write().clear()` 没有正确清空集合
2. **自动反转逻辑缺失**: 进入比较模式时，应该自动将主模式的选择集合反转到比较模式
3. **记忆持久性未实现**: 用户在比较模式中的修改应该被记住，直到完全退出
4. **脏标记未实现**: 当主模式被修改时，只有在比较模式没有用户记忆的情况下才重新反转

### Clear 失败的根本原因分析

查看当前代码 `Interaction.rs:333-335`:

```rust
Action::EnterMuteCompare => {
    *self.compare.write() = CompareMode::Mute;
    self.mute_set.write().clear();  // 这里清空的是 mute_set
}
```

**问题**: 当从 Solo Active 进入 Mute Compare 时，我们清空的是 `mute_set`。但这不是我们想要的！根据设计文档，进入比较模式时应该：

1. 保留主模式的集合（solo_set 保持不变）
2. 自动反转主模式集合到比较模式集合（mute_set = 反转(solo_set)）

## 设计方案

### 数据结构重构

```rust
pub struct InteractionManager {
    // 主模式和比较模式
    primary: RwLock<PrimaryMode>,
    compare: RwLock<CompareMode>,

    // Solo 上下文 (Context A)
    solo_set_main: RwLock<u32>,      // 主声道位图
    solo_set_sub: RwLock<u32>,       // SUB 位图
    solo_has_memory: RwLock<bool>,   // 是否有用户修改的记忆

    // Mute 上下文 (Context B)
    mute_set_main: RwLock<u32>,      // 主声道位图
    mute_set_sub: RwLock<u32>,       // SUB 位图
    mute_has_memory: RwLock<bool>,   // 是否有用户修改的记忆

    // User Mute (SUB 专用 - 双击/长按触发)
    user_mute_sub: RwLock<u32>,      // 强制静音的 SUB 位图

    // 工具
    double_click: RwLock<DoubleClickDetector>,
    blink_counter: AtomicU32,
}
```

### 核心逻辑规则

#### 1. 进入比较模式时的自动反转

```
当从 Solo Active 进入 Mute Compare:
    if !mute_has_memory:
        mute_set = 反转(solo_set)  // 所有在 solo_set 中的通道变成 mute
    // 如果有 memory，保留上次的 mute_set

当从 Mute Active 进入 Solo Compare:
    if !solo_has_memory:
        solo_set = 反转(mute_set)  // 所有在 mute_set 中的通道变成 solo
    // 如果有 memory，保留上次的 solo_set
```

#### 2. 用户修改时设置记忆标记

```
当用户在比较模式中修改通道:
    设置 compare_context.has_memory = true
```

#### 3. 主模式修改时重置比较模式记忆

```
当用户在主模式中修改通道:
    设置 compare_context.has_memory = false  // 脏化比较模式
```

#### 4. 完全退出时清除所有状态

```
当退出到 Idle:
    清空 solo_set
    清空 mute_set
    清空 user_mute_sub
    重置 solo_has_memory = false
    重置 mute_has_memory = false
```

### SUB 通道特殊处理

1. **SUB 豁免权**: SUB 不参与自动反转
2. **单击 SUB**: 加入当前激活的上下文
3. **双击/长按 SUB**: 加入 user_mute_sub（强制静音，独立于 Solo/Mute 逻辑）

### 通道显示逻辑

```
get_channel_display(ch, is_sub) -> ChannelDisplay:
    // 获取当前激活的上下文来决定显示
    match (primary, compare):
        // 比较模式激活时，显示比较模式的状态
        (Solo, Mute): 使用 mute_set 计算显示
        (Mute, Solo): 使用 solo_set 计算显示

        // 只有主模式时
        (Solo, None): 使用 solo_set 计算显示
        (Mute, None): 使用 mute_set 计算显示

        // Idle
        (None, None): 全部灰色

    // 计算逻辑
    if has_any_solo:
        被 solo 的 -> 绿色 (S)
        没被 solo 的 -> 红色 (M) [Auto-Mute]
    elif has_any_mute:
        被 mute 的 -> 红色 (M)
        没被 mute 的 -> 绿色 (S) [正常发声]
    else:
        全部灰色
```

## 实现步骤

### Step 1: 重构 InteractionManager 数据结构

1. 分离 `solo_set` 和 `mute_set` 为独立的 main 和 sub 位图
2. 添加 `solo_has_memory` 和 `mute_has_memory` 标记
3. 添加 `user_mute_sub` 用于 SUB 强制静音

### Step 2: 实现自动反转逻辑

1. 修改 `on_solo_button_click` 和 `on_mute_button_click`
2. 在进入比较模式时检查 has_memory 标记
3. 如果没有记忆，执行自动反转

### Step 3: 实现记忆标记系统

1. 在 `on_channel_click` 中设置当前上下文的 has_memory
2. 在主模式修改时重置比较模式的 has_memory

### Step 4: 修复通道显示逻辑

1. 修改 `get_channel_display` 以正确使用当前激活的上下文
2. 确保绿色 = 有声音，红色 = 无声音

### Step 5: 实现 SUB 特殊处理

1. 修改 SUB 单击逻辑
2. 实现 SUB 双击/长按逻辑 (user_mute_sub)
3. 确保 SUB 不参与自动反转

### Step 6: 测试和验证

测试用例：

1. Solo L -> 进入 Mute Compare -> 验证 L 被自动 Mute
2. 在 Mute Compare 中修改 -> A/B 切换 -> 验证记忆保留
3. 在 Solo Active 中修改 -> 进入 Mute Compare -> 验证自动重新反转
4. SUB 在 Solo L 时保持响应
5. 双击 SUB 强制静音

## 关键文件

- [Interaction.rs](vscode-webview://1obv6044kv2g89pb9723emt4edo4qv0jnprcbmj6dt4h2ls8a4sf/Source/Plugin/Src/Interaction.rs) - 核心交互状态机（主要修改）
- [Editor.rs](vscode-webview://1obv6044kv2g89pb9723emt4edo4qv0jnprcbmj6dt4h2ls8a4sf/Source/Plugin/Src/Editor.rs) - GUI 渲染（可能需要小调整）
- [Channel_Logic.rs](vscode-webview://1obv6044kv2g89pb9723emt4edo4qv0jnprcbmj6dt4h2ls8a4sf/Source/Plugin/Src/Channel_Logic.rs) - 音频逻辑（可能需要集成）

## 注意事项

1. 所有状态修改必须通过独立的锁操作，避免死锁
2. 先读取所有需要的状态，再执行写入操作
3. SUB 通道的 user_mute 优先级最高
4. 确保 A/B 切换时视觉反馈即时