## 总结

我已经完成了全面的代码检查，发现：

### ✅ UI 层（已完成）

- `Interaction.rs` - 所有 SUB 逻辑、Compare 模式、闪烁效果都已实现
- `Editor.rs` - 闪烁渲染逻辑已实现

### ⏳ 音频层（待实现）

**问题**：`Channel_Logic.rs` 直接读取 `params.channels[i].solo/mute`，完全没有连接到 `InteractionManager`

 

**解决方案**（2个文件的修改）：

1. **Interaction.rs** - 添加 `get_audio_mute_masks()` 函数
2. **Channel_Logic.rs** - 调用 InteractionManager 获取 mute mask

修改非常简洁，因为：

- InteractionManager 是全局单例，可以直接访问
- Audio.rs 无需修改
- 所有逻辑都在 InteractionManager 中，Channel_Logic 只需要调用一个函数

Claude’s Plan

# SUB 通道逻辑修复计划

## 问题总结

根据 `/Doc/Note/逻辑沟通.md` 的详细讨论，当前 SUB 通道逻辑存在以下问题：

### 当前实现的问题

1. **`get_channel_display()` 没有区分 Group M 和 Group S**
    
    - 当前代码对 Main 和 SUB 使用相同的 Auto-Mute 逻辑
    - SUB 应该有"豁免权"，不被主声道的 Solo 所影响
2. **SUB 不应该参与自动反转**
    
    - 当前 `copy_set()` 正确地只拷贝 main 通道
    - 但 `get_channel_display()` 的显示逻辑没有体现 SUB 的特殊处理
3. **双层 Solo 逻辑未实现**
    
    - 需要分别维护 `SoloSet_Main` 和 `SoloSet_Sub`
    - Main 通道只受 Main 组 Solo 影响
    - SUB 通道受 SUB 组 Solo 影响，但依赖 Main 组有声音作为前提

## 核心规范（来自沟通记录）

### 1. 双组模型 (Dual Group Model)

```
- Group M (Main): L, R, C, LFE, LSS, RSS, LRS, RRS, LTF, RTF, LTB, RTB...
- Group S (Sub): SUB, SUB L, SUB R, SUB F, SUB B...
```

**关键区分**：

- LFE 属于 Group M（低音通道，不是低音炮）
- 只有名称包含 "SUB" 的才属于 Group S

### 2. 主声道逻辑 (Group M)

对于主声道 i：

```
Pass_i = !UserMute_i
    AND ( SoloSet_Main 为空 OR i ∈ SoloSet_Main )
```

- Main 通道只跟自己圈子玩
- SUB 的状态**完全不影响** Main 通道

### 3. SUB 通道逻辑 (Group S) - 核心！

对于 SUB 通道 j：

```
Pass_j = !UserMute_j                           // 用户没按 Mute
    AND ( 有任意 Main 通道在响 )               // 物理依赖：必须有源
    AND ( SoloSet_Sub 为空 OR j ∈ SoloSet_Sub ) // SUB 组内竞争
```

**关键规则**：

1. **豁免权**：Solo 某个 Main 通道时，SUB 默认跟着响（因为有源）
2. **SUB 组内竞争**：如果 Solo 了 SUB1，则 SUB2/SUB3 会被 Auto-Mute
3. **SUB Solo 不切断 Main**：Solo SUB 时，Main 通道保持原样（该响的响）

### 4. 自动反转时 SUB 的行为

**SUB 永远不参与自动反转**：

- Solo L → 点 Mute 进入比较 → SUB 状态保持不变
- SUB 就像房间里的灯，除非用户按它的开关

### 5. SUB 双击逻辑

- **单击 SUB**：加入当前 Context 的 Solo/Mute 集合
- **双击 SUB**：User Mute 切换（强制静音，优先级最高）

### 6. 场景验证

|操作|L|R|C|SUB1|SUB2|说明|
|---|---|---|---|---|---|---|
|Idle|○|○|○|○|○|全部灰色|
|Solo L|●|✖|✖|●|●|L响，其他Main静，SUB都响|
|Solo L + Solo SUB1|●|✖|✖|●|✖|L响，SUB1响，SUB2静|
|Solo SUB1 (alone)|○|○|○|●|✖|Main不变，只有SUB1响|
|Mute L|✖|●|●|●|●|L静，其他Main响，SUB都响|

（●=绿色/响，✖=红色/静，○=灰色）

## 修改方案

### 文件：`Interaction.rs`

#### 1. 修改 `ChannelSet` 结构

当前结构已经区分了 `main` 和 `sub`，但需要确保逻辑正确使用。

#### 2. 重写 `get_channel_display()` 函数

```rust
pub fn get_channel_display(&self, ch: usize, is_sub: bool) -> ChannelDisplay {
    let primary = *self.primary.read();
    let compare = *self.compare.read();

    // Idle 状态：全部灰色
    if primary == PrimaryMode::None {
        return ChannelDisplay { has_sound: false, marker: None };
    }

    // 获取当前激活的集合
    let (context_type, active_set) = match compare {
        CompareMode::Solo => (ContextType::Solo, self.solo_set.read()),
        CompareMode::Mute => (ContextType::Mute, self.mute_set.read()),
        CompareMode::None => match primary {
            PrimaryMode::Solo => (ContextType::Solo, self.solo_set.read()),
            PrimaryMode::Mute => (ContextType::Mute, self.mute_set.read()),
            PrimaryMode::None => unreachable!(),
        }
    };

    // === SUB 特殊逻辑 ===
    if is_sub {
        // 检查 User Mute（优先级最高）
        let user_mute = *self.user_mute_sub.read();
        if (user_mute >> ch) & 1 == 1 {
            return ChannelDisplay { has_sound: false, marker: Some(ChannelMarker::Mute) };
        }

        // 检查 Main 是否有声音（物理依赖）
        let main_has_sound = self.check_main_has_sound(context_type, &active_set);
        if !main_has_sound {
            // 没有源，SUB 不响
            return ChannelDisplay { has_sound: false, marker: Some(ChannelMarker::Mute) };
        }

        // SUB 组内逻辑
        let is_in_sub_set = active_set.contains_sub(ch);
        let sub_set_has_any = active_set.sub != 0;

        let marker = match context_type {
            ContextType::Solo => {
                if sub_set_has_any {
                    // SUB 组有 Solo
                    if is_in_sub_set { Some(ChannelMarker::Solo) }
                    else { Some(ChannelMarker::Mute) }
                } else {
                    // SUB 组没有 Solo，豁免权：跟着响
                    Some(ChannelMarker::Solo)
                }
            }
            ContextType::Mute => {
                if is_in_sub_set {
                    Some(ChannelMarker::Mute)
                } else if sub_set_has_any {
                    Some(ChannelMarker::Solo)
                } else {
                    // Mute 集合为空，豁免权：跟着响
                    Some(ChannelMarker::Solo)
                }
            }
        };

        return ChannelDisplay {
            has_sound: marker == Some(ChannelMarker::Solo),
            marker
        };
    }

    // === Main 通道逻辑（原有逻辑，只看 main 部分） ===
    let is_in_main_set = active_set.contains_main(ch);
    let main_set_has_any = active_set.main != 0;

    let marker = match context_type {
        ContextType::Solo => {
            if is_in_main_set {
                Some(ChannelMarker::Solo)
            } else if main_set_has_any {
                Some(ChannelMarker::Mute)
            } else {
                None
            }
        }
        ContextType::Mute => {
            if is_in_main_set {
                Some(ChannelMarker::Mute)
            } else if main_set_has_any {
                Some(ChannelMarker::Solo)
            } else {
                None
            }
        }
    };

    ChannelDisplay {
        has_sound: marker == Some(ChannelMarker::Solo),
        marker
    }
}
```

#### 3. 添加辅助函数 `check_main_has_sound()`

```rust
/// 检查是否有任何 Main 通道在响（SUB 的物理依赖条件）
fn check_main_has_sound(&self, context_type: ContextType, active_set: &ChannelSet) -> bool {
    let main_set_has_any = active_set.main != 0;

    match context_type {
        ContextType::Solo => {
            // Solo 模式：如果 Solo 集合为空，全部 Main 都响；否则只有被 Solo 的响
            // 只要有任意 Main 响，就返回 true
            if !main_set_has_any {
                true  // Solo 集合为空，全部 Main 响
            } else {
                true  // 有被 Solo 的，那些在响
            }
        }
        ContextType::Mute => {
            // Mute 模式：如果 Mute 集合为空，全部 Main 都响；否则不在 Mute 里的响
            if !main_set_has_any {
                true  // Mute 集合为空，全部 Main 响
            } else {
                // 检查是否有任何 Main 不在 Mute 集合中
                // 简化：只要不是全部都被 Mute，就有声音
                active_set.main != 0xFFFFFFFF  // 不可能全部 32 通道都被 Mute
            }
        }
    }
}
```

### 文件：`Channel_Logic.rs`

当前代码已经使用 `ch_info.name.contains("SUB")` 来区分 SUB，这是正确的。但需要确保：

1. 只有名称包含 "SUB" 的才被视为 Group S
2. LFE 应该被视为 Group M（当前代码正确）

## 边界情况测试清单

1. **Solo L** → SUB 应该全部响（豁免权）
2. **Solo L + Solo SUB1** → 只有 SUB1 响，其他 SUB 静
3. **只 Solo SUB1（不 Solo 任何 Main）** → Main 保持原样，只有 SUB1 响
4. **Mute L** → SUB 全部响
5. **双击 SUB** → User Mute 切换，优先级最高
6. **反转时** → SUB 状态保持不变

## 实现步骤

### 阶段 1：UI 层 ✅ 已完成

1. ✅ 在 `Interaction.rs` 中重写 `get_channel_display()` 函数
2. ✅ SUB 使用 Primary 模式的集合（不参与 Compare 反转）
3. ✅ 添加 `is_blinking` 字段到 `ChannelDisplay`
4. ✅ 闪烁逻辑：只有被选中的通道闪烁

### 阶段 2：音频层同步 ⏳ 待完成

#### 问题分析

当前 `Channel_Logic.rs` 存在的问题：

1. **直接读取 params** - 使用 `params.channels[i].solo/mute.value()` 而不是 InteractionManager
2. **没有 Compare 模式** - 音频层不知道当前是 Primary 还是 Compare
3. **User Mute SUB 未连接** - `InteractionManager.user_mute_sub` 没有被读取

#### 解决方案

**方案 A：在 InteractionManager 添加音频接口（推荐）**

 

在 `Interaction.rs` 中添加一个专门给音频层使用的函数：

```rust
/// 获取所有通道的音频状态（供 Channel_Logic 使用）
/// 返回 (main_mute_mask, sub_mute_mask) - 位为 1 表示该通道应该静音
pub fn get_audio_mute_masks(&self, layout: &Layout) -> (u32, u32) {
    let primary = *self.primary.read();

    // Idle 状态：所有通道都响
    if primary == PrimaryMode::None {
        return (0, 0);
    }

    // Compare 模式下，使用 Compare 的集合
    let compare = *self.compare.read();
    let active_set = match compare {
        CompareMode::Solo => *self.solo_set.read(),
        CompareMode::Mute => *self.mute_set.read(),
        CompareMode::None => match primary {
            PrimaryMode::Solo => *self.solo_set.read(),
            PrimaryMode::Mute => *self.mute_set.read(),
            PrimaryMode::None => unreachable!(),
        }
    };

    let context_type = match compare {
        CompareMode::Solo => ContextType::Solo,
        CompareMode::Mute => ContextType::Mute,
        CompareMode::None => match primary {
            PrimaryMode::Solo => ContextType::Solo,
            PrimaryMode::Mute => ContextType::Mute,
            PrimaryMode::None => unreachable!(),
        }
    };

    // === 计算 Main 通道的 mute mask ===
    let main_mute_mask = match context_type {
        ContextType::Solo => {
            if active_set.main == 0 {
                0  // 没有 Solo，全部响
            } else {
                !active_set.main  // Solo 的响，其他静
            }
        }
        ContextType::Mute => {
            active_set.main  // Mute 的静，其他响
        }
    };

    // === 计算 SUB 通道的 mute mask ===
    // SUB 使用 Primary 的集合！
    let (sub_context, sub_set) = match primary {
        PrimaryMode::Solo => (ContextType::Solo, self.solo_set.read().sub),
        PrimaryMode::Mute => (ContextType::Mute, self.mute_set.read().sub),
        PrimaryMode::None => unreachable!(),
    };

    // User Mute SUB (优先级最高)
    let user_mute_sub = *self.user_mute_sub.read();

    // 检查 Main 是否有声音
    let main_has_sound = main_mute_mask != 0xFFFFFFFF;  // 不全静

    let sub_mute_mask = if !main_has_sound {
        0xFFFFFFFF  // Main 全静，SUB 全静
    } else {
        let base_mask = match sub_context {
            ContextType::Solo => {
                if sub_set == 0 {
                    0  // 没有 SUB Solo，全部响（豁免权）
                } else {
                    !sub_set  // Solo 的响，其他静
                }
            }
            ContextType::Mute => {
                sub_set  // Mute 的静，其他响
            }
        };
        base_mask | user_mute_sub  // 合并 User Mute
    };

    (main_mute_mask, sub_mute_mask)
}
```

**方案 B：修改 Channel_Logic 调用 InteractionManager**

 

修改 `Channel_Logic::compute()` 函数：

```rust
pub fn compute(
    params: &MonitorParams,
    layout: &Layout,
    override_role: Option<PluginRole>,
    interaction: &InteractionManager,  // 新增参数
) -> RenderState {
    // ... 前面的代码不变 ...

    // 获取 InteractionManager 的状态
    let (main_mute_mask, sub_mute_mask) = interaction.get_audio_mute_masks(layout);

    // 使用 mute mask 替代直接读取 params.channels[i].solo/mute
    for i in 0..layout.total_channels {
        if i >= MAX_CHANNELS { break; }

        let channel_info = layout.main_channels.iter()
            .chain(layout.sub_channels.iter())
            .find(|ch| ch.channel_index == i);

        let is_sub = channel_info.map(|ch| ch.name.contains("SUB")).unwrap_or(false);
        let channel_trim = params.channels[i].gain.value();

        // 使用 InteractionManager 的 mute mask
        let is_muted = if is_sub {
            (sub_mute_mask >> i) & 1 == 1
        } else {
            (main_mute_mask >> i) & 1 == 1
        };

        state.channel_gains[i] = if is_muted { 0.0 } else { channel_trim };

        if is_muted {
            state.channel_mute_mask |= 1 << i;
        }
    }

    state
}
```

#### 关键修改文件

1. **Interaction.rs** - 添加 `get_audio_mute_masks()` 函数
2. **Channel_Logic.rs** - 修改 `compute()` 使用 InteractionManager
3. **调用点** - 找到调用 `ChannelLogic::compute()` 的地方，传入 InteractionManager

#### 调用点分析（已确认）

**调用位置**：`Audio.rs:46`

```rust
let state = ChannelLogic::compute(params, &layout, None);
```

**架构理解**：

- `Audio.rs::process_audio()` 是音频处理入口
- Master/Standalone 模式：本地计算 RenderState，广播给 Slave
- Slave 模式：从网络接收 RenderState

**修改策略**： 只需要修改 Master/Standalone 模式的计算逻辑，Slave 会自动从网络同步。

## 下一步行动（具体实现）

### Step 1: 修改 Interaction.rs

添加 `get_audio_mute_masks()` 函数（参见上面方案 A 的代码）。

### Step 2: 修改 Channel_Logic.rs

修改 `ChannelLogic::compute()` 签名，增加 InteractionManager 参数：

```rust
use crate::Interaction::get_interaction_manager;

pub fn compute(
    params: &MonitorParams,
    layout: &Layout,
    override_role: Option<PluginRole>,
) -> RenderState {
    // ... 前面保持不变 ...

    let interaction = get_interaction_manager();

    // 获取 InteractionManager 的 mute mask
    let (main_mute_mask, sub_mute_mask) = interaction.get_audio_mute_masks();

    // 修改通道增益计算
    for i in 0..layout.total_channels {
        if i >= MAX_CHANNELS { break; }

        let channel_info = layout.main_channels.iter()
            .chain(layout.sub_channels.iter())
            .find(|ch| ch.channel_index == i);

        let is_sub = channel_info.map(|ch| ch.name.contains("SUB")).unwrap_or(false);
        let channel_trim = params.channels[i].gain.value();

        // 使用 InteractionManager 的 mute mask
        let is_muted = if is_sub {
            (sub_mute_mask >> i) & 1 == 1
        } else {
            (main_mute_mask >> i) & 1 == 1
        };

        state.channel_gains[i] = if is_muted { 0.0 } else { channel_trim };

        if is_muted {
            state.channel_mute_mask |= 1 << i;
        }
    }

    state
}
```

### Step 3: Audio.rs 无需修改

`Audio.rs` 调用 `ChannelLogic::compute()` 的方式不变，因为 InteractionManager 是全局单例。

### Step 4: 测试验证

1. 进入 Solo 模式 → 点击某个通道 → 音频应该只输出被 Solo 的通道
2. 进入 Mute 模式 → 点击某个通道 → 音频应该静音被 Mute 的通道
3. Compare 模式 → 切换时音频应该正确反转
4. SUB 独立逻辑 → SUB 不参与 Compare 反转
5. User Mute SUB → 双击 SUB 应该强制静音

## 完成状态

|功能|UI层|音频层|状态|
|---|---|---|---|
|Solo/Mute 基础逻辑|✅|⏳|待连接|
|Compare 模式|✅|⏳|待连接|
|SUB 豁免权|✅|⏳|待连接|
|SUB 组内竞争|✅|⏳|待连接|
|SUB 不参与反转|✅|⏳|待连接|
|User Mute SUB|✅|⏳|待连接|
|闪烁动画|✅|N/A|完成|

Stayed in plan mode