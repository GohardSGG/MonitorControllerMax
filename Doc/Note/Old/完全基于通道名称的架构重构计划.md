完美！我已经设计好了**完全基于通道名称**的完整方案。

 

核心思路：

1. **ChannelSet 改用 `HashSet<String>`** - 直接存储通道名 "LBF"、"SUB_F" 等
2. **所有接口改为接收 `ch_name: &str`** - 不再使用索引
3. **OSC 层直接传名称** - 删除 `channel_name_to_index()`
4. **完全消除硬编码** - 不需要 `ch >= 12`、`SUB_START_INDEX` 等任何魔法数字

优点：

- ✅ **零硬编码**：完全不需要知道索引范围
- ✅ **零转换**：名称即身份
- ✅ **逻辑清晰**：`solo_set.insert("LBF")` 比位运算直观太多
- ✅ **性能可接受**：HashSet 10ns vs 位图 1ns，对音频插件完全可忽略

这个方案会涉及 4 个文件的修改，但都是机械式替换，风险可控。

Claude’s Plan

# 完全基于通道名称的架构重构计划

## 核心设计原则

**完全基于通道名称，零索引转换，零硬编码**

```
硬件发送: /Monitor/Channel/LBF
         ↓
OSC 提取: "LBF"
         ↓
直接判断: "LBF".starts_with("SUB") → false (Main 通道)
         ↓
存储到: solo_set.insert("LBF")
         ↓
广播时: for name in solo_set { send("/Monitor/Channel/LBF", Solo) }
```

**优点**：

- ✅ 完全动态，无硬编码索引
- ✅ 支持任意数量、任意名称的通道
- ✅ 逻辑清晰，名字即身份
- ✅ 调试友好，日志直接显示通道名

---

## 问题诊断

### 当前问题

- 硬件旋转 Bottom 旋钮，OSC 发送 `/Monitor/Channel/LBF`
- 代码将 "LBF" 转换为索引 12
- Interaction 用 `ch >= 12` 判断 SUB，错误地认为 LBF 是 SUB

### 根本原因

- **不必要的索引转换**：已有通道名 "LBF"，为何要转成索引 12？
- **硬编码判断**：`ch >= 12` 假设 SUB 从索引 12 开始，但 7.1.4.4 配置 SUB 从 16 开始

---

## 重构方案

### 修改 1: ChannelSet 改用 HashSet

**文件**: `Interaction.rs`

 

**当前实现（位图）**：

```rust
pub struct ChannelSet {
    pub main: u32,  // 位图，支持 32 个 Main 通道
    pub sub: u32,   // 位图，支持 32 个 SUB 通道
}

impl ChannelSet {
    pub fn set_main(&mut self, ch: usize, on: bool) {
        if on {
            self.main |= 1 << ch;
        } else {
            self.main &= !(1 << ch);
        }
    }
}
```

**新实现（基于名称）**：

```rust
use std::collections::HashSet;

pub struct ChannelSet {
    channels: HashSet<String>,  // 直接存储通道名称
}

impl ChannelSet {
    pub fn new() -> Self {
        Self { channels: HashSet::new() }
    }

    pub fn clear(&mut self) {
        self.channels.clear();
    }

    pub fn is_empty(&self) -> bool {
        self.channels.is_empty()
    }

    /// 切换通道状态
    pub fn toggle(&mut self, ch_name: &str) {
        if self.channels.contains(ch_name) {
            self.channels.remove(ch_name);
        } else {
            self.channels.insert(ch_name.to_string());
        }
    }

    /// 设置通道状态
    pub fn set(&mut self, ch_name: &str, on: bool) {
        if on {
            self.channels.insert(ch_name.to_string());
        } else {
            self.channels.remove(ch_name);
        }
    }

    /// 检查通道是否在集合中
    pub fn contains(&self, ch_name: &str) -> bool {
        self.channels.contains(ch_name)
    }

    /// 获取所有通道名称
    pub fn iter(&self) -> impl Iterator<Item = &String> {
        self.channels.iter()
    }
}
```

**删除的方法**（不再需要区分 main/sub）：

- `toggle_main()` / `toggle_sub()`
- `set_main()` / `set_sub()`
- `contains_main()` / `contains_sub()`

---

### 修改 2: Interaction 接口改为接收通道名称

**文件**: `Interaction.rs`

 

**修改函数签名**：

1. **set_channel_state** (Line ~580):

```rust
// ❌ 旧签名（接收索引）
pub fn set_channel_state(&self, ch: usize, state: u8)

// ✅ 新签名（接收名称）
pub fn set_channel_state(&self, ch_name: &str, state: u8) {
    let ctx = self.get_active_context();

    match ctx {
        Some(ActiveContext::Solo) => {
            let mut solo_set = self.solo_set.write();
            match state {
                0 => solo_set.set(ch_name, false),  // Off = 移除
                2 => solo_set.set(ch_name, true),   // Solo = 加入
                _ => {}
            }
        }
        Some(ActiveContext::Mute) => {
            let mut mute_set = self.mute_set.write();
            match state {
                0 => mute_set.set(ch_name, false),
                1 => mute_set.set(ch_name, true),   // Mute = 加入
                _ => {}
            }
        }
        None => {}
    }
}
```

2. **set_channel_sound** (Line ~645):

```rust
pub fn set_channel_sound(&self, ch_name: &str, has_sound: bool) {
    let ctx = self.get_active_context();

    match ctx {
        Some(ActiveContext::Solo) => {
            self.solo_set.write().set(ch_name, has_sound);
        }
        Some(ActiveContext::Mute) => {
            self.mute_set.write().set(ch_name, !has_sound);
        }
        None => {}
    }
}
```

3. **handle_click** (Line ~896):

```rust
pub fn handle_click(&self, ch_name: &str) {
    // 不再需要判断 is_sub，直接用名字操作
    self.on_channel_click(ch_name);
}

fn on_channel_click(&self, ch_name: &str) {
    let ctx = self.get_active_context();

    match ctx {
        Some(ActiveContext::Solo) => {
            self.solo_set.write().toggle(ch_name);
        }
        Some(ActiveContext::Mute) => {
            self.mute_set.write().toggle(ch_name);
        }
        None => {}
    }
}
```

4. **is_channel_solo** (Line ~943):

```rust
pub fn is_channel_solo(&self, ch_name: &str) -> bool {
    let display = self.get_channel_display(ch_name);
    display.marker == Some(ChannelMarker::Solo)
}
```

5. **is_channel_muted** (Line ~955):

```rust
pub fn is_channel_muted(&self, ch_name: &str) -> bool {
    let display = self.get_channel_display(ch_name);
    display.marker == Some(ChannelMarker::Mute)
}
```

6. **get_channel_display** - 核心查询函数：

```rust
pub fn get_channel_display(&self, ch_name: &str) -> ChannelDisplay {
    let primary = *self.primary.read();
    let compare = *self.compare.read();
    let solo_set = self.solo_set.read();
    let mute_set = self.mute_set.read();

    let in_solo = solo_set.contains(ch_name);
    let in_mute = mute_set.contains(ch_name);

    // 根据 Primary/Compare 模式决定显示
    match (primary, compare) {
        (PrimaryMode::Solo, CompareMode::None) => {
            // Solo 常亮
            if in_solo {
                ChannelDisplay { marker: Some(ChannelMarker::Solo), blinking: false }
            } else {
                ChannelDisplay { marker: None, blinking: false }
            }
        }
        // ... 其他模式组合
    }
}
```

---

### 修改 3: OSC 层直接传递通道名称

**文件**: `Osc.rs`

 

**修改 handle_channel_click**：

```rust
// 当前实现（转换为索引）
fn handle_channel_click(name: &str, value: f32) {
    if let Some(ch) = channel_name_to_index(name) {
        INTERACTION.handle_click(ch);  // 传索引
    }
}

// ✅ 新实现（直接传名称）
fn handle_channel_click(name: &str, value: f32) {
    INTERACTION.handle_click(name);  // 直接传名称
}
```

**删除 channel_name_to_index**（不再需要）：

```rust
// ❌ 删除这个函数
fn channel_name_to_index(name: &str) -> Option<usize> { ... }
```

**保留 channel_index_to_name**（用于 GUI → OSC 的反向查询）

---

### 修改 4: 广播时遍历通道名称列表

**文件**: `Osc.rs`

```rust
pub fn broadcast_channel_states() {
    let curr = CURRENT_CHANNEL_NAMES.read();
    let prev = PREV_CHANNEL_NAMES.read();

    // 1. 广播当前布局的所有通道状态
    for ch_name in curr.iter() {
        let state = if INTERACTION.is_channel_solo(ch_name) {
            ChannelLedState::Solo
        } else if INTERACTION.is_channel_muted(ch_name) {
            ChannelLedState::Mute
        } else {
            ChannelLedState::Off
        };
        OSC_SENDER.send_channel_led_by_name(ch_name, state);
    }

    // 2. 清空「之前存在但现在不存在」的通道
    let curr_set: HashSet<_> = curr.iter().collect();
    for ch_name in prev.iter() {
        if !curr_set.contains(ch_name) {
            OSC_SENDER.send_channel_led_by_name(ch_name, ChannelLedState::Off);
        }
    }
}
```

---

### 修改 5: GUI 和 Channel_Logic 适配

**文件**: `Channel_Logic.rs`、`Editor.rs`

 

需要将所有调用 `INTERACTION.set_channel_state(ch, state)` 的地方改为传递通道名称。

 

**方案**：从 `ChannelInfo` 中获取名称

```rust
// 当前（使用索引）
for (idx, ch_info) in layout.main_channels.iter().enumerate() {
    INTERACTION.set_channel_state(idx, state);
}

// ✅ 新方案（使用名称）
for ch_info in layout.main_channels.iter() {
    INTERACTION.set_channel_state(&ch_info.name, state);
}
```

---

## 修改文件清单

|文件|修改内容|
|---|---|
|`Interaction.rs`|✅ `ChannelSet` 改为 `HashSet<String>`<br>✅ 所有接口改为接收 `ch_name: &str`<br>✅ 删除 `set_main/set_sub` 等方法|
|`Osc.rs`|✅ `handle_channel_click` 直接传名称<br>✅ 删除 `channel_name_to_index`<br>✅ `broadcast_channel_states` 遍历名称列表|
|`Channel_Logic.rs`|✅ 所有调用改为传递 `ch_info.name`|
|`Editor.rs`|✅ 参数同步时使用通道名称|

---

## 优点总结

1. **零硬编码**：完全不需要知道 SUB 从索引几开始
2. **零索引转换**：名称即身份，无需映射
3. **完全动态**：支持任意数量、任意名称的通道（甚至可以支持未来的 "HEIGHT_L"）
4. **逻辑清晰**：`solo_set.insert("LBF")` 比 `solo_set.main |= 1 << 12` 直观
5. **调试友好**：日志显示 "LBF" 而不是索引 12
6. **性能可接受**：HashSet 查找 O(1)，20 个通道完全无压力

---

## 性能对比

|操作|BitArray|HashSet<String>|
|---|---|---|
|查询|~1ns (位运算)|~10ns (哈希查找)|
|插入|~1ns|~10ns|
|内存|8 bytes (2×u32)|~500 bytes (20个通道)|

**结论**：对于音频插件（处理时间微秒级），10ns 的差异完全可忽略。代码清晰度 >> 纳秒级性能差异。

---

## 测试验证

1. **Bottom 响应**：7.1.4.4 配置下，旋转 Bottom 旋钮，验证 VST GUI 显示正确的 Bottom 通道
2. **SUB 响应**：7.1.4.4 配置下，旋转 SUB 旋钮，验证 VST GUI 显示正确的 SUB 通道
3. **配置切换**：2.0 ↔ 7.1.4 ↔ 7.1.4.4，验证所有通道正确识别
4. **Solo/Mute**：任意配置下测试 Solo/Mute，验证状态正确