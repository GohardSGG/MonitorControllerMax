## 当前通信机制 - 使用流程视角

### 一、三种运行模式

插件有一个 `Role` 参数，决定运行模式：

|模式|用途|网络|OSC 硬件|
|---|---|---|---|
|**Standalone**|单机使用|❌ 无|✅ 有|
|**Master**|主控端|✅ 广播状态|✅ 有|
|**Slave**|从属端|✅ 接收状态|❌ 无|

---

### 二、Standalone 模式（最简单）

**场景**：你只有一台电脑、一个 DAW 实例

```
┌─────────────────────────────────────────────────────────┐
│  DAW (单实例)                                            │
│  ┌───────────────────────┐                              │
│  │ MonitorControllerMax  │◄──── OSC ────► Loupedeck    │
│  │ (Standalone 模式)      │     7444/7445              │
│  └───────────────────────┘                              │
└─────────────────────────────────────────────────────────┘
```

**使用流程**：

1. 在 DAW 中加载插件
2. 设置 Role = Standalone
3. 插件直接计算音频，同时通过 OSC 与 Loupedeck 通信

---

### 三、Master-Slave 模式

**场景**：多个 DAW 实例需要同步监听控制

```
┌─────────────────────────────────────────────────────────┐
│  DAW 实例 A (例如：主混音工程)                            │
│  ┌───────────────────────┐                              │
│  │ MonitorControllerMax  │◄──── OSC ────► Loupedeck    │
│  │ (Master 模式)          │     7444/7445              │
│  └─────────┬─────────────┘                              │
│            │ ZMQ PUB (端口 9123)                         │
│            │ 广播 RenderState                            │
└────────────┼────────────────────────────────────────────┘
             │
             ▼ (本机 127.0.0.1)
┌────────────┴────────────────────────────────────────────┐
│  DAW 实例 B (例如：参考工程)                              │
│  ┌───────────────────────┐                              │
│  │ MonitorControllerMax  │  ← 无 OSC（不控制硬件）        │
│  │ (Slave 模式)           │                              │
│  └───────────────────────┘                              │
│  音频跟随 Master 的增益/静音状态                          │
└─────────────────────────────────────────────────────────┘
```

**数据流**：

1. **Master** 计算 `RenderState`（增益、静音掩码）
2. **Master** 通过 ZMQ 广播状态到端口 9123
3. **Slave** 订阅 127.0.0.1:9123，接收状态
4. **Slave** 直接使用收到的状态处理音频（不自己计算）

---

### 四、当前限制

|限制|说明|
|---|---|
|**仅本机**|Slave 硬编码连接 `127.0.0.1:9123`，不支持跨机|
|**无配置界面**|端口、IP 都是代码写死的|
|**无连接状态**|UI 不显示 Slave 是否已连接 Master|
|**断连行为**|Slave 断连后保持最后状态或静音（安全模式）|

---

### 五、验证步骤建议

**1. 先验证 Standalone 模式**（最简单）：

- 打开一个 DAW
- 加载插件，设置 Role = Standalone
- 播放音频，测试 Cut/Dim/Solo/Mute

**2. 再验证 Master-Slave**：

- 打开 DAW 实例 A，加载插件，设置 Role = Master
- 打开 DAW 实例 B，加载插件，设置 Role = Slave
- 在 A 中操作，观察 B 是否跟随

# MonitorControllerMax Master-Slave 通信改进计划

## 已完成的任务 ✅

- 小按钮反馈机制 (MONO, LFE +10dB, Low Boost, High Boost)
- 按钮高度统一 (46px)
- DIM 按钮颜色改为淡黄色
- 齿轮按钮位置移动

---

## 当前需求

### 1. EVENT LOG 窗口显示实际内容

**问题**: EVENT LOG 面板只显示 "-- No events logged --" 占位符，从不显示任何内容

 

**根因分析**:

- UI 在 `Editor.rs:956-1025` 的 `render_log_panel()` 函数
- 只有占位符逻辑，没有实际日志缓冲区
- `logger.rs` 只写入文件，不连接到 UI

### 2. 显示 Master-Slave 连接状态

**需求**:

- 在 EVENT LOG 中显示连接/断开提示
- Slave 连接到 Master 时显示通知
- Master 有 Slave 连接时显示通知
- 断开连接时显示警告

### 3. Slave 必须跟随 Master 的通道布局

**问题**: `NetworkRenderState` 不包含布局信息 (Map 状态)

- Slave 和 Master 可能有不同的通道数量
- 这会导致混乱和不一致

### 4. Slave UI 通道区域应该禁用

**需求**:

- Slave 模式下通道区域显示灰色覆盖层
- 禁止点击通道区域 (只能由 Master 控制)

---

## 实现方案

### 模块 1: UI 日志缓冲区系统

**新增文件**: `Source/Plugin/Src/ui_log.rs`

```rust
use crossbeam::channel::{bounded, Receiver, Sender};
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};
use once_cell::sync::Lazy;

const MAX_LOG_ENTRIES: usize = 100;

#[derive(Clone)]
pub struct LogEntry {
    pub timestamp: String,
    pub level: LogLevel,
    pub message: String,
}

#[derive(Clone, Copy)]
pub enum LogLevel {
    Info,
    Warning,
    Error,
    Connection,  // 专门用于连接状态
}

pub struct UILogBuffer {
    sender: Sender<LogEntry>,
    receiver: Receiver<LogEntry>,
    entries: Arc<Mutex<VecDeque<LogEntry>>>,
}

impl UILogBuffer {
    pub fn new() -> Self {
        let (sender, receiver) = bounded(100);
        Self {
            sender,
            receiver,
            entries: Arc::new(Mutex::new(VecDeque::with_capacity(MAX_LOG_ENTRIES))),
        }
    }

    /// 发送日志 (从任何线程调用)
    pub fn log(&self, level: LogLevel, message: impl Into<String>) {
        let entry = LogEntry {
            timestamp: chrono::Local::now().format("%H:%M:%S").to_string(),
            level,
            message: message.into(),
        };
        let _ = self.sender.try_send(entry);
    }

    /// UI 线程调用: 处理待处理消息并返回所有条目
    pub fn drain_and_get(&self) -> Vec<LogEntry> {
        let mut entries = self.entries.lock().unwrap();

        // 处理所有待处理消息
        while let Ok(entry) = self.receiver.try_recv() {
            if entries.len() >= MAX_LOG_ENTRIES {
                entries.pop_front();
            }
            entries.push_back(entry);
        }

        entries.iter().cloned().collect()
    }
}

pub static UI_LOG: Lazy<UILogBuffer> = Lazy::new(UILogBuffer::new);

// 便捷宏
#[macro_export]
macro_rules! ui_log_info {
    ($($arg:tt)*) => {
        $crate::ui_log::UI_LOG.log($crate::ui_log::LogLevel::Info, format!($($arg)*))
    };
}

#[macro_export]
macro_rules! ui_log_connection {
    ($($arg:tt)*) => {
        $crate::ui_log::UI_LOG.log($crate::ui_log::LogLevel::Connection, format!($($arg)*))
    };
}
```

**修改文件**: `Source/Plugin/Src/Editor.rs`

```rust
// render_log_panel() 函数修改
fn render_log_panel(&mut self, ui: &mut egui::Ui, scale: &Scale) {
    let entries = ui_log::UI_LOG.drain_and_get();

    egui::ScrollArea::vertical()
        .auto_shrink([false, false])
        .stick_to_bottom(true)
        .show(ui, |ui| {
            if entries.is_empty() {
                ui.label("-- No events logged --");
            } else {
                for entry in entries {
                    let color = match entry.level {
                        LogLevel::Info => Color32::WHITE,
                        LogLevel::Warning => Color32::YELLOW,
                        LogLevel::Error => Color32::RED,
                        LogLevel::Connection => Color32::GREEN,
                    };
                    ui.horizontal(|ui| {
                        ui.label(RichText::new(&entry.timestamp).color(Color32::GRAY));
                        ui.label(RichText::new(&entry.message).color(color));
                    });
                }
            }
        });
}
```

---

### 模块 2: Master-Slave 连接状态追踪

**修改文件**: `Source/Plugin/Src/Network.rs`

```rust
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::time::{Duration, Instant};

// 新增: 连接状态追踪
pub struct ConnectionStatus {
    // Master 端: 最后收到的 Slave 心跳时间
    last_slave_heartbeat: AtomicU64,
    slave_connected: AtomicBool,

    // Slave 端: 最后收到的 Master 数据时间
    last_master_data: AtomicU64,
    master_connected: AtomicBool,
}

impl ConnectionStatus {
    const TIMEOUT_MS: u64 = 3000;  // 3秒超时

    pub fn update_slave_heartbeat(&self) {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;

        let was_connected = self.slave_connected.load(Ordering::SeqCst);
        self.last_slave_heartbeat.store(now, Ordering::SeqCst);

        if !was_connected {
            self.slave_connected.store(true, Ordering::SeqCst);
            ui_log_connection!("Slave 已连接");
        }
    }

    pub fn check_timeouts(&self) {
        let now = /* current time */;

        // 检查 Slave 超时
        if self.slave_connected.load(Ordering::SeqCst) {
            let last = self.last_slave_heartbeat.load(Ordering::SeqCst);
            if now - last > Self::TIMEOUT_MS {
                self.slave_connected.store(false, Ordering::SeqCst);
                ui_log_connection!("Slave 已断开");
            }
        }

        // 类似地检查 Master 超时 (Slave 端)
    }
}

pub static CONNECTION_STATUS: Lazy<ConnectionStatus> = Lazy::new(/* ... */);
```

---

### 模块 3: NetworkRenderState 扩展 - 布局同步

**修改文件**: `Source/Plugin/Src/Network_Protocol.rs`

```rust
// 当前结构
pub struct NetworkRenderState {
    pub master_gain: f32,
    pub channel_gains: [f32; MAX_CHANNELS],
    pub channel_mute_mask: u32,
    pub timestamp: u64,
    pub magic: u16,
}

// 扩展为:
pub struct NetworkRenderState {
    pub master_gain: f32,
    pub channel_gains: [f32; MAX_CHANNELS],
    pub channel_mute_mask: u32,
    pub timestamp: u64,
    pub magic: u16,

    // 新增: 布局信息
    pub layout_id: u8,        // 对应 Map 选择 (0=7.1.4, 1=7.1, etc.)
    pub channel_count: u8,    // 激活的通道数
}
```

**修改文件**: `Source/Plugin/Src/Network.rs` (Master 端)

```rust
// 在广播状态时包含当前布局
fn broadcast_state(&self, params: &MonitorControllerMaxParams) {
    let state = NetworkRenderState {
        master_gain: params.master_gain.value(),
        channel_gains: /* ... */,
        channel_mute_mask: /* ... */,
        timestamp: /* ... */,
        magic: 0x4D43,
        layout_id: params.current_layout.load(Ordering::SeqCst),
        channel_count: get_channel_count_for_layout(layout_id),
    };
    // 发送...
}
```

**修改文件**: `Source/Plugin/Src/Network.rs` (Slave 端)

```rust
// 接收到 Master 状态时同步布局
fn on_receive_master_state(&self, state: &NetworkRenderState) {
    // 同步布局
    if self.current_layout != state.layout_id {
        self.set_layout(state.layout_id);
        ui_log_info!("布局已同步: {}", get_layout_name(state.layout_id));
    }

    // 同步其他状态...
}
```

---

### 模块 4: Slave UI 限制

**修改文件**: `Source/Plugin/Src/Editor.rs`

```rust
// 在渲染通道区域时检查角色
fn render_channel_area(&mut self, ui: &mut egui::Ui, params: &Params) {
    let is_slave = params.role.value() == Role::Slave;

    if is_slave {
        // 绘制灰色覆盖层
        let rect = ui.available_rect_before_wrap();
        ui.painter().rect_filled(
            rect,
            0.0,
            Color32::from_rgba_unmultiplied(128, 128, 128, 180)  // 半透明灰色
        );

        // 显示提示文字
        ui.centered_and_justified(|ui| {
            ui.label(RichText::new("Slave Mode - 由 Master 控制")
                .color(Color32::WHITE)
                .size(16.0));
        });

        // 禁用交互 - 使用 ui.set_enabled(false)
        return;
    }

    // 正常渲染通道控件...
}
```

**关键点**: 使用 `ui.set_enabled(false)` 或 `ui.disable()` 阻止 Slave 模式下的通道交互

---

## 修改文件清单

|文件|修改内容|
|---|---|
|`Source/Plugin/Src/ui_log.rs`|**新建** - UI 日志缓冲区系统|
|`Source/Plugin/Src/mod.rs`|添加 `pub mod ui_log;`|
|`Source/Plugin/Src/Editor.rs`|修改 `render_log_panel()`; 添加 Slave 覆盖层逻辑|
|`Source/Plugin/Src/Network.rs`|添加 `ConnectionStatus`; 心跳/超时检测; 布局同步逻辑|
|`Source/Plugin/Src/Network_Protocol.rs`|扩展 `NetworkRenderState` 添加 `layout_id`, `channel_count`|

---

## 执行顺序

### 阶段 1: UI 日志系统

1. 创建 `ui_log.rs`
2. 在 `mod.rs` 中注册模块
3. 修改 `Editor.rs` 的 `render_log_panel()`
4. 测试日志显示

### 阶段 2: 连接状态追踪

1. 在 `Network.rs` 添加 `ConnectionStatus`
2. 实现心跳/超时检测
3. 在连接/断开时调用 `ui_log_connection!`
4. 测试连接状态显示

### 阶段 3: 布局同步

1. 扩展 `NetworkRenderState`
2. Master 端发送布局信息
3. Slave 端接收并同步布局
4. 测试布局同步

### 阶段 4: Slave UI 限制

1. 在通道区域渲染前检查角色
2. 添加灰色覆盖层
3. 禁用交互
4. 测试 Slave 模式 UI

---

## 风险与注意事项

1. **向后兼容**: `NetworkRenderState` 扩展会改变数据包大小，需要版本检测或固定格式
2. **线程安全**: `UILogBuffer` 使用 crossbeam channel 确保线程安全
3. **性能**: 日志系统使用 bounded channel 防止内存溢出
4. **超时值**: 3秒超时需要根据实际网络情况调整
## 风险解决方案概要

|风险|解决方案|
|---|---|
|**向后兼容**|Magic 字段版本区分 (V1=0x4D43, V2=0x4D44)，支持新旧版本互联|
|**线程安全**|crossbeam bounded channel + try_send 非阻塞，满时丢弃不阻塞|
|**性能**|50条消息缓冲上限，UI每帧批量处理，写入<1μs|
|**超时检测**|3秒默认超时 + 防重复日志标志 + 定期检查|

## 协议升级策略

- **V1 (0x4D43)**: 现有格式，保持不变
- **V2 (0x4D44)**: 新增 `layout_id` + `channel_count` + 4字节预留
- Slave 先尝试 V2，失败回退 V1

## 执行分 6 个阶段

1. 基础设施 (ui_log.rs)
2. UI 日志显示
3. 连接状态追踪
4. 协议升级 (V1/V2)
5. 布局同步
6. Slave UI 限制

Claude’s Plan

# MonitorControllerMax Master-Slave 通信改进计划

## 已完成的任务 ✅

- 小按钮反馈机制 (MONO, LFE +10dB, Low Boost, High Boost)
- 按钮高度统一 (46px)
- DIM 按钮颜色改为淡黄色
- 齿轮按钮位置移动

---

## 当前需求

### 1. EVENT LOG 窗口显示实际内容

**问题**: EVENT LOG 面板只显示 "-- No events logged --" 占位符，从不显示任何内容

 

**根因分析**:

- UI 在 `Editor.rs:956-1025` 的 `render_log_panel()` 函数
- 只有占位符逻辑，没有实际日志缓冲区
- `logger.rs` 只写入文件，不连接到 UI

### 2. 显示 Master-Slave 连接状态

**需求**:

- 在 EVENT LOG 中显示连接/断开提示
- Slave 连接到 Master 时显示通知
- Master 有 Slave 连接时显示通知
- 断开连接时显示警告

### 3. Slave 必须跟随 Master 的通道布局

**问题**: `NetworkRenderState` 不包含布局信息 (Map 状态)

- Slave 和 Master 可能有不同的通道数量
- 这会导致混乱和不一致

### 4. Slave UI 通道区域应该禁用

**需求**:

- Slave 模式下通道区域显示灰色覆盖层
- 禁止点击通道区域 (只能由 Master 控制)

---

## 实现方案

### 模块 1: UI 日志缓冲区系统

**新增文件**: `Source/Plugin/Src/ui_log.rs`

```rust
use crossbeam::channel::{bounded, Receiver, Sender};
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};
use once_cell::sync::Lazy;

const MAX_LOG_ENTRIES: usize = 100;

#[derive(Clone)]
pub struct LogEntry {
    pub timestamp: String,
    pub level: LogLevel,
    pub message: String,
}

#[derive(Clone, Copy)]
pub enum LogLevel {
    Info,
    Warning,
    Error,
    Connection,  // 专门用于连接状态
}

pub struct UILogBuffer {
    sender: Sender<LogEntry>,
    receiver: Receiver<LogEntry>,
    entries: Arc<Mutex<VecDeque<LogEntry>>>,
}

impl UILogBuffer {
    pub fn new() -> Self {
        let (sender, receiver) = bounded(100);
        Self {
            sender,
            receiver,
            entries: Arc::new(Mutex::new(VecDeque::with_capacity(MAX_LOG_ENTRIES))),
        }
    }

    /// 发送日志 (从任何线程调用)
    pub fn log(&self, level: LogLevel, message: impl Into<String>) {
        let entry = LogEntry {
            timestamp: chrono::Local::now().format("%H:%M:%S").to_string(),
            level,
            message: message.into(),
        };
        let _ = self.sender.try_send(entry);
    }

    /// UI 线程调用: 处理待处理消息并返回所有条目
    pub fn drain_and_get(&self) -> Vec<LogEntry> {
        let mut entries = self.entries.lock().unwrap();

        // 处理所有待处理消息
        while let Ok(entry) = self.receiver.try_recv() {
            if entries.len() >= MAX_LOG_ENTRIES {
                entries.pop_front();
            }
            entries.push_back(entry);
        }

        entries.iter().cloned().collect()
    }
}

pub static UI_LOG: Lazy<UILogBuffer> = Lazy::new(UILogBuffer::new);

// 便捷宏
#[macro_export]
macro_rules! ui_log_info {
    ($($arg:tt)*) => {
        $crate::ui_log::UI_LOG.log($crate::ui_log::LogLevel::Info, format!($($arg)*))
    };
}

#[macro_export]
macro_rules! ui_log_connection {
    ($($arg:tt)*) => {
        $crate::ui_log::UI_LOG.log($crate::ui_log::LogLevel::Connection, format!($($arg)*))
    };
}
```

**修改文件**: `Source/Plugin/Src/Editor.rs`

```rust
// render_log_panel() 函数修改
fn render_log_panel(&mut self, ui: &mut egui::Ui, scale: &Scale) {
    let entries = ui_log::UI_LOG.drain_and_get();

    egui::ScrollArea::vertical()
        .auto_shrink([false, false])
        .stick_to_bottom(true)
        .show(ui, |ui| {
            if entries.is_empty() {
                ui.label("-- No events logged --");
            } else {
                for entry in entries {
                    let color = match entry.level {
                        LogLevel::Info => Color32::WHITE,
                        LogLevel::Warning => Color32::YELLOW,
                        LogLevel::Error => Color32::RED,
                        LogLevel::Connection => Color32::GREEN,
                    };
                    ui.horizontal(|ui| {
                        ui.label(RichText::new(&entry.timestamp).color(Color32::GRAY));
                        ui.label(RichText::new(&entry.message).color(color));
                    });
                }
            }
        });
}
```

---

### 模块 2: Master-Slave 连接状态追踪

**修改文件**: `Source/Plugin/Src/Network.rs`

```rust
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::time::{Duration, Instant};

// 新增: 连接状态追踪
pub struct ConnectionStatus {
    // Master 端: 最后收到的 Slave 心跳时间
    last_slave_heartbeat: AtomicU64,
    slave_connected: AtomicBool,

    // Slave 端: 最后收到的 Master 数据时间
    last_master_data: AtomicU64,
    master_connected: AtomicBool,
}

impl ConnectionStatus {
    const TIMEOUT_MS: u64 = 3000;  // 3秒超时

    pub fn update_slave_heartbeat(&self) {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;

        let was_connected = self.slave_connected.load(Ordering::SeqCst);
        self.last_slave_heartbeat.store(now, Ordering::SeqCst);

        if !was_connected {
            self.slave_connected.store(true, Ordering::SeqCst);
            ui_log_connection!("Slave 已连接");
        }
    }

    pub fn check_timeouts(&self) {
        let now = /* current time */;

        // 检查 Slave 超时
        if self.slave_connected.load(Ordering::SeqCst) {
            let last = self.last_slave_heartbeat.load(Ordering::SeqCst);
            if now - last > Self::TIMEOUT_MS {
                self.slave_connected.store(false, Ordering::SeqCst);
                ui_log_connection!("Slave 已断开");
            }
        }

        // 类似地检查 Master 超时 (Slave 端)
    }
}

pub static CONNECTION_STATUS: Lazy<ConnectionStatus> = Lazy::new(/* ... */);
```

---

### 模块 3: NetworkRenderState 扩展 - 布局同步

**修改文件**: `Source/Plugin/Src/Network_Protocol.rs`

```rust
// 当前结构
pub struct NetworkRenderState {
    pub master_gain: f32,
    pub channel_gains: [f32; MAX_CHANNELS],
    pub channel_mute_mask: u32,
    pub timestamp: u64,
    pub magic: u16,
}

// 扩展为:
pub struct NetworkRenderState {
    pub master_gain: f32,
    pub channel_gains: [f32; MAX_CHANNELS],
    pub channel_mute_mask: u32,
    pub timestamp: u64,
    pub magic: u16,

    // 新增: 布局信息
    pub layout_id: u8,        // 对应 Map 选择 (0=7.1.4, 1=7.1, etc.)
    pub channel_count: u8,    // 激活的通道数
}
```

**修改文件**: `Source/Plugin/Src/Network.rs` (Master 端)

```rust
// 在广播状态时包含当前布局
fn broadcast_state(&self, params: &MonitorControllerMaxParams) {
    let state = NetworkRenderState {
        master_gain: params.master_gain.value(),
        channel_gains: /* ... */,
        channel_mute_mask: /* ... */,
        timestamp: /* ... */,
        magic: 0x4D43,
        layout_id: params.current_layout.load(Ordering::SeqCst),
        channel_count: get_channel_count_for_layout(layout_id),
    };
    // 发送...
}
```

**修改文件**: `Source/Plugin/Src/Network.rs` (Slave 端)

```rust
// 接收到 Master 状态时同步布局
fn on_receive_master_state(&self, state: &NetworkRenderState) {
    // 同步布局
    if self.current_layout != state.layout_id {
        self.set_layout(state.layout_id);
        ui_log_info!("布局已同步: {}", get_layout_name(state.layout_id));
    }

    // 同步其他状态...
}
```

---

### 模块 4: Slave UI 限制

**修改文件**: `Source/Plugin/Src/Editor.rs`

```rust
// 在渲染通道区域时检查角色
fn render_channel_area(&mut self, ui: &mut egui::Ui, params: &Params) {
    let is_slave = params.role.value() == Role::Slave;

    if is_slave {
        // 绘制灰色覆盖层
        let rect = ui.available_rect_before_wrap();
        ui.painter().rect_filled(
            rect,
            0.0,
            Color32::from_rgba_unmultiplied(128, 128, 128, 180)  // 半透明灰色
        );

        // 显示提示文字
        ui.centered_and_justified(|ui| {
            ui.label(RichText::new("Slave Mode - 由 Master 控制")
                .color(Color32::WHITE)
                .size(16.0));
        });

        // 禁用交互 - 使用 ui.set_enabled(false)
        return;
    }

    // 正常渲染通道控件...
}
```

**关键点**: 使用 `ui.set_enabled(false)` 或 `ui.disable()` 阻止 Slave 模式下的通道交互

---

## 修改文件清单

|文件|修改内容|
|---|---|
|`Source/Plugin/Src/ui_log.rs`|**新建** - UI 日志缓冲区系统|
|`Source/Plugin/Src/mod.rs`|添加 `pub mod ui_log;`|
|`Source/Plugin/Src/Editor.rs`|修改 `render_log_panel()`; 添加 Slave 覆盖层逻辑|
|`Source/Plugin/Src/Network.rs`|添加 `ConnectionStatus`; 心跳/超时检测; 布局同步逻辑|
|`Source/Plugin/Src/Network_Protocol.rs`|扩展 `NetworkRenderState` 添加 `layout_id`, `channel_count`|

---

## 执行顺序

### 阶段 1: UI 日志系统

1. 创建 `ui_log.rs`
2. 在 `mod.rs` 中注册模块
3. 修改 `Editor.rs` 的 `render_log_panel()`
4. 测试日志显示

### 阶段 2: 连接状态追踪

1. 在 `Network.rs` 添加 `ConnectionStatus`
2. 实现心跳/超时检测
3. 在连接/断开时调用 `ui_log_connection!`
4. 测试连接状态显示

### 阶段 3: 布局同步

1. 扩展 `NetworkRenderState`
2. Master 端发送布局信息
3. Slave 端接收并同步布局
4. 测试布局同步

### 阶段 4: Slave UI 限制

1. 在通道区域渲染前检查角色
2. 添加灰色覆盖层
3. 禁用交互
4. 测试 Slave 模式 UI

---

## 风险与解决方案

### 风险 1: 向后兼容 - NetworkRenderState 扩展

**问题**: 扩展结构体会改变数据包大小，旧版 Slave 无法解析新版 Master 的数据

 

**解决方案**: 使用 Magic 字段进行版本区分

```rust
// Network_Protocol.rs

// 协议版本常量
pub const MAGIC_V1: u16 = 0x4D43;  // "MC" - 当前版本
pub const MAGIC_V2: u16 = 0x4D44;  // "MD" - 新版本 (带布局)

// V1 结构体 (保持不变，用于兼容)
#[derive(Serialize, Deserialize, Clone, Copy, Debug)]
#[repr(C)]
pub struct NetworkRenderStateV1 {
    pub master_gain: f32,
    pub channel_gains: [f32; MAX_CHANNELS],
    pub channel_mute_mask: u32,
    pub timestamp: u64,
    pub magic: u16,  // = MAGIC_V1
}

// V2 结构体 (新版本)
#[derive(Serialize, Deserialize, Clone, Copy, Debug)]
#[repr(C)]
pub struct NetworkRenderStateV2 {
    pub master_gain: f32,
    pub channel_gains: [f32; MAX_CHANNELS],
    pub channel_mute_mask: u32,
    pub timestamp: u64,
    pub magic: u16,           // = MAGIC_V2
    pub layout_id: u8,        // 布局 ID (0-255)
    pub channel_count: u8,    // 通道数量
    pub _reserved: [u8; 4],   // 预留扩展空间
}

// 统一枚举
pub enum NetworkRenderState {
    V1(NetworkRenderStateV1),
    V2(NetworkRenderStateV2),
}
```

**Slave 端解析逻辑**:

```rust
// Network.rs - Slave 接收逻辑
fn parse_network_state(bytes: &[u8]) -> Option<NetworkRenderState> {
    // 先尝试 V2 (新版本)
    if let Ok(state) = bincode::deserialize::<NetworkRenderStateV2>(bytes) {
        if state.magic == MAGIC_V2 {
            return Some(NetworkRenderState::V2(state));
        }
    }

    // 回退到 V1 (旧版本)
    if let Ok(state) = bincode::deserialize::<NetworkRenderStateV1>(bytes) {
        if state.magic == MAGIC_V1 {
            return Some(NetworkRenderState::V1(state));
        }
    }

    None
}
```

**优点**:

- 新版 Slave 可以连接旧版 Master (V1 协议)
- 新版 Master 可以被旧版 Slave 连接 (旧版忽略新字段导致 magic 不匹配时静默失败)
- 预留 4 字节扩展空间，未来添加字段无需再改协议

---

### 风险 2: 线程安全

**问题**: UI 日志从多个线程写入 (音频线程、网络线程、主线程)

 

**解决方案**: 已采用 crossbeam bounded channel

```rust
// ui_log.rs - 完整实现

use crossbeam::channel::{bounded, Receiver, Sender, TrySendError};
use std::collections::VecDeque;
use std::sync::Mutex;
use once_cell::sync::Lazy;

const MAX_LOG_ENTRIES: usize = 100;
const CHANNEL_CAPACITY: usize = 50;

#[derive(Clone)]
pub struct LogEntry {
    pub timestamp: String,
    pub level: LogLevel,
    pub message: String,
}

#[derive(Clone, Copy, PartialEq)]
pub enum LogLevel {
    Info,
    Warning,
    Error,
    Connection,
}

pub struct UILogBuffer {
    sender: Sender<LogEntry>,
    receiver: Receiver<LogEntry>,
    entries: Mutex<VecDeque<LogEntry>>,  // 只在 UI 线程访问，Mutex 保护即可
}

impl UILogBuffer {
    pub fn new() -> Self {
        let (sender, receiver) = bounded(CHANNEL_CAPACITY);
        Self {
            sender,
            receiver,
            entries: Mutex::new(VecDeque::with_capacity(MAX_LOG_ENTRIES)),
        }
    }

    /// 线程安全：从任何线程调用
    pub fn log(&self, level: LogLevel, message: impl Into<String>) {
        let entry = LogEntry {
            timestamp: chrono::Local::now().format("%H:%M:%S").to_string(),
            level,
            message: message.into(),
        };

        // try_send 不会阻塞，如果 channel 满了就丢弃（日志不能阻塞音频线程）
        match self.sender.try_send(entry) {
            Ok(_) => {},
            Err(TrySendError::Full(_)) => {
                // Channel 满了，静默丢弃 - 不能阻塞调用线程
            },
            Err(TrySendError::Disconnected(_)) => {
                // Channel 断开，不应该发生
            }
        }
    }

    /// 只在 UI 线程调用
    pub fn drain_and_get(&self) -> Vec<LogEntry> {
        let mut entries = self.entries.lock().unwrap();

        // 处理所有待处理消息
        while let Ok(entry) = self.receiver.try_recv() {
            if entries.len() >= MAX_LOG_ENTRIES {
                entries.pop_front();
            }
            entries.push_back(entry);
        }

        entries.iter().cloned().collect()
    }
}

pub static UI_LOG: Lazy<UILogBuffer> = Lazy::new(UILogBuffer::new);
```

**线程安全保证**:

- `Sender<T>` 是 `Clone + Send`，可以安全地从多线程发送
- `try_send()` 非阻塞，不会影响音频线程性能
- `Mutex<VecDeque>` 只在 UI 线程的 `drain_and_get()` 中访问
- Channel 满时静默丢弃，保证不阻塞

---

### 风险 3: 性能

**问题**: 日志系统可能影响音频实时性能

 

**解决方案**:

1. **Bounded Channel**: 限制 50 条消息缓冲，防止内存无限增长
2. **try_send**: 非阻塞发送，满了就丢弃
3. **批量处理**: UI 每帧只调用一次 `drain_and_get()`
4. **字符串预分配**: 日志消息使用 `String::with_capacity()` 减少分配

```rust
// 优化的日志宏 - 避免在音频线程做字符串格式化（如果不需要的话）
#[macro_export]
macro_rules! ui_log_info {
    ($($arg:tt)*) => {{
        // 只有在 UI_LOG channel 未满时才格式化字符串
        $crate::ui_log::UI_LOG.log($crate::ui_log::LogLevel::Info, format!($($arg)*))
    }};
}
```

**性能预算**:

- 日志写入: < 1μs (非阻塞 channel send)
- UI 读取: < 100μs/帧 (最多处理 50 条)

---

### 风险 4: 超时检测

**问题**: 硬编码 3 秒超时可能不适合所有网络环境

 

**解决方案**: 使用可配置的超时 + 心跳机制

```rust
// Network.rs

pub struct ConnectionStatus {
    // 配置
    timeout_ms: AtomicU64,  // 默认 3000ms，可配置

    // Master 端状态
    last_slave_heartbeat: AtomicU64,
    slave_connected: AtomicBool,
    slave_disconnect_logged: AtomicBool,  // 防止重复日志

    // Slave 端状态
    last_master_data: AtomicU64,
    master_connected: AtomicBool,
    master_disconnect_logged: AtomicBool,
}

impl ConnectionStatus {
    pub const DEFAULT_TIMEOUT_MS: u64 = 3000;

    pub fn new() -> Self {
        Self {
            timeout_ms: AtomicU64::new(Self::DEFAULT_TIMEOUT_MS),
            last_slave_heartbeat: AtomicU64::new(0),
            slave_connected: AtomicBool::new(false),
            slave_disconnect_logged: AtomicBool::new(false),
            last_master_data: AtomicU64::new(0),
            master_connected: AtomicBool::new(false),
            master_disconnect_logged: AtomicBool::new(false),
        }
    }

    fn current_time_ms() -> u64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64
    }

    /// Slave 端调用: 收到 Master 数据时
    pub fn on_master_data_received(&self) {
        let now = Self::current_time_ms();
        self.last_master_data.store(now, Ordering::SeqCst);

        if !self.master_connected.swap(true, Ordering::SeqCst) {
            // 首次连接
            self.master_disconnect_logged.store(false, Ordering::SeqCst);
            ui_log_connection!("已连接到 Master");
        }
    }

    /// 定期调用 (每秒一次) - 检查超时
    pub fn check_timeouts(&self) {
        let now = Self::current_time_ms();
        let timeout = self.timeout_ms.load(Ordering::SeqCst);

        // 检查 Master 连接 (Slave 端)
        if self.master_connected.load(Ordering::SeqCst) {
            let last = self.last_master_data.load(Ordering::SeqCst);
            if now.saturating_sub(last) > timeout {
                self.master_connected.store(false, Ordering::SeqCst);

                // 防止重复日志
                if !self.master_disconnect_logged.swap(true, Ordering::SeqCst) {
                    ui_log_connection!("与 Master 的连接已断开 (超时)");
                }
            }
        }

        // 检查 Slave 连接 (Master 端) - 类似逻辑
    }

    // Getter 方法供 UI 使用
    pub fn is_master_connected(&self) -> bool {
        self.master_connected.load(Ordering::SeqCst)
    }

    pub fn is_slave_connected(&self) -> bool {
        self.slave_connected.load(Ordering::SeqCst)
    }
}

pub static CONNECTION_STATUS: Lazy<ConnectionStatus> = Lazy::new(ConnectionStatus::new);
```

**心跳触发点**:

- Master: 每次 `process()` 调用时广播状态 (自然心跳)
- Slave: 收到数据即视为心跳
- 超时检测: 在 UI 渲染循环中每秒检查一次

---

## 最终修改文件清单

|文件|修改内容|
|---|---|
|`Source/Plugin/Src/ui_log.rs`|**新建** - 完整 UI 日志缓冲区系统|
|`Source/Plugin/Src/mod.rs`|添加 `pub mod ui_log;`|
|`Source/Plugin/Src/Editor.rs`|修改 `render_log_panel()`; Slave 覆盖层; 每秒调用超时检测|
|`Source/Plugin/Src/Network.rs`|添加 `ConnectionStatus`; 心跳/超时; 布局同步; 协议解析|
|`Source/Plugin/Src/Network_Protocol.rs`|V1/V2 协议定义; Magic 常量|
|`Cargo.toml`|添加 `chrono` 依赖 (时间戳格式化)|

---

## 执行顺序 (最终版)

### 阶段 1: 基础设施

1. 检查 `Cargo.toml` 是否已有 `chrono` 依赖，没有则添加
2. 创建 `ui_log.rs` (完整实现)
3. 在 `mod.rs` 中注册模块
4. 构建验证

### 阶段 2: UI 日志显示

1. 修改 `Editor.rs` 的 `render_log_panel()` 读取日志缓冲区
2. 添加测试日志 `ui_log_info!("Plugin initialized")`
3. 验证日志显示

### 阶段 3: 连接状态

1. 在 `Network.rs` 添加 `ConnectionStatus`
2. 在 Slave 接收数据时调用 `on_master_data_received()`
3. 在 UI 循环添加超时检测调用
4. 测试连接/断开日志

### 阶段 4: 协议升级

1. 修改 `Network_Protocol.rs` 添加 V1/V2 定义
2. Master 发送 V2 协议 (带 layout_id)
3. Slave 解析时支持 V1/V2 回退
4. 测试新旧版本兼容

### 阶段 5: 布局同步

1. Slave 收到 V2 数据时同步 layout_id
2. 添加布局同步日志
3. 测试布局同步

### 阶段 6: Slave UI 限制

1. 在通道区域添加 Slave 模式检测
2. 绘制灰色覆盖层
3. 禁用交互
4. 完整测试