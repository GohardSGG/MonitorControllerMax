我们现在的核心目标是：将 C++ 中复杂的、分散在 StateManager、PluginProcessor 和 SemanticChannelState 中的有状态逻辑，重构为 Rust 中清晰的、单向流动的“参数 -> 纯逻辑 -> 渲染状态”模型。

以下是详细的实施方案，请审核：

---

### 1. 核心设计理念转变：从“指令式”到“声明式”

- 旧架构 (C++): 当用户点击 Solo 时，代码会去修改其他通道的 Mute 状态（Destructive），并且需要复杂的变量（如 user_mute_memory）来记住之前的状态以便恢复。这导致了复杂的“状态恢复”逻辑和死锁风险。

- 新架构 (Rust):

- Params (参数) 只记录用户意图（User Intent）。即：用户是否按下了 Mute？用户是否按下了 Solo？

- Logic (逻辑) 每一帧都根据当前的参数，实时计算出最终的音频增益。

- 优势: 我们不需要“保存并恢复”Mute 状态。当 Solo 取消时，由于 Mute 参数本身从未被修改过，系统自然会“回退”到用户设定的 Mute 状态。

---

### 2. 详细模块实现方案

#### 2.1 模块一：参数定义 (Params) - 真理之源

我们需要在 lib.rs 中定义 MonitorParams 结构体，它包含所有的持久化状态。

- 设计逻辑:

- 通道参数: 展平处理。使用 Vec<BoolParam> 或固定数组存储 18 个通道的 Mute 和 Solo 状态。

- 全局参数: MasterGain, Dim, Cut。

- 配置参数: SoloMode (Enum: SIP, PFL, etc.)。

- 关键点: 这里不存储“Auto-Mute”状态。Auto-Mute 是计算结果，不是参数。

#### 2.2 模块二：语义逻辑核心 (ChannelLogic) - 纯函数

这是迁移的重中之重。我们将 架构.md 中的“真值表”逻辑封装为一个纯 Rust 结构体，不涉及任何 GUI 代码或 DSP 代码。

- 输入: LogicInput (参数的只读快照)。

- 输出: RenderState (每个通道的最终 Gain 值 [0.0 - 1.0])。

- 核心算法流程 (每帧计算):

1. 全局扫描: 遍历所有 Solo 参数，判断 HasAnySolo (主通道) 和 HasSubSolo (超低通道)。

2. 通道遍历: 对于每一个通道 i：

- Step A (Solo 优先): 如果 HasAnySolo 为真：

- 如果通道 i 被 Solo -> Open (1.0)。

- 如果通道 i 未 Solo -> Auto-Mute (0.0) (进入静音逻辑)。

- Step B (SUB 特殊联动 - 参考 硬件控制器.md):

- 如果通道 i 是 SUB，且 HasSubSolo 为假 (即只有主声道Solo)，SUB 通道应豁免 Auto-Mute，保持原有状态。

- Step C (Mute 逻辑): 如果未被 Auto-Mute，检查用户 Mute[i] 参数。如果为真 -> User-Mute (0.0)。

- Step D (全局控制): 应用 Dim (-20dB) 和 Cut (Mute All) 的逻辑。

1. 输出: 将计算出的最终增益写入 RenderState。

#### 2.3 模块三：交互状态机 (InteractionState) - UI 专用

您在 架构.md 中提到的 “Select Mode (选择模式)”（点击主 Solo 按钮变绿，然后点击通道才生效），这属于交互逻辑，不属于音频逻辑。

- 位置: 放在 Editor 结构体中，或者一个独立的 UIState 辅助类中。

- 状态定义:
    
        enum InteractionMode {
    
            Normal,
    
            WaitingForSoloTarget, // 对应 IsInSoloSelectionMode
    
            WaitingForMuteTarget, // 对应 IsInMuteSelectionMode
    
        }
    

- 行为逻辑:

- 当用户点击 Sidebar 的 SOLO 大按钮 -> 切换 InteractionMode。

- 当用户点击 矩阵中的 音箱块 ->

- 如果 Normal -> 切换该通道参数。

- 如果 WaitingFor... -> 切换该通道参数，并重置为 Normal。

#### 2.4 模块四：硬件/OSC 映射 (HardwareMapper)

为了解决 硬件控制器.md 中提到的“防循环机制”和双向同步：

- 下行 (Rust -> Hardware):

- 监听 Params 的变化（通过 nih-plug 的回调）。

- 注意：这里发送的是参数状态（按钮亮不亮），但也需要发送逻辑状态（颜色是红还是绿）。

- 改进点: 我们可以将 ChannelLogic 计算出的 RenderState 中的 is_audible 状态广播给硬件，这样硬件的灯光能准确反映 Auto-Mute（例如变暗或变红）。

- 上行 (Hardware -> Rust):

- 接收 /Monitor/Solo/L。

- 直接映射为：context.set_parameter(params.solo_l, new_value)。

- 防循环: 由于 nih-plug 的参数更新机制，如果是设置为相同的值，通常不会触发多余的通知。

---

### 3. 与旧版实现的对比优势

|特性|旧版 C++ (StateManager)|新版 Rust (Logic Core)|
|---|---|---|
|Mute 记忆|需要变量 user_mute_memory 显式存储/恢复|不需要。参数即记忆，Solo 只是临时覆盖了计算结果。|
|SUB 联动|复杂的 if-else 嵌套在事件回调中|清晰的 Pure Function 逻辑分支，易于测试。|
|线程安全|依赖锁，曾有死锁历史|无锁。Params -> RenderState 通过 TripleBuffer 传递。|
|选择模式|混合在全局状态中|仅存在于 GUI 层的交互状态，不污染音频逻辑。|

### 4. 审核建议

如果您同意这个方案，我建议接下来的开发步骤（Phase 2）按以下顺序执行：

1. 定义 Params: 在 lib.rs 中写死 18 个通道的参数。

2. 实现 ChannelLogic: 创建 src/logic.rs，把 架构.md 里的真值表翻译成 Rust 的 compute 函数。

3. 编写测试: 这是关键。不启动 GUI，直接写 cargo test，模拟：

- "开启 L Solo，检查 R 是否 Gain=0"

- "开启 L Solo，再开启 SUB Solo，检查联动"

- "开启 Dim，检查 Gain 是否衰减"

1. 连接 AudioProcessor: 在 process 中调用逻辑并应用 Gain。

您觉得这个“逻辑状态与参数分离，每帧重算”的方案是否符合您的预期？特别是针对“Mute记忆”的处理方式，是否符合您的预期？