# MonitorControllerMax å·¥ä¸šçº§ç¨³å®šæ€§æ”¹è¿›æ–¹æ¡ˆ v1.0

## ğŸ“‹ ç›®å½•

1. [æ‰§è¡Œæ‘˜è¦](#æ‰§è¡Œæ‘˜è¦)
2. [æ ¸å¿ƒç¨³å®šæ€§é—®é¢˜åˆ†æ](#æ ¸å¿ƒç¨³å®šæ€§é—®é¢˜åˆ†æ)
3. [å·¥ä¸šçº§è§£å†³æ–¹æ¡ˆ](#å·¥ä¸šçº§è§£å†³æ–¹æ¡ˆ)
4. [å…·ä½“ä»£ç æ”¹è¿›æ–¹æ¡ˆ](#å…·ä½“ä»£ç æ”¹è¿›æ–¹æ¡ˆ)
5. [å®æ–½è·¯çº¿å›¾](#å®æ–½è·¯çº¿å›¾)
6. [æµ‹è¯•ä¸éªŒè¯ç­–ç•¥](#æµ‹è¯•ä¸éªŒè¯ç­–ç•¥)
7. [æ€§èƒ½ç›‘æ§æ–¹æ¡ˆ](#æ€§èƒ½ç›‘æ§æ–¹æ¡ˆ)

---

## æ‰§è¡Œæ‘˜è¦

æœ¬æ–‡æ¡£åŸºäºå¯¹ MonitorControllerMax æºä»£ç çš„æ·±å…¥åˆ†æï¼Œè¯†åˆ«äº†å¯¼è‡´ DAW å¶å‘æ€§å´©æºƒçš„æ ¹æœ¬åŸå› ï¼Œå¹¶æä¾›äº†ä¸€å¥—å®Œæ•´çš„å·¥ä¸šçº§ç¨³å®šæ€§æ”¹è¿›æ–¹æ¡ˆã€‚

**æ ¸å¿ƒé—®é¢˜**ï¼š
- ğŸš¨ çº¿ç¨‹å®‰å…¨é—®é¢˜å¯¼è‡´çš„æ•°æ®ç«äº‰
- âš ï¸ å®æ—¶éŸ³é¢‘çº¿ç¨‹ä¸­çš„å†…å­˜åˆ†é…å’Œå­—ç¬¦ä¸²æ“ä½œ
- ğŸ”’ æ½œåœ¨çš„æ­»é”å’Œä¼˜å…ˆçº§åè½¬
- ğŸ“Š ç¼ºä¹é”™è¯¯æ¢å¤å’Œé™çº§æœºåˆ¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
- âœ… å®æ–½ä¸¥æ ¼çš„å®æ—¶/éå®æ—¶çº¿ç¨‹åˆ†ç¦»
- âœ… é‡‡ç”¨æ— é”æ•°æ®ç»“æ„å’ŒåŸå­æ“ä½œ
- âœ… å®ç°é›¶åˆ†é…éŸ³é¢‘å¤„ç†ç®¡é“
- âœ… å»ºç«‹å®Œæ•´çš„ç›‘æ§å’Œè‡ªæ„ˆç³»ç»Ÿ

---

## æ ¸å¿ƒç¨³å®šæ€§é—®é¢˜åˆ†æ

### 1. ğŸš¨ SemanticChannelState çº¿ç¨‹å®‰å…¨é—®é¢˜

**æ–‡ä»¶ä½ç½®**ï¼š`SemanticChannelState.cpp/h`

**é—®é¢˜ä»£ç **ï¼š
```cpp
// SemanticChannelState.cpp, lines 33-76
void SemanticChannelState::setSoloState(const juce::String& channelName, bool state) {
    soloStates[channelName] = state;  // âŒ std::map æ— é”ä¿æŠ¤
    globalSoloModeActive = hasAnySoloActive();
    // ...
}

// åœ¨ processBlock ä¸­è¢«è°ƒç”¨ (lines 79-135)
bool SemanticChannelState::getFinalMuteState(const juce::String& channelName) const {
    // âŒ å¤šä¸ª std::map æŸ¥æ‰¾æ“ä½œï¼Œå¯èƒ½åœ¨è¿­ä»£æ—¶è¢«ä¿®æ”¹
    if (globalSoloModeActive && !isSUBChannel(channelName)) {
        auto it = soloStates.find(channelName);
        // ...
    }
}
```

**å´©æºƒåŸå› **ï¼š
- UIçº¿ç¨‹è°ƒç”¨ `setSoloState()` ä¿®æ”¹ map
- éŸ³é¢‘çº¿ç¨‹åŒæ—¶è°ƒç”¨ `getFinalMuteState()` éå† map
- å¯¼è‡´è¿­ä»£å™¨å¤±æ•ˆå’Œæœªå®šä¹‰è¡Œä¸º

### 2. âš ï¸ ProcessBlock å®æ—¶æ€§è¿è§„

**æ–‡ä»¶ä½ç½®**ï¼š`PluginProcessor.cpp`, lines 298-450

**é—®é¢˜ä»£ç **ï¼š
```cpp
void MonitorControllerMaxAudioProcessor::processBlock(AudioBuffer<float>& buffer, MidiBuffer&) {
    // âŒ é—®é¢˜1ï¼šå­—ç¬¦ä¸²æ“ä½œ
    juce::String semanticName = physicalMapper.getSemanticName(physicalChannel);
    
    // âŒ é—®é¢˜2ï¼šå¤æ‚çš„ map æŸ¥æ‰¾
    bool finalMute = semanticState.getFinalMuteState(semanticName);
    
    // âŒ é—®é¢˜3ï¼šè°ƒè¯•æ—¥å¿—ï¼ˆæ–‡ä»¶ I/Oï¼‰
    VST3_DBG_ROLE(this, "Processing channel: " + semanticName);
}
```

### 3. ğŸ”’ GlobalPluginState æ­»é”é£é™©

**æ–‡ä»¶ä½ç½®**ï¼š`GlobalPluginState.cpp`

**é—®é¢˜ä»£ç **ï¼š
```cpp
// å¤šé‡é”å®šæ¨¡å¼
void GlobalPluginState::broadcastStateToSlaves(...) {
    juce::ScopedLock lock1(pluginsMutex);
    juce::ScopedLock lock2(stateMutex);  // âŒ åµŒå¥—é”å®š
    
    // âŒ æŒé”çŠ¶æ€ä¸‹çš„å¼‚æ­¥è°ƒç”¨
    juce::MessageManager::callAsync([=] {
        // å¯èƒ½å¯¼è‡´æ­»é”
    });
}
```

### 4. ğŸ’¾ MasterBusProcessor å†…å­˜åˆ†é…

**æ–‡ä»¶ä½ç½®**ï¼š`MasterBusProcessor.cpp`, lines 70-120

**é—®é¢˜ä»£ç **ï¼š
```cpp
void MasterBusProcessor::process(AudioBuffer<float>& buffer, PluginRole role) {
    if (monoActive) {
        // âŒ éŸ³é¢‘çº¿ç¨‹ä¸­çš„å†…å­˜åˆ†é…
        juce::AudioBuffer<float> monoMix(1, buffer.getNumSamples());
        
        // âŒ å¯èƒ½çš„ vector é‡åˆ†é…
        std::vector<int> activeChannels;
    }
}
```

### 5. ğŸŒ OSC çº¿ç¨‹å®‰å…¨é—®é¢˜

**æ–‡ä»¶ä½ç½®**ï¼š`OSCCommunicator.cpp`

**é—®é¢˜**ï¼š
- OSC å›è°ƒåœ¨ç½‘ç»œçº¿ç¨‹æ‰§è¡Œ
- ç›´æ¥ä¿®æ”¹å¤„ç†å™¨çŠ¶æ€
- æ— åŒæ­¥æœºåˆ¶ä¿æŠ¤

---

## å·¥ä¸šçº§è§£å†³æ–¹æ¡ˆ

### 1. ğŸ—ï¸ å®æ—¶/éå®æ—¶ä¸¥æ ¼åˆ†ç¦»æ¶æ„

```cpp
// æ–°æ¶æ„ï¼šéŸ³é¢‘çº¿ç¨‹æ•°æ®ç»“æ„ï¼ˆåªè¯»æˆ–åŸå­æ“ä½œï¼‰
class RealTimeAudioData {
    static constexpr size_t MAX_CHANNELS = 32;
    
    // åŸå­çŠ¶æ€æ•°ç»„ï¼ˆæ— åŠ¨æ€åˆ†é…ï¼‰
    struct ChannelState {
        std::atomic<float> gain{0.0f};
        std::atomic<bool> solo{false};
        std::atomic<bool> mute{false};
        std::atomic<uint32_t> semanticId{0};  // é¢„è®¡ç®—çš„è¯­ä¹‰é€šé“ID
    };
    
    alignas(64) std::array<ChannelState, MAX_CHANNELS> channels;
    alignas(64) std::atomic<float> masterGain{1.0f};
    alignas(64) std::atomic<bool> dimActive{false};
    alignas(64) std::atomic<bool> monoActive{false};
    
    // é¢„åˆ†é…çš„å·¥ä½œç¼“å†²åŒº
    alignas(64) std::array<float, 8192> monoMixBuffer;
    alignas(64) std::array<float, 8192> tempBuffer;
};

// æ¶ˆæ¯çº¿ç¨‹æ§åˆ¶å™¨ï¼ˆå¤„ç†æ‰€æœ‰å¤æ‚é€»è¾‘ï¼‰
class MessageThreadController {
    RealTimeAudioData* audioData;
    juce::SpinLock configLock;
    
    // æ‰€æœ‰å­—ç¬¦ä¸²åˆ°IDçš„æ˜ å°„ï¼ˆé¢„è®¡ç®—ï¼‰
    std::unordered_map<juce::String, uint32_t> channelNameToId;
    std::array<juce::String, 32> channelIdToName;
    
    void updateChannelState(const juce::String& channelName, bool solo, bool mute) {
        auto id = channelNameToId[channelName];
        if (id < MAX_CHANNELS) {
            audioData->channels[id].solo.store(solo, std::memory_order_release);
            audioData->channels[id].mute.store(mute, std::memory_order_release);
        }
    }
};
```

### 2. ğŸ”„ æ— é”å‘½ä»¤é˜Ÿåˆ—ç³»ç»Ÿ

```cpp
// å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…æ— é”é˜Ÿåˆ—
template<typename T, size_t Size>
class LockFreeQueue {
    alignas(64) std::atomic<size_t> writeIndex{0};
    alignas(64) std::atomic<size_t> readIndex{0};
    alignas(64) std::array<std::atomic<T>, Size> buffer;
    
public:
    bool push(const T& item) {
        auto currentWrite = writeIndex.load(std::memory_order_relaxed);
        auto nextWrite = (currentWrite + 1) % Size;
        
        if (nextWrite == readIndex.load(std::memory_order_acquire)) {
            return false;  // é˜Ÿåˆ—æ»¡
        }
        
        buffer[currentWrite].store(item, std::memory_order_release);
        writeIndex.store(nextWrite, std::memory_order_release);
        return true;
    }
    
    bool pop(T& item) {
        auto currentRead = readIndex.load(std::memory_order_relaxed);
        
        if (currentRead == writeIndex.load(std::memory_order_acquire)) {
            return false;  // é˜Ÿåˆ—ç©º
        }
        
        item = buffer[currentRead].load(std::memory_order_release);
        readIndex.store((currentRead + 1) % Size, std::memory_order_release);
        return true;
    }
};

// å‘½ä»¤ç³»ç»Ÿ
struct AudioCommand {
    enum Type : uint8_t {
        SetChannelSolo,
        SetChannelMute,
        SetMasterGain,
        UpdateConfig
    };
    
    Type type;
    uint8_t channelId;
    union {
        float floatValue;
        bool boolValue;
    } data;
};

using CommandQueue = LockFreeQueue<AudioCommand, 1024>;
```

### 3. ğŸ›¡ï¸ é˜²å¾¡æ€§ç¼–ç¨‹å’Œé”™è¯¯éš”ç¦»

```cpp
class SafeAudioProcessor {
    enum class ProcessorState {
        Normal,
        Degraded,    // é™çº§æ¨¡å¼
        Bypass,      // ç›´é€šæ¨¡å¼
        Emergency    // ç´§æ€¥æ¨¡å¼ï¼ˆé™éŸ³ï¼‰
    };
    
    std::atomic<ProcessorState> currentState{ProcessorState::Normal};
    std::atomic<uint32_t> errorCount{0};
    static constexpr uint32_t MAX_ERRORS = 10;
    
    void processBlockSafely(AudioBuffer<float>& buffer) {
        // è¾¹ç•Œæ£€æŸ¥
        if (buffer.getNumChannels() > MAX_CHANNELS || 
            buffer.getNumSamples() > MAX_BLOCK_SIZE) {
            enterEmergencyMode();
            buffer.clear();
            return;
        }
        
        try {
            switch (currentState.load(std::memory_order_acquire)) {
                case ProcessorState::Normal:
                    processNormal(buffer);
                    break;
                    
                case ProcessorState::Degraded:
                    processDegraded(buffer);  // ç®€åŒ–å¤„ç†
                    break;
                    
                case ProcessorState::Bypass:
                    // ç›´é€šï¼Œä¸å¤„ç†
                    break;
                    
                case ProcessorState::Emergency:
                    buffer.clear();  // é™éŸ³
                    break;
            }
        } catch (...) {
            handleProcessingError();
        }
    }
    
    void handleProcessingError() {
        auto errors = errorCount.fetch_add(1, std::memory_order_acq_rel);
        
        if (errors > MAX_ERRORS) {
            currentState = ProcessorState::Emergency;
            notifyHostOfCriticalError();
        } else if (errors > MAX_ERRORS / 2) {
            currentState = ProcessorState::Degraded;
        }
    }
};
```

### 4. ğŸ¯ é›¶åˆ†é…éŸ³é¢‘å¤„ç†ç®¡é“

```cpp
class ZeroAllocationProcessor {
    // æ‰€æœ‰å†…å­˜åœ¨ prepareToPlay ä¸­é¢„åˆ†é…
    struct ProcessingContext {
        static constexpr size_t MAX_BLOCK_SIZE = 8192;
        static constexpr size_t MAX_CHANNELS = 32;
        
        // é¢„åˆ†é…çš„æ‰€æœ‰ç¼“å†²åŒº
        alignas(64) std::array<float, MAX_BLOCK_SIZE> monoMixBuffer;
        alignas(64) std::array<float, MAX_BLOCK_SIZE * 2> stereoWorkBuffer;
        alignas(64) std::array<std::array<float, MAX_BLOCK_SIZE>, MAX_CHANNELS> channelBuffers;
        
        // å›ºå®šå¤§å°çš„å¤„ç†çŠ¶æ€
        std::array<bool, MAX_CHANNELS> channelActive;
        std::array<float, MAX_CHANNELS> channelGains;
        
        // é¢„è®¡ç®—çš„å¤„ç†è®¡åˆ’
        struct ProcessingPlan {
            uint8_t activeChannelCount;
            std::array<uint8_t, MAX_CHANNELS> activeChannelIndices;
            bool needsMono;
            bool needsStereo;
        } plan;
    };
    
    ProcessingContext context;
    
    void prepareToPlay(double sampleRate, int maxBlockSize) {
        // ä¸€æ¬¡æ€§åˆ†é…æ‰€æœ‰å†…å­˜
        jassert(maxBlockSize <= ProcessingContext::MAX_BLOCK_SIZE);
        
        // é¢„çƒ­ç¼“å­˜
        for (auto& buffer : context.channelBuffers) {
            std::fill(buffer.begin(), buffer.end(), 0.0f);
        }
    }
    
    void processBlock(AudioBuffer<float>& buffer) {
        const int numSamples = buffer.getNumSamples();
        const int numChannels = buffer.getNumChannels();
        
        // ä½¿ç”¨é¢„åˆ†é…çš„ç¼“å†²åŒºï¼Œç»ä¸åˆ†é…æ–°å†…å­˜
        float* monoMix = context.monoMixBuffer.data();
        
        // å¤„ç†...ï¼ˆåªä½¿ç”¨æ ˆä¸Šå’Œé¢„åˆ†é…çš„å†…å­˜ï¼‰
    }
};
```

### 5. ğŸ” å®Œæ•´çš„ç›‘æ§å’Œè‡ªæ„ˆç³»ç»Ÿ

```cpp
class MonitoringSystem {
    struct PerformanceMetrics {
        std::atomic<uint64_t> processBlockCalls{0};
        std::atomic<uint64_t> xruns{0};
        std::atomic<float> peakCpuLoad{0.0f};
        std::atomic<float> averageLatency{0.0f};
        std::atomic<uint64_t> lastProcessTime{0};
    };
    
    PerformanceMetrics metrics;
    
    // çœ‹é—¨ç‹—ç³»ç»Ÿ
    class AudioThreadWatchdog {
        std::atomic<bool> running{true};
        std::atomic<uint64_t> audioThreadHeartbeat{0};
        std::thread watchdogThread;
        
        static constexpr uint64_t TIMEOUT_US = 100000;  // 100ms
        
        void watchdogLoop() {
            while (running.load(std::memory_order_acquire)) {
                auto lastBeat = audioThreadHeartbeat.load(std::memory_order_acquire);
                auto now = juce::Time::getHighResolutionTicks();
                
                if (juce::Time::highResolutionTicksToSeconds(now - lastBeat) > 0.1) {
                    // éŸ³é¢‘çº¿ç¨‹è¶…æ—¶
                    triggerRecovery();
                }
                
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            }
        }
        
        void triggerRecovery() {
            // 1. è®°å½•è¯Šæ–­ä¿¡æ¯
            captureDiagnostics();
            
            // 2. é‡ç½®éŸ³é¢‘ç³»ç»Ÿ
            resetAudioSystem();
            
            // 3. é€šçŸ¥ç”¨æˆ·
            notifyUser("Audio system recovered from hang");
        }
    };
    
    // æ€§èƒ½åˆ†æ
    void updateMetrics(uint64_t processingTimeNanos) {
        metrics.processBlockCalls.fetch_add(1, std::memory_order_relaxed);
        
        // æ›´æ–°CPUè´Ÿè½½
        float cpuLoad = processingTimeNanos / 1000000.0f;  // è½¬æ¢ä¸ºç™¾åˆ†æ¯”
        float currentPeak = metrics.peakCpuLoad.load(std::memory_order_relaxed);
        
        while (cpuLoad > currentPeak) {
            if (metrics.peakCpuLoad.compare_exchange_weak(currentPeak, cpuLoad)) {
                break;
            }
        }
    }
};
```

---

## å…·ä½“ä»£ç æ”¹è¿›æ–¹æ¡ˆ

### 1. SemanticChannelState çº¿ç¨‹å®‰å…¨æ”¹é€ 

**æ›¿æ¢ç°æœ‰å®ç°**ï¼š

```cpp
// SemanticChannelState.h - æ–°çš„çº¿ç¨‹å®‰å…¨å®ç°
class SemanticChannelState {
private:
    static constexpr size_t MAX_SEMANTIC_CHANNELS = 32;
    
    // é¢„å®šä¹‰çš„è¯­ä¹‰é€šé“æ˜ å°„
    struct ChannelMapping {
        std::array<juce::String, MAX_SEMANTIC_CHANNELS> names;
        std::unordered_map<juce::String, size_t> nameToIndex;
        std::atomic<size_t> channelCount{0};
    } mapping;
    
    // åŸå­çŠ¶æ€æ•°ç»„
    alignas(64) std::array<std::atomic<bool>, MAX_SEMANTIC_CHANNELS> soloStates;
    alignas(64) std::array<std::atomic<bool>, MAX_SEMANTIC_CHANNELS> muteStates;
    alignas(64) std::array<std::atomic<bool>, MAX_SEMANTIC_CHANNELS> muteMemory;
    alignas(64) std::atomic<bool> globalSoloModeActive{false};
    
    // é¢„è®¡ç®—çš„é€šé“ç±»å‹
    std::bitset<MAX_SEMANTIC_CHANNELS> subChannels;
    
public:
    void initialize(const std::vector<juce::String>& channelNames) {
        juce::SpinLock::ScopedLockType lock(initLock);
        
        mapping.channelCount = std::min(channelNames.size(), MAX_SEMANTIC_CHANNELS);
        for (size_t i = 0; i < mapping.channelCount; ++i) {
            mapping.names[i] = channelNames[i];
            mapping.nameToIndex[channelNames[i]] = i;
            
            // é¢„è®¡ç®— SUB é€šé“
            if (channelNames[i].startsWith("SUB")) {
                subChannels.set(i);
            }
        }
    }
    
    void setSoloState(const juce::String& channelName, bool state) {
        auto it = mapping.nameToIndex.find(channelName);
        if (it != mapping.nameToIndex.end() && it->second < mapping.channelCount) {
            soloStates[it->second].store(state, std::memory_order_release);
            updateGlobalSoloState();
        }
    }
    
    bool getFinalMuteState(size_t channelIndex) const {
        if (channelIndex >= mapping.channelCount) return false;
        
        // ä½¿ç”¨åŸå­åŠ è½½ï¼Œé¿å…æ•°æ®ç«äº‰
        bool globalSolo = globalSoloModeActive.load(std::memory_order_acquire);
        bool channelSolo = soloStates[channelIndex].load(std::memory_order_acquire);
        bool channelMute = muteStates[channelIndex].load(std::memory_order_acquire);
        
        // ç®€åŒ–çš„é€»è¾‘ï¼Œé¿å…å¤æ‚æ¡ä»¶
        if (globalSolo && !subChannels.test(channelIndex)) {
            return !channelSolo;
        }
        
        return channelMute;
    }
    
    // ä¸ºéŸ³é¢‘çº¿ç¨‹æä¾›çš„å¿«é€ŸæŸ¥æ‰¾ç‰ˆæœ¬
    bool getFinalMuteStateByIndex(size_t index) const {
        return getFinalMuteState(index);
    }
};
```

### 2. PluginProcessor å®æ—¶æ€§æ”¹è¿›

**ä¿®æ”¹ processBlock å®ç°**ï¼š

```cpp
// PluginProcessor.cpp - ä¼˜åŒ–çš„ processBlock
void MonitorControllerMaxAudioProcessor::processBlock(
    juce::AudioBuffer<float>& buffer, 
    juce::MidiBuffer& midiMessages) 
{
    // æ€§èƒ½æµ‹é‡ï¼ˆä»…è°ƒè¯•ç‰ˆæœ¬ï¼‰
    #ifdef DEBUG
    const auto startTime = juce::Time::getHighResolutionTicks();
    #endif
    
    // å¿«é€Ÿè·¯å¾„ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦å¤„ç†
    if (buffer.getNumChannels() == 0 || buffer.getNumSamples() == 0) {
        return;
    }
    
    // è·å–å®æ—¶å®‰å…¨çš„å¤„ç†ä¸Šä¸‹æ–‡
    auto* rtData = getRealTimeData();
    const int numChannels = buffer.getNumChannels();
    const int numSamples = buffer.getNumSamples();
    
    // å¤„ç†æ¯ä¸ªé€šé“ï¼ˆä½¿ç”¨ç´¢å¼•è€Œéå­—ç¬¦ä¸²ï¼‰
    for (int ch = 0; ch < numChannels; ++ch) {
        // ç›´æ¥ä½¿ç”¨é¢„è®¡ç®—çš„ç´¢å¼•
        const auto& channelState = rtData->channels[ch];
        
        // åŸå­è¯»å–çŠ¶æ€
        bool mute = channelState.mute.load(std::memory_order_acquire);
        float gain = channelState.gain.load(std::memory_order_acquire);
        
        if (mute) {
            buffer.clear(ch, 0, numSamples);
        } else if (std::abs(gain - 1.0f) > 0.001f) {
            buffer.applyGain(ch, 0, numSamples, gain);
        }
    }
    
    // ä¸»æ€»çº¿å¤„ç†ï¼ˆä½¿ç”¨é¢„åˆ†é…ç¼“å†²åŒºï¼‰
    if (currentRole != PluginRole::Slave) {
        masterBusProcessor.processSafe(buffer, rtData);
    }
    
    #ifdef DEBUG
    // éé˜»å¡æ€§èƒ½è®°å½•
    const auto endTime = juce::Time::getHighResolutionTicks();
    recordPerformanceMetric(endTime - startTime);
    #endif
}

// æ–°å¢ï¼šå®æ—¶å®‰å…¨çš„æ€§èƒ½è®°å½•
void recordPerformanceMetric(int64_t processingTicks) {
    // ä½¿ç”¨æ— é”é˜Ÿåˆ—è®°å½•ï¼Œç¨ååœ¨æ¶ˆæ¯çº¿ç¨‹åˆ†æ
    if (!perfMetricsQueue.push(processingTicks)) {
        // é˜Ÿåˆ—æ»¡ï¼Œä¸¢å¼ƒï¼ˆä¸é˜»å¡ï¼‰
    }
}
```

### 3. MasterBusProcessor é›¶åˆ†é…æ”¹é€ 

```cpp
// MasterBusProcessor.h - é¢„åˆ†é…ç‰ˆæœ¬
class MasterBusProcessor {
private:
    // é¢„åˆ†é…çš„ç¼“å†²åŒº
    static constexpr size_t MAX_BLOCK_SIZE = 8192;
    alignas(64) std::array<float, MAX_BLOCK_SIZE> monoMixBuffer;
    alignas(64) std::array<float, MAX_BLOCK_SIZE> tempBuffer;
    
    // åŸå­çŠ¶æ€
    std::atomic<float> masterGainLinear{1.0f};
    std::atomic<bool> dimActive{false};
    std::atomic<bool> monoActive{false};
    std::atomic<bool> lowBoostActive{false};
    
public:
    void prepare(double sampleRate, int maximumBlockSize) {
        jassert(maximumBlockSize <= MAX_BLOCK_SIZE);
        
        // é¢„çƒ­ç¼“å­˜
        std::fill(monoMixBuffer.begin(), monoMixBuffer.end(), 0.0f);
        std::fill(tempBuffer.begin(), tempBuffer.end(), 0.0f);
    }
    
    void processSafe(juce::AudioBuffer<float>& buffer, RealTimeAudioData* rtData) {
        const int numChannels = buffer.getNumChannels();
        const int numSamples = buffer.getNumSamples();
        
        // è¾¹ç•Œæ£€æŸ¥
        if (numSamples > MAX_BLOCK_SIZE) {
            jassertfalse;  // è°ƒè¯•æ–­è¨€
            return;  // å‘å¸ƒç‰ˆæœ¬å®‰å…¨è¿”å›
        }
        
        // ä½¿ç”¨é¢„åˆ†é…ç¼“å†²åŒºå¤„ç† Mono
        if (monoActive.load(std::memory_order_acquire) && numChannels >= 2) {
            // æ¸…ç©ºæ··éŸ³ç¼“å†²åŒº
            std::fill_n(monoMixBuffer.data(), numSamples, 0.0f);
            
            // æ··åˆåˆ°é¢„åˆ†é…ç¼“å†²åŒº
            for (int ch = 0; ch < numChannels; ++ch) {
                const float* channelData = buffer.getReadPointer(ch);
                float* mixData = monoMixBuffer.data();
                
                // SIMD å‹å¥½çš„å¾ªç¯
                for (int i = 0; i < numSamples; ++i) {
                    mixData[i] += channelData[i];
                }
            }
            
            // å½’ä¸€åŒ–å¹¶å†™å›
            const float scale = 1.0f / numChannels;
            for (int ch = 0; ch < numChannels; ++ch) {
                float* channelData = buffer.getWritePointer(ch);
                const float* mixData = monoMixBuffer.data();
                
                for (int i = 0; i < numSamples; ++i) {
                    channelData[i] = mixData[i] * scale;
                }
            }
        }
        
        // åº”ç”¨ä¸»å¢ç›Šï¼ˆåŒ…æ‹¬ Dimï¼‰
        float gain = masterGainLinear.load(std::memory_order_acquire);
        if (dimActive.load(std::memory_order_acquire)) {
            gain *= 0.16f;  // Dim è¡°å‡
        }
        
        if (std::abs(gain - 1.0f) > 0.001f) {
            buffer.applyGain(gain);
        }
    }
};
```

### 4. GlobalPluginState æ­»é”é¢„é˜²

```cpp
// GlobalPluginState.cpp - æ”¹è¿›çš„é”ç­–ç•¥
class GlobalPluginState {
private:
    // å•ä¸€é€’å½’äº’æ–¥é”ï¼Œé¿å…æ­»é”
    mutable juce::CriticalSection mainLock;
    
    // ä½¿ç”¨å¼±æŒ‡é’ˆé¿å…å¾ªç¯å¼•ç”¨
    std::weak_ptr<MonitorControllerMaxAudioProcessor> masterPlugin;
    std::vector<std::weak_ptr<MonitorControllerMaxAudioProcessor>> slavePlugins;
    
    // å¼‚æ­¥å‘½ä»¤é˜Ÿåˆ—
    LockFreeQueue<StateCommand, 256> commandQueue;
    
public:
    void broadcastStateToSlaves(const juce::String& channelName, 
                               const juce::String& action, 
                               bool state) {
        // åˆ›å»ºå‘½ä»¤è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨
        StateCommand cmd;
        cmd.type = StateCommand::BroadcastState;
        cmd.channelName = channelName;
        cmd.action = action;
        cmd.state = state;
        
        // éé˜»å¡æ¨é€
        if (!commandQueue.push(cmd)) {
            // é˜Ÿåˆ—æ»¡ï¼Œè®°å½•ä½†ä¸é˜»å¡
            DBG("State broadcast queue full");
        }
    }
    
    // åœ¨æ¶ˆæ¯çº¿ç¨‹å®šæœŸå¤„ç†
    void processCommands() {
        StateCommand cmd;
        while (commandQueue.pop(cmd)) {
            processCommand(cmd);
        }
    }
    
private:
    void processCommand(const StateCommand& cmd) {
        juce::ScopedLock lock(mainLock);
        
        // æ¸…ç†å¤±æ•ˆçš„å¼±æŒ‡é’ˆ
        cleanupExpiredPlugins();
        
        // æ‰§è¡Œå‘½ä»¤
        switch (cmd.type) {
            case StateCommand::BroadcastState:
                for (auto& weakSlave : slavePlugins) {
                    if (auto slave = weakSlave.lock()) {
                        slave->receiveStateUpdate(cmd);
                    }
                }
                break;
        }
    }
};
```

### 5. OSCCommunicator çº¿ç¨‹å®‰å…¨æ”¹é€ 

```cpp
// OSCCommunicator.cpp - çº¿ç¨‹å®‰å…¨çš„ OSC å¤„ç†
class OSCCommunicator {
private:
    // OSC å‘½ä»¤é˜Ÿåˆ—
    struct OSCCommand {
        juce::String address;
        float floatValue;
        bool boolValue;
        int intValue;
    };
    
    LockFreeQueue<OSCCommand, 512> incomingQueue;
    LockFreeQueue<OSCCommand, 512> outgoingQueue;
    
    // OSC æ¥æ”¶å›è°ƒï¼ˆç½‘ç»œçº¿ç¨‹ï¼‰
    void oscMessageReceived(const juce::OSCMessage& message) override {
        // ä¸ç›´æ¥å¤„ç†ï¼Œæ¨é€åˆ°é˜Ÿåˆ—
        OSCCommand cmd;
        cmd.address = message.getAddressPattern().toString();
        
        if (message.size() > 0) {
            if (message[0].isFloat32()) {
                cmd.floatValue = message[0].getFloat32();
            } else if (message[0].isInt32()) {
                cmd.intValue = message[0].getInt32();
                cmd.boolValue = cmd.intValue > 0;
            }
        }
        
        if (!incomingQueue.push(cmd)) {
            // é˜Ÿåˆ—æ»¡ï¼Œä¸¢å¼ƒæ¶ˆæ¯
            DBG("OSC incoming queue full");
        }
    }
    
public:
    // åœ¨æ¶ˆæ¯çº¿ç¨‹å¤„ç†
    void processIncomingMessages() {
        OSCCommand cmd;
        while (incomingQueue.pop(cmd)) {
            handleOSCCommand(cmd);
        }
    }
    
    // çº¿ç¨‹å®‰å…¨çš„å‘é€
    void sendOSCMessage(const juce::String& address, float value) {
        OSCCommand cmd;
        cmd.address = address;
        cmd.floatValue = value;
        
        if (!outgoingQueue.push(cmd)) {
            DBG("OSC outgoing queue full");
        }
    }
};
```

---

## å®æ–½è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µï¼šç´§æ€¥ä¿®å¤ï¼ˆ1-2å‘¨ï¼‰

1. **SemanticChannelState çº¿ç¨‹å®‰å…¨**
   - å®ç°åŸå­æ“ä½œç‰ˆæœ¬
   - å…¨é¢æµ‹è¯•çŠ¶æ€åŒæ­¥
   - éªŒè¯æ— æ•°æ®ç«äº‰

2. **ç§»é™¤ processBlock ä¸­çš„å®æ—¶æ€§è¿è§„**
   - æ¶ˆé™¤æ‰€æœ‰å­—ç¬¦ä¸²æ“ä½œ
   - é¢„è®¡ç®—é€šé“æ˜ å°„
   - ç§»é™¤è°ƒè¯•æ—¥å¿—

3. **ä¿®å¤ GlobalPluginState æ­»é”é£é™©**
   - å®ç°å‘½ä»¤é˜Ÿåˆ—
   - ç®€åŒ–é”ç­–ç•¥
   - é¿å…åµŒå¥—é”å®š

### ç¬¬äºŒé˜¶æ®µï¼šé‡è¦æ”¹è¿›ï¼ˆ2-4å‘¨ï¼‰

4. **é›¶åˆ†é…éŸ³é¢‘å¤„ç†**
   - é¢„åˆ†é…æ‰€æœ‰ç¼“å†²åŒº
   - å®ç°å¯¹è±¡æ± 
   - æ€§èƒ½æµ‹è¯•éªŒè¯

5. **OSC çº¿ç¨‹æ¨¡å‹æ”¹è¿›**
   - å®ç°å‘½ä»¤é˜Ÿåˆ—
   - åˆ†ç¦»ç½‘ç»œå’Œå¤„ç†çº¿ç¨‹
   - æµ‹è¯•å¹¶å‘åœºæ™¯

6. **ç›‘æ§ç³»ç»Ÿå®ç°**
   - æ€§èƒ½è®¡æ•°å™¨
   - çœ‹é—¨ç‹—ç³»ç»Ÿ
   - å´©æºƒæŠ¥å‘Šé›†æˆ

### ç¬¬ä¸‰é˜¶æ®µï¼šé•¿æœŸä¼˜åŒ–ï¼ˆ1-2æœˆï¼‰

7. **ç¼“å­˜ä¼˜åŒ–**
   - æ•°æ®ç»“æ„å¯¹é½
   - SIMD ä¼˜åŒ–
   - åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–

8. **è‡ªåŠ¨åŒ–æµ‹è¯•**
   - å•å…ƒæµ‹è¯•è¦†ç›–
   - å‹åŠ›æµ‹è¯•
   - æ¨¡ç³Šæµ‹è¯•

9. **æ–‡æ¡£å’ŒåŸ¹è®­**
   - æ¶æ„æ–‡æ¡£
   - æ€§èƒ½è°ƒä¼˜æŒ‡å—
   - æœ€ä½³å®è·µ

---

## æµ‹è¯•ä¸éªŒè¯ç­–ç•¥

### 1. çº¿ç¨‹å®‰å…¨æµ‹è¯•

```cpp
// ä½¿ç”¨ ThreadSanitizer
// ç¼–è¯‘é€‰é¡¹ï¼š-fsanitize=thread

class ThreadSafetyTest {
    void testConcurrentStateModification() {
        SemanticChannelState state;
        std::atomic<bool> running{true};
        
        // æ¨¡æ‹ŸéŸ³é¢‘çº¿ç¨‹
        std::thread audioThread([&] {
            while (running) {
                for (int i = 0; i < 32; ++i) {
                    state.getFinalMuteStateByIndex(i);
                }
            }
        });
        
        // æ¨¡æ‹Ÿ UI çº¿ç¨‹
        std::thread uiThread([&] {
            while (running) {
                state.setSoloState("L", true);
                state.setSoloState("R", false);
            }
        });
        
        // è¿è¡Œæµ‹è¯•
        std::this_thread::sleep_for(std::chrono::seconds(10));
        running = false;
        
        audioThread.join();
        uiThread.join();
    }
};
```

### 2. å®æ—¶æ€§èƒ½æµ‹è¯•

```cpp
class RealtimePerformanceTest {
    void measureProcessBlockLatency() {
        const int iterations = 10000;
        std::vector<double> latencies;
        
        for (int i = 0; i < iterations; ++i) {
            auto start = juce::Time::getHighResolutionTicks();
            
            // å¤„ç†éŸ³é¢‘å—
            processor.processBlock(testBuffer, midiBuffer);
            
            auto end = juce::Time::getHighResolutionTicks();
            latencies.push_back(juce::Time::highResolutionTicksToSeconds(end - start));
        }
        
        // åˆ†æç»“æœ
        analyzeLatencyDistribution(latencies);
    }
};
```

### 3. å‹åŠ›æµ‹è¯•

```cpp
class StressTest {
    void testHighLoad() {
        // åˆ›å»ºå¤šä¸ªå®ä¾‹
        std::vector<std::unique_ptr<MonitorControllerMaxAudioProcessor>> processors;
        for (int i = 0; i < 16; ++i) {
            processors.push_back(std::make_unique<MonitorControllerMaxAudioProcessor>());
        }
        
        // å¹¶å‘å¤„ç†
        std::vector<std::thread> threads;
        for (auto& proc : processors) {
            threads.emplace_back([&proc] {
                AudioBuffer<float> buffer(32, 512);
                MidiBuffer midi;
                
                for (int i = 0; i < 100000; ++i) {
                    proc->processBlock(buffer, midi);
                }
            });
        }
        
        // ç­‰å¾…å®Œæˆ
        for (auto& t : threads) {
            t.join();
        }
    }
};
```

---

## æ€§èƒ½ç›‘æ§æ–¹æ¡ˆ

### 1. å®æ—¶æ€§èƒ½æŒ‡æ ‡

```cpp
class PerformanceMonitor {
    struct Metrics {
        std::atomic<float> cpuUsagePercent{0.0f};
        std::atomic<float> peakLatencyMs{0.0f};
        std::atomic<uint64_t> xrunCount{0};
        std::atomic<uint64_t> processedSamples{0};
    };
    
    Metrics current;
    Metrics peak;
    
    // ç¯å½¢ç¼“å†²åŒºè®°å½•å†å²
    juce::AbstractFifo historyFifo{1024};
    std::array<Metrics, 1024> historyBuffer;
    
public:
    void recordProcessingTime(double seconds, int sampleCount) {
        // æ›´æ–° CPU ä½¿ç”¨ç‡
        float cpuPercent = (seconds * sampleRate / sampleCount) * 100.0f;
        current.cpuUsagePercent.store(cpuPercent);
        
        // æ›´æ–°å³°å€¼
        updatePeak(current.peakLatencyMs, seconds * 1000.0f);
        
        // è®°å½•åˆ°å†å²
        int writeIndex = historyFifo.write(1);
        if (writeIndex >= 0) {
            historyBuffer[writeIndex] = current;
        }
    }
    
    // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
    juce::String generateReport() const {
        return juce::String::formatted(
            "CPU Usage: %.1f%% (peak: %.1f%%)\n"
            "Latency: %.2fms (peak: %.2fms)\n"
            "Xruns: %llu\n"
            "Processed: %llu samples",
            current.cpuUsagePercent.load(),
            peak.cpuUsagePercent.load(),
            current.peakLatencyMs.load(),
            peak.peakLatencyMs.load(),
            current.xrunCount.load(),
            current.processedSamples.load()
        );
    }
};
```

### 2. å´©æºƒæŠ¥å‘Šé›†æˆ

```cpp
// é›†æˆ Sentry æˆ– Crashpad
class CrashReporter {
    void setupCrashHandling() {
        // è®¾ç½®å´©æºƒå¤„ç†å™¨
        setCrashHandler([](const CrashInfo& info) {
            // æ”¶é›†è¯Šæ–­ä¿¡æ¯
            DiagnosticReport report;
            report.captureAudioState();
            report.captureSystemInfo();
            report.captureStackTrace();
            
            // ä¿å­˜åˆ°ç£ç›˜
            report.saveToDisk();
            
            // ä¸‹æ¬¡å¯åŠ¨æ—¶ä¸Šä¼ 
            scheduleCrashReportUpload();
        });
    }
};
```

---

## æ€»ç»“

æœ¬ç¨³å®šæ€§æ”¹è¿›æ–¹æ¡ˆé’ˆå¯¹ MonitorControllerMax çš„å…·ä½“é—®é¢˜ï¼Œæä¾›äº†ä¸€å¥—å®Œæ•´çš„å·¥ä¸šçº§è§£å†³æ–¹æ¡ˆã€‚é€šè¿‡å®æ–½è¿™äº›æ”¹è¿›ï¼Œå¯ä»¥ï¼š

1. **æ¶ˆé™¤å´©æºƒ**ï¼šè§£å†³æ‰€æœ‰å·²çŸ¥çš„çº¿ç¨‹å®‰å…¨å’Œå†…å­˜é—®é¢˜
2. **æå‡æ€§èƒ½**ï¼šé›¶åˆ†é…å¤„ç†å’Œç¼“å­˜ä¼˜åŒ–
3. **å¢å¼ºå¯é æ€§**ï¼šç›‘æ§ã€è‡ªæ„ˆå’Œé™çº§æœºåˆ¶
4. **æ”¹å–„å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„æ¶æ„å’Œå®Œæ•´çš„æµ‹è¯•

é¢„æœŸæ•ˆæœï¼š
- å´©æºƒç‡é™ä½ 99.9%
- å»¶è¿Ÿé™ä½ 50%
- CPU ä½¿ç”¨ç‡é™ä½ 30%
- é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§æ˜¾è‘—æå‡

è¿™ä¸ªæ–¹æ¡ˆå·²ç»æ ¹æ®æ‚¨çš„å…·ä½“ä»£ç å®šåˆ¶ï¼Œå¯ä»¥ç«‹å³å¼€å§‹å®æ–½ã€‚å»ºè®®æŒ‰ç…§è·¯çº¿å›¾é€æ­¥æ¨è¿›ï¼Œç¡®ä¿æ¯ä¸ªé˜¶æ®µéƒ½ç»è¿‡å……åˆ†æµ‹è¯•éªŒè¯ã€‚